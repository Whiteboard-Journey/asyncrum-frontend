{"version":3,"file":"static/js/872.f59b9a77.chunk.js","mappings":"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","sources":["../node_modules/automation-events/build/es5/bundle.js","../node_modules/broker-factory/src/helpers/port-map.ts","../node_modules/broker-factory/src/module.ts","../node_modules/broker-factory/src/helpers/extend-broker-implementation.ts","../node_modules/broker-factory/src/guards/message-port.ts","../node_modules/compilerr/build/es5/bundle.js","../node_modules/dashify/index.js","../node_modules/extendable-media-recorder-wav-encoder-broker/src/module.ts","../node_modules/extendable-media-recorder-wav-encoder/src/module.ts","../node_modules/extendable-media-recorder-wav-encoder/src/worker/worker.ts","../node_modules/media-encoder-host-broker/src/module.ts","../node_modules/media-encoder-host/src/module.ts","../node_modules/media-encoder-host/src/worker/worker.ts","../node_modules/extendable-media-recorder/src/factories/invalid-modification-error.ts","../node_modules/extendable-media-recorder/src/factories/not-supported-error.ts","../node_modules/rxjs-interop/source/symbols.ts","../node_modules/rxjs-interop/source/to-observer.ts","../node_modules/subscribable-things/src/factories/animation-frame.ts","../node_modules/subscribable-things/src/functions/emit-not-supported-error.ts","../node_modules/subscribable-things/src/module.ts","../node_modules/subscribable-things/src/factories/window.ts","../node_modules/subscribable-things/src/factories/wrap-subscribe-function.ts","../node_modules/rxjs-interop/source/patch.ts","../node_modules/subscribable-things/src/factories/mutations.ts","../node_modules/subscribable-things/src/factories/map-subscribable-thing.ts","../node_modules/subscribable-things/src/factories/prepend-subscribable-thing.ts","../node_modules/subscribable-things/src/factories/attribute.ts","../node_modules/subscribable-things/src/factories/geolocation.ts","../node_modules/subscribable-things/src/factories/intersections.ts","../node_modules/subscribable-things/src/factories/media-devices.ts","../node_modules/subscribable-things/src/factories/media-query-match.ts","../node_modules/subscribable-things/src/factories/metrics.ts","../node_modules/subscribable-things/src/factories/midi-inputs.ts","../node_modules/subscribable-things/src/factories/midi-outputs.ts","../node_modules/subscribable-things/src/factories/on.ts","../node_modules/subscribable-things/src/factories/online.ts","../node_modules/subscribable-things/src/factories/permission-state.ts","../node_modules/subscribable-things/src/factories/reports.ts","../node_modules/subscribable-things/src/factories/resizes.ts","../node_modules/subscribable-things/src/factories/unhandled-rejection.ts","../node_modules/subscribable-things/src/factories/video-frame.ts","../node_modules/subscribable-things/src/factories/wake-lock.ts","../node_modules/worker-factory/src/helpers/error-renderers.ts","../node_modules/recorder-audio-worklet/src/module.ts","../node_modules/worker-factory/src/helpers/extend-worker-implementation.ts","../node_modules/recorder-audio-worklet/src/factories/add-recorder-audio-worklet-module.ts","../node_modules/recorder-audio-worklet/src/worklet/worklet.ts","../node_modules/recorder-audio-worklet/src/factories/recorder-audio-worklet-node-factory.ts","../node_modules/recorder-audio-worklet/src/factories/listener.ts","../node_modules/recorder-audio-worklet/src/factories/post-message-factory.ts","../node_modules/recorder-audio-worklet/src/functions/validate-state.ts","../node_modules/standardized-audio-context/src/globals.ts","../node_modules/standardized-audio-context/src/helpers/is-constructible.ts","../node_modules/standardized-audio-context/src/helpers/split-import-statements.ts","../node_modules/standardized-audio-context/src/factories/add-audio-worklet-module.ts","../node_modules/standardized-audio-context/src/helpers/get-value-for-key.ts","../node_modules/standardized-audio-context/src/helpers/pick-element-from-set.ts","../node_modules/standardized-audio-context/src/helpers/delete-passive-input-connection-to-audio-node.ts","../node_modules/standardized-audio-context/src/helpers/get-event-listeners-of-audio-node.ts","../node_modules/standardized-audio-context/src/helpers/set-internal-state-to-active.ts","../node_modules/standardized-audio-context/src/guards/audio-worklet-node.ts","../node_modules/standardized-audio-context/src/helpers/set-internal-state-to-passive.ts","../node_modules/standardized-audio-context/src/helpers/set-internal-state-to-passive-when-necessary.ts","../node_modules/standardized-audio-context/src/factories/analyser-node-constructor.ts","../node_modules/standardized-audio-context/src/helpers/is-owned-by-context.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.ts","../node_modules/standardized-audio-context/src/factories/index-size-error.ts","../node_modules/standardized-audio-context/src/helpers/wrap-audio-buffer-get-channel-data-method.ts","../node_modules/standardized-audio-context/src/factories/audio-buffer-constructor.ts","../node_modules/standardized-audio-context/src/constants.ts","../node_modules/standardized-audio-context/src/helpers/is-active-audio-node.ts","../node_modules/standardized-audio-context/src/factories/audio-buffer-source-node-constructor.ts","../node_modules/standardized-audio-context/src/helpers/get-audio-node-connections.ts","../node_modules/standardized-audio-context/src/helpers/get-audio-param-connections.ts","../node_modules/standardized-audio-context/src/helpers/deactivate-active-audio-node-input-connections.ts","../node_modules/standardized-audio-context/src/guards/audio-buffer-source-node.ts","../node_modules/standardized-audio-context/src/guards/biquad-filter-node.ts","../node_modules/standardized-audio-context/src/guards/constant-source-node.ts","../node_modules/standardized-audio-context/src/guards/gain-node.ts","../node_modules/standardized-audio-context/src/guards/oscillator-node.ts","../node_modules/standardized-audio-context/src/guards/stereo-panner-node.ts","../node_modules/standardized-audio-context/src/helpers/deactivate-audio-graph.ts","../node_modules/standardized-audio-context/src/helpers/is-valid-latency-hint.ts","../node_modules/standardized-audio-context/src/guards/audio-node.ts","../node_modules/standardized-audio-context/src/guards/audio-node-output-connection.ts","../node_modules/standardized-audio-context/src/helpers/insert-element-in-set.ts","../node_modules/standardized-audio-context/src/helpers/add-active-input-connection-to-audio-param.ts","../node_modules/standardized-audio-context/src/helpers/add-passive-input-connection-to-audio-param.ts","../node_modules/standardized-audio-context/src/guards/native-audio-node-faker.ts","../node_modules/standardized-audio-context/src/helpers/connect-native-audio-node-to-native-audio-node.ts","../node_modules/standardized-audio-context/src/helpers/delete-active-input-connection.ts","../node_modules/standardized-audio-context/src/helpers/delete-event-listeners-of-audio-node.ts","../node_modules/standardized-audio-context/src/helpers/delete-passive-input-connection-to-audio-param.ts","../node_modules/standardized-audio-context/src/helpers/disconnect-native-audio-node-from-native-audio-node.ts","../node_modules/standardized-audio-context/src/helpers/get-native-audio-node.ts","../node_modules/standardized-audio-context/src/helpers/get-native-audio-param.ts","../node_modules/standardized-audio-context/src/helpers/is-part-of-a-cycle.ts","../node_modules/standardized-audio-context/src/helpers/is-passive-audio-node.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-node-disconnect-method-support.ts","../node_modules/standardized-audio-context/src/helpers/visit-each-audio-node-once.ts","../node_modules/standardized-audio-context/src/guards/native-audio-node.ts","../node_modules/standardized-audio-context/src/helpers/wrap-audio-node-disconnect-method.ts","../node_modules/standardized-audio-context/src/factories/audio-node-constructor.ts","../node_modules/standardized-audio-context/src/helpers/delete-active-input-connection-to-audio-param.ts","../node_modules/standardized-audio-context/src/read-only-map.ts","../node_modules/standardized-audio-context/src/factories/audio-worklet-node-constructor.ts","../node_modules/standardized-audio-context/src/helpers/copy-from-channel.ts","../node_modules/standardized-audio-context/src/helpers/copy-to-channel.ts","../node_modules/standardized-audio-context/src/helpers/create-nested-arrays.ts","../node_modules/standardized-audio-context/src/helpers/get-audio-worklet-processor.ts","../node_modules/standardized-audio-context/src/factories/audio-worklet-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/biquad-filter-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/channel-merger-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/channel-splitter-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/constant-source-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/convolver-node-constructor.ts","../node_modules/standardized-audio-context/src/helpers/detach-array-buffer.ts","../node_modules/standardized-audio-context/src/factories/delay-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/disconnect-multiple-outputs.ts","../node_modules/standardized-audio-context/src/factories/dynamics-compressor-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/gain-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/invalid-state-error.ts","../node_modules/standardized-audio-context/src/factories/invalid-access-error.ts","../node_modules/standardized-audio-context/src/factories/iir-filter-node-constructor.ts","../node_modules/standardized-audio-context/src/helpers/filter-buffer.ts","../node_modules/standardized-audio-context/src/factories/iir-filter-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/media-stream-audio-destination-node-constructor.ts","../node_modules/standardized-audio-context/src/helpers/test-promise-support.ts","../node_modules/standardized-audio-context/src/factories/minimal-offline-audio-context-constructor.ts","../node_modules/standardized-audio-context/src/helpers/assign-native-audio-node-option.ts","../node_modules/standardized-audio-context/src/helpers/assign-native-audio-node-options.ts","../node_modules/standardized-audio-context/src/helpers/test-analyser-node-get-float-time-domain-data-method-support.ts","../node_modules/standardized-audio-context/src/helpers/assign-native-audio-node-audio-param-value.ts","../node_modules/standardized-audio-context/src/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.ts","../node_modules/standardized-audio-context/src/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.ts","../node_modules/standardized-audio-context/src/helpers/compute-buffer-size.ts","../node_modules/standardized-audio-context/src/helpers/clone-audio-worklet-node-options.ts","../node_modules/standardized-audio-context/src/helpers/create-audio-worklet-processor-promise.ts","../node_modules/standardized-audio-context/src/factories/native-biquad-filter-node.ts","../node_modules/standardized-audio-context/src/factories/native-channel-splitter-node.ts","../node_modules/standardized-audio-context/src/helpers/wrap-channel-splitter-node.ts","../node_modules/standardized-audio-context/src/helpers/intercept-connections.ts","../node_modules/standardized-audio-context/src/factories/native-delay-node.ts","../node_modules/standardized-audio-context/src/factories/native-gain-node.ts","../node_modules/standardized-audio-context/src/factories/native-iir-filter-node-faker-factory.ts","../node_modules/standardized-audio-context/src/factories/cache-test-result.ts","../node_modules/standardized-audio-context/src/factories/get-native-context.ts","../node_modules/standardized-audio-context/src/factories/add-audio-node-connections.ts","../node_modules/standardized-audio-context/src/factories/convert-number-to-unsigned-long.ts","../node_modules/standardized-audio-context/src/factories/add-audio-param-connections.ts","../node_modules/standardized-audio-context/src/factories/native-script-processor-node.ts","../node_modules/standardized-audio-context/src/factories/not-supported-error.ts","../node_modules/standardized-audio-context/src/factories/offline-audio-context-constructor.ts","../node_modules/standardized-audio-context/src/factories/oscillator-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/panner-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/periodic-wave-constructor.ts","../node_modules/standardized-audio-context/src/factories/stereo-panner-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/unknown-error.ts","../node_modules/standardized-audio-context/src/factories/wave-shaper-node-constructor.ts","../node_modules/standardized-audio-context/src/helpers/get-first-sample.ts","../node_modules/standardized-audio-context/src/helpers/is-dc-curve.ts","../node_modules/standardized-audio-context/src/helpers/overwrite-accessors.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support.ts","../node_modules/standardized-audio-context/src/helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.ts","../node_modules/standardized-audio-context/src/helpers/wrap-event-listener.ts","../node_modules/standardized-audio-context/src/module.ts","../node_modules/standardized-audio-context/src/factories/add-active-input-connection-to-audio-node.ts","../node_modules/standardized-audio-context/src/factories/add-passive-input-connection-to-audio-node.ts","../node_modules/standardized-audio-context/src/factories/delete-active-input-connection-to-audio-node.ts","../node_modules/standardized-audio-context/src/factories/get-audio-node-tail-time.ts","../node_modules/standardized-audio-context/src/factories/window.ts","../node_modules/standardized-audio-context/src/factories/native-analyser-node-factory.ts","../node_modules/standardized-audio-context/src/helpers/wrap-analyser-node-get-float-time-domain-data-method.ts","../node_modules/standardized-audio-context/src/factories/get-audio-node-renderer.ts","../node_modules/standardized-audio-context/src/factories/render-inputs-of-audio-node.ts","../node_modules/standardized-audio-context/src/factories/analyser-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/native-offline-audio-context-constructor.ts","../node_modules/standardized-audio-context/src/factories/is-native-offline-audio-context.ts","../node_modules/standardized-audio-context/src/factories/event-target-constructor.ts","../node_modules/standardized-audio-context/src/factories/native-audio-context-constructor.ts","../node_modules/standardized-audio-context/src/factories/is-native-audio-context.ts","../node_modules/standardized-audio-context/src/factories/is-native-audio-node.ts","../node_modules/standardized-audio-context/src/factories/is-native-audio-param.ts","../node_modules/standardized-audio-context/src/factories/native-audio-worklet-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/add-connection-to-audio-node.ts","../node_modules/standardized-audio-context/src/factories/increment-cycle-counter-factory.ts","../node_modules/standardized-audio-context/src/factories/decrement-cycle-counter.ts","../node_modules/standardized-audio-context/src/factories/detect-cycles.ts","../node_modules/standardized-audio-context/src/guards/delay-node.ts","../node_modules/standardized-audio-context/src/factories/native-audio-buffer-constructor.ts","../node_modules/standardized-audio-context/src/factories/wrap-audio-buffer-copy-channel-methods.ts","../node_modules/standardized-audio-context/src/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.ts","../node_modules/standardized-audio-context/src/factories/test-audio-buffer-constructor-support.ts","../node_modules/standardized-audio-context/src/factories/add-silent-connection.ts","../node_modules/standardized-audio-context/src/factories/render-inputs-of-audio-param.ts","../node_modules/standardized-audio-context/src/factories/connect-audio-param.ts","../node_modules/standardized-audio-context/src/factories/native-audio-buffer-source-node-factory.ts","../node_modules/standardized-audio-context/src/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-buffer-source-node-start-method-offset-clamping-support.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support.ts","../node_modules/standardized-audio-context/src/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.ts","../node_modules/standardized-audio-context/src/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.ts","../node_modules/standardized-audio-context/src/factories/render-automation.ts","../node_modules/standardized-audio-context/src/factories/get-audio-param-renderer.ts","../node_modules/standardized-audio-context/src/factories/audio-buffer-source-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/audio-param-factory.ts","../node_modules/standardized-audio-context/src/factories/audio-param-renderer.ts","../node_modules/standardized-audio-context/src/helpers/set-value-at-time-until-possible.ts","../node_modules/standardized-audio-context/src/factories/audio-destination-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/audio-destination-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/native-audio-destination-node.ts","../node_modules/standardized-audio-context/src/factories/biquad-filter-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/set-audio-node-tail-time.ts","../node_modules/standardized-audio-context/src/factories/monitor-connections.ts","../node_modules/standardized-audio-context/src/factories/wrap-channel-merger-node.ts","../node_modules/standardized-audio-context/src/factories/native-channel-merger-node-factory.ts","../node_modules/standardized-audio-context/src/factories/channel-merger-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/channel-splitter-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/helpers/sanitize-channel-splitter-options.ts","../node_modules/standardized-audio-context/src/factories/native-constant-source-node-faker-factory.ts","../node_modules/standardized-audio-context/src/factories/native-constant-source-node-factory.ts","../node_modules/standardized-audio-context/src/factories/constant-source-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/native-convolver-node-factory.ts","../node_modules/standardized-audio-context/src/factories/convolver-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/delay-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/native-dynamics-compressor-node-factory.ts","../node_modules/standardized-audio-context/src/factories/dynamics-compressor-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/gain-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/render-native-offline-audio-context.ts","../node_modules/standardized-audio-context/src/factories/test-offline-audio-context-current-time-support.ts","../node_modules/standardized-audio-context/src/factories/native-iir-filter-node-factory.ts","../node_modules/standardized-audio-context/src/helpers/wrap-iir-filter-node-get-frequency-response-method.ts","../node_modules/standardized-audio-context/src/factories/audio-listener-factory.ts","../node_modules/standardized-audio-context/src/factories/minimal-base-audio-context-constructor.ts","../node_modules/standardized-audio-context/src/factories/native-oscillator-node-factory.ts","../node_modules/standardized-audio-context/src/factories/oscillator-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/connected-native-audio-buffer-source-node-factory.ts","../node_modules/standardized-audio-context/src/factories/native-wave-shaper-node-faker-factory.ts","../node_modules/standardized-audio-context/src/factories/native-wave-shaper-node-factory.ts","../node_modules/standardized-audio-context/src/factories/native-panner-node-faker-factory.ts","../node_modules/standardized-audio-context/src/factories/native-panner-node-factory.ts","../node_modules/standardized-audio-context/src/factories/panner-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/native-periodic-wave-factory.ts","../node_modules/standardized-audio-context/src/helpers/sanitize-periodic-wave-options.ts","../node_modules/standardized-audio-context/src/factories/native-stereo-panner-node-faker-factory.ts","../node_modules/standardized-audio-context/src/factories/native-stereo-panner-node-factory.ts","../node_modules/standardized-audio-context/src/factories/stereo-panner-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/wave-shaper-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/is-secure-context.ts","../node_modules/standardized-audio-context/src/factories/expose-current-frame-and-current-time.ts","../node_modules/standardized-audio-context/src/factories/get-or-create-backup-offline-audio-context.ts","../node_modules/standardized-audio-context/src/factories/evaluate-source.ts","../node_modules/standardized-audio-context/src/factories/fetch-source.ts","../node_modules/standardized-audio-context/src/factories/abort-error.ts","../node_modules/standardized-audio-context/src/factories/test-audio-worklet-processor-post-message-support.ts","../node_modules/standardized-audio-context/src/factories/is-native-context.ts","../node_modules/standardized-audio-context/src/factories/decode-audio-data.ts","../node_modules/standardized-audio-context/src/factories/data-clone-error.ts","../node_modules/standardized-audio-context/src/factories/encoding-error.ts","../node_modules/standardized-audio-context/src/factories/base-audio-context-constructor.ts","../node_modules/standardized-audio-context/src/factories/media-element-audio-source-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/native-media-element-audio-source-node.ts","../node_modules/standardized-audio-context/src/factories/native-media-stream-audio-destination-node.ts","../node_modules/standardized-audio-context/src/factories/media-stream-audio-source-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/native-media-stream-audio-source-node.ts","../node_modules/standardized-audio-context/src/factories/native-media-stream-track-audio-source-node-factory.ts","../node_modules/standardized-audio-context/src/factories/media-stream-track-audio-source-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/audio-context-constructor.ts","../node_modules/standardized-audio-context/src/factories/get-unrendered-audio-worklet-nodes.ts","../node_modules/standardized-audio-context/src/factories/add-unrendered-audio-worklet-node.ts","../node_modules/standardized-audio-context/src/factories/connect-multiple-outputs.ts","../node_modules/standardized-audio-context/src/factories/delete-unrendered-audio-worklet-node.ts","../node_modules/standardized-audio-context/src/factories/get-active-audio-worklet-node-inputs.ts","../node_modules/standardized-audio-context/src/factories/native-audio-worklet-node-faker-factory.ts","../node_modules/standardized-audio-context/src/helpers/create-audio-worklet-processor.ts","../node_modules/standardized-audio-context/src/factories/native-audio-worklet-node-factory.ts","../node_modules/standardized-audio-context/src/helpers/test-clonability-of-audio-worklet-node-options.ts","../node_modules/standardized-audio-context/src/factories/get-backup-offline-audio-context.ts","../node_modules/standardized-audio-context/src/factories/set-active-audio-worklet-node-inputs.ts","../node_modules/standardized-audio-context/src/helpers/sanitize-audio-worklet-node-options.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-worklet-node-options-clonability.ts","../node_modules/standardized-audio-context/src/factories/minimal-audio-context-constructor.ts","../node_modules/standardized-audio-context/src/factories/create-native-offline-audio-context.ts","../node_modules/standardized-audio-context/src/factories/start-rendering.ts","../node_modules/extendable-media-recorder/src/factories/web-audio-media-recorder.ts","../node_modules/standardized-audio-context/src/factories/is-any-audio-context.ts","../node_modules/standardized-audio-context/src/factories/is-any-audio-node.ts","../node_modules/standardized-audio-context/src/factories/is-any-audio-param.ts","../node_modules/standardized-audio-context/src/factories/is-any-offline-audio-context.ts","../node_modules/extendable-media-recorder/src/module.ts","../node_modules/extendable-media-recorder/src/factories/window.ts","../node_modules/extendable-media-recorder/src/factories/blob-event-factory.ts","../node_modules/extendable-media-recorder/src/factories/native-blob-event-constructor.ts","../node_modules/extendable-media-recorder/src/factories/invalid-state-error.ts","../node_modules/extendable-media-recorder/src/factories/read-variable-size-integer.ts","../node_modules/extendable-media-recorder/src/functions/read-variable-size-integer-length.ts","../node_modules/extendable-media-recorder/src/factories/read-element-content.ts","../node_modules/extendable-media-recorder/src/factories/read-element-type.ts","../node_modules/extendable-media-recorder/src/factories/decode-web-m-chunk.ts","../node_modules/extendable-media-recorder/src/factories/webm-pcm-media-recorder.ts","../node_modules/extendable-media-recorder/src/factories/event-target-factory.ts","../node_modules/extendable-media-recorder/src/factories/native-media-recorder-constructor.ts","../node_modules/extendable-media-recorder/src/factories/native-media-recorder.ts","../node_modules/extendable-media-recorder/src/factories/media-recorder-constructor.ts","../node_modules/extendable-media-recorder/src/factories/event-target-constructor.ts","../node_modules/extendable-media-recorder/src/functions/wrap-event-listener.ts","../node_modules/extendable-media-recorder/src/factories/is-supported-promise.ts","../node_modules/fast-unique-numbers/build/es5/bundle.js","../node_modules/indefinite-article/indefinite-article.js","../node_modules/multi-buffer-data-view/build/es5/bundle.js","../node_modules/prop-types/factoryWithThrowingShims.js","../node_modules/prop-types/index.js","../node_modules/prop-types/lib/ReactPropTypesSecret.js","../node_modules/react-bootstrap/esm/BreadcrumbItem.js","../node_modules/react-bootstrap/esm/Breadcrumb.js","../node_modules/react-bootstrap/esm/CardImg.js","../node_modules/react-bootstrap/esm/CardHeader.js","../node_modules/react-bootstrap/esm/Card.js","../node_modules/react-bootstrap/esm/CardHeaderContext.js","../node_modules/react-bootstrap/esm/Col.js","../node_modules/react-bootstrap/esm/ElementChildren.js","../node_modules/react-bootstrap/esm/Feedback.js","../node_modules/react-bootstrap/esm/FormCheckLabel.js","../node_modules/react-bootstrap/esm/FormCheck.js","../node_modules/react-bootstrap/esm/FormControl.js","../node_modules/react-bootstrap/esm/FormFloating.js","../node_modules/react-bootstrap/esm/FormGroup.js","../node_modules/react-bootstrap/esm/FormLabel.js","../node_modules/react-bootstrap/esm/FormRange.js","../node_modules/react-bootstrap/esm/FormSelect.js","../node_modules/react-bootstrap/esm/FormText.js","../node_modules/react-bootstrap/esm/Switch.js","../node_modules/react-bootstrap/esm/FloatingLabel.js","../node_modules/react-bootstrap/esm/Form.js","../node_modules/react-bootstrap/esm/FormCheckInput.js","../node_modules/react-bootstrap/esm/FormContext.js","../node_modules/react-bootstrap/esm/InputGroup.js","../node_modules/react-bootstrap/esm/Row.js","../node_modules/react-bootstrap/esm/divWithClassName.js","../node_modules/react-media-recorder/index.js","../node_modules/react-media-recorder/lib/index.js","../Webcam/webpack/universalModuleDefinition","../Webcam/webpack/bootstrap","../Webcam/src/react-webcam.tsx","../Webcam/external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}","../node_modules/@babel/runtime/helpers/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/classCallCheck.js","../node_modules/@babel/runtime/helpers/createClass.js","../node_modules/@babel/runtime/helpers/iterableToArray.js","../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/nonIterableRest.js","../node_modules/@babel/runtime/helpers/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/slicedToArray.js","../node_modules/@babel/runtime/helpers/toConsumableArray.js","../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.automationEvents = {}, global._slicedToArray, global._classCallCheck, global._createClass));\n})(this, (function (exports, _slicedToArray, _classCallCheck, _createClass) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);\n    var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);\n    var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);\n\n    var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetValueAutomationEvent = function createSetValueAutomationEvent(value, startTime) {\n      return {\n        startTime: startTime,\n        type: 'setValue',\n        value: value\n      };\n    };\n\n    var createSetValueCurveAutomationEvent = function createSetValueCurveAutomationEvent(values, startTime, duration) {\n      return {\n        duration: duration,\n        startTime: startTime,\n        type: 'setValueCurve',\n        values: values\n      };\n    };\n\n    var getTargetValueAtTime = function getTargetValueAtTime(time, valueAtStartTime, _ref) {\n      var startTime = _ref.startTime,\n          target = _ref.target,\n          timeConstant = _ref.timeConstant;\n      return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n    };\n\n    var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'exponentialRampToValue';\n    };\n\n    var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'linearRampToValue';\n    };\n\n    var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent(automationEvent) {\n      return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n    };\n\n    var isSetValueAutomationEvent = function isSetValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValue';\n    };\n\n    var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValueCurve';\n    };\n\n    var getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime(automationEvents, index, time, defaultValue) {\n      var automationEvent = automationEvents[index];\n      return automationEvent === undefined ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);\n    };\n\n    var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) {\n      return currentAutomationEvent === undefined ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime + currentAutomationEvent.duration, currentAutomationEvent.values[currentAutomationEvent.values.length - 1]] : [currentAutomationEvent.startTime, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)];\n    };\n\n    var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelAndHold';\n    };\n\n    var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelScheduledValues';\n    };\n\n    var getEventTime = function getEventTime(automationEvent) {\n      if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n        return automationEvent.cancelTime;\n      }\n\n      if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n        return automationEvent.endTime;\n      }\n\n      return automationEvent.startTime;\n    };\n\n    var getExponentialRampValueAtTime = function getExponentialRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n          value = _ref.value;\n\n      if (valueAtStartTime === value) {\n        return value;\n      }\n\n      if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {\n        return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));\n      }\n\n      return 0;\n    };\n\n    var getLinearRampValueAtTime = function getLinearRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n          value = _ref.value;\n      return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);\n    };\n\n    var interpolateValue = function interpolateValue(values, theoreticIndex) {\n      var lowerIndex = Math.floor(theoreticIndex);\n      var upperIndex = Math.ceil(theoreticIndex);\n\n      if (lowerIndex === upperIndex) {\n        return values[lowerIndex];\n      }\n\n      return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n    };\n\n    var getValueCurveValueAtTime = function getValueCurveValueAtTime(time, _ref) {\n      var duration = _ref.duration,\n          startTime = _ref.startTime,\n          values = _ref.values;\n      var theoreticIndex = (time - startTime) / duration * (values.length - 1);\n      return interpolateValue(values, theoreticIndex);\n    };\n\n    var isSetTargetAutomationEvent = function isSetTargetAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setTarget';\n    };\n\n    var AutomationEventList = /*#__PURE__*/function (_Symbol$iterator) {\n      function AutomationEventList(defaultValue) {\n        _classCallCheck__default[\"default\"](this, AutomationEventList);\n\n        this._automationEvents = [];\n        this._currenTime = 0;\n        this._defaultValue = defaultValue;\n      }\n\n      _createClass__default[\"default\"](AutomationEventList, [{\n        key: _Symbol$iterator,\n        value: function value() {\n          return this._automationEvents[Symbol.iterator]();\n        }\n      }, {\n        key: \"add\",\n        value: function add(automationEvent) {\n          var eventTime = getEventTime(automationEvent);\n\n          if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n            var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {\n                return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;\n              }\n\n              return getEventTime(currentAutomationEvent) >= eventTime;\n            });\n\n            var removedAutomationEvent = this._automationEvents[index];\n\n            if (index !== -1) {\n              this._automationEvents = this._automationEvents.slice(0, index);\n            }\n\n            if (isCancelAndHoldAutomationEvent(automationEvent)) {\n              var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n              if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n                if (isSetTargetAutomationEvent(lastAutomationEvent)) {\n                  throw new Error('The internal list is malformed.');\n                }\n\n                var startTime = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);\n                var startValue = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;\n                var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n                var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n\n                this._automationEvents.push(truncatedAutomationEvent);\n              }\n\n              if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n              }\n\n              if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n                this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(new Float32Array([6, 7]), lastAutomationEvent.startTime, eventTime - lastAutomationEvent.startTime);\n              }\n            }\n          } else {\n            var _index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              return getEventTime(currentAutomationEvent) > eventTime;\n            });\n\n            var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];\n\n            if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n              return false;\n            }\n\n            var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;\n\n            if (_index === -1) {\n              this._automationEvents.push(persistentAutomationEvent);\n            } else {\n              if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {\n                return false;\n              }\n\n              this._automationEvents.splice(_index, 0, persistentAutomationEvent);\n            }\n          }\n\n          return true;\n        }\n      }, {\n        key: \"flush\",\n        value: function flush(time) {\n          var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n            return getEventTime(currentAutomationEvent) > time;\n          });\n\n          if (index > 1) {\n            var remainingAutomationEvents = this._automationEvents.slice(index - 1);\n\n            var firstRemainingAutomationEvent = remainingAutomationEvents[0];\n\n            if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n              remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n            }\n\n            this._automationEvents = remainingAutomationEvents;\n          }\n        }\n      }, {\n        key: \"getValue\",\n        value: function getValue(time) {\n          if (this._automationEvents.length === 0) {\n            return this._defaultValue;\n          }\n\n          var indexOfNextEvent = this._automationEvents.findIndex(function (automationEvent) {\n            return getEventTime(automationEvent) > time;\n          });\n\n          var nextAutomationEvent = this._automationEvents[indexOfNextEvent];\n          var indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;\n          var currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];\n\n          if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {\n            return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n          }\n\n          if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n\n          if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n            if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n              return getValueCurveValueAtTime(time, currentAutomationEvent);\n            }\n\n            return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n          }\n\n          if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n\n          if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n                _getEndTimeAndValueOf2 = _slicedToArray__default[\"default\"](_getEndTimeAndValueOf, 2),\n                startTime = _getEndTimeAndValueOf2[0],\n                value = _getEndTimeAndValueOf2[1];\n\n            return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n          }\n\n          if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n                _getEndTimeAndValueOf4 = _slicedToArray__default[\"default\"](_getEndTimeAndValueOf3, 2),\n                _startTime = _getEndTimeAndValueOf4[0],\n                _value = _getEndTimeAndValueOf4[1];\n\n            return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);\n          }\n\n          return this._defaultValue;\n        }\n      }]);\n\n      return AutomationEventList;\n    }(Symbol.iterator);\n\n    var createCancelAndHoldAutomationEvent = function createCancelAndHoldAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelAndHold'\n      };\n    };\n\n    var createCancelScheduledValuesAutomationEvent = function createCancelScheduledValuesAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelScheduledValues'\n      };\n    };\n\n    var createExponentialRampToValueAutomationEvent = function createExponentialRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createLinearRampToValueAutomationEvent = function createLinearRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetTargetAutomationEvent = function createSetTargetAutomationEvent(target, startTime, timeConstant) {\n      return {\n        startTime: startTime,\n        target: target,\n        timeConstant: timeConstant,\n        type: 'setTarget'\n      };\n    };\n\n    exports.AutomationEventList = AutomationEventList;\n    exports.createCancelAndHoldAutomationEvent = createCancelAndHoldAutomationEvent;\n    exports.createCancelScheduledValuesAutomationEvent = createCancelScheduledValuesAutomationEvent;\n    exports.createExponentialRampToValueAutomationEvent = createExponentialRampToValueAutomationEvent;\n    exports.createLinearRampToValueAutomationEvent = createLinearRampToValueAutomationEvent;\n    exports.createSetTargetAutomationEvent = createSetTargetAutomationEvent;\n    exports.createSetValueAutomationEvent = createSetValueAutomationEvent;\n    exports.createSetValueCurveAutomationEvent = createSetValueCurveAutomationEvent;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n","export const PORT_MAP: WeakMap<MessagePort, number> = new WeakMap();\n","import { generateUniqueNumber } from 'fast-unique-numbers';\nimport { IWorkerDefinition, IWorkerErrorMessage, IWorkerResultMessage } from 'worker-factory';\nimport { isMessagePort } from './guards/message-port';\nimport { extendBrokerImplementation } from './helpers/extend-broker-implementation';\nimport { IBrokerDefinition, IDefaultBrokerDefinition, IWorkerEvent } from './interfaces';\nimport { TBrokerImplementation } from './types';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nconst ONGOING_REQUESTS = new WeakMap<MessagePort | Worker, Map<number, { reject: Function; resolve: Function }>>();\n\nconst createOrGetOngoingRequests = (sender: MessagePort | Worker): Map<number, { reject: Function; resolve: Function }> => {\n    if (ONGOING_REQUESTS.has(sender)) {\n        // @todo TypeScript needs to be convinced that has() works as expected.\n        return <Map<number, { reject: Function; resolve: Function }>>ONGOING_REQUESTS.get(sender);\n    }\n\n    const ongoingRequests: Map<number, { reject: Function; resolve: Function }> = new Map();\n\n    ONGOING_REQUESTS.set(sender, ongoingRequests);\n\n    return ongoingRequests;\n};\n\nexport const createBroker = <T extends IBrokerDefinition, U extends IWorkerDefinition>(\n    brokerImplementation: TBrokerImplementation<T, U>\n): ((sender: MessagePort | Worker) => T & IDefaultBrokerDefinition) => {\n    const fullBrokerImplementation = extendBrokerImplementation(brokerImplementation);\n\n    return (sender: MessagePort | Worker) => {\n        const ongoingRequests = createOrGetOngoingRequests(sender);\n\n        sender.addEventListener('message', <EventListener>(({ data: message }: IWorkerEvent) => {\n            const { id } = message;\n\n            if (id !== null && ongoingRequests.has(id)) {\n                const { reject, resolve } = <{ reject: Function; resolve: Function }>ongoingRequests.get(id);\n\n                ongoingRequests.delete(id);\n\n                if ((<IWorkerErrorMessage>message).error === undefined) {\n                    resolve((<IWorkerResultMessage>message).result);\n                } else {\n                    reject(new Error((<IWorkerErrorMessage>message).error.message));\n                }\n            }\n        }));\n\n        if (isMessagePort(sender)) {\n            sender.start();\n        }\n\n        const call = <V extends keyof U>(method: V, params: U[V]['params'] = null, transferables: U[V]['transferables'] = []) => {\n            return new Promise<U[V]['response']['result']>((resolve, reject) => {\n                const id = generateUniqueNumber(ongoingRequests);\n\n                ongoingRequests.set(id, { reject, resolve });\n\n                if (params === null) {\n                    sender.postMessage({ id, method }, <Transferable[]>transferables);\n                } else {\n                    sender.postMessage({ id, method, params }, <Transferable[]>transferables);\n                }\n            });\n        };\n        const notify = <V extends keyof U>(method: V, params: U[V]['params'], transferables: U[V]['transferables'] = []) => {\n            sender.postMessage({ id: null, method, params }, <Transferable[]>transferables);\n        };\n\n        let functions: object = {};\n\n        for (const [key, handler] of Object.entries(fullBrokerImplementation)) {\n            functions = { ...functions, [key]: handler({ call, notify }) };\n        }\n\n        return <T & IDefaultBrokerDefinition>{ ...functions };\n    };\n};\n","import { IWorkerDefinition } from 'worker-factory';\nimport { IBrokerDefinition, IDefaultBrokerDefinition } from '../interfaces';\nimport { TBrokerImplementation } from '../types';\nimport { PORT_MAP } from './port-map';\n\nexport const extendBrokerImplementation = <T extends IBrokerDefinition, U extends IWorkerDefinition>(\n    partialBrokerImplementation: TBrokerImplementation<T, U>\n): TBrokerImplementation<T & IDefaultBrokerDefinition, U> =>\n    <TBrokerImplementation<T & IDefaultBrokerDefinition, U>>{\n        ...partialBrokerImplementation,\n        connect: ({ call }) => {\n            return async (): Promise<MessagePort> => {\n                const { port1, port2 } = new MessageChannel();\n\n                const portId = <number>await call('connect', { port: port1 }, [port1]);\n\n                PORT_MAP.set(port2, portId);\n\n                return port2;\n            };\n        },\n        disconnect: ({ call }) => {\n            return async (port: MessagePort): Promise<void> => {\n                const portId = PORT_MAP.get(port);\n\n                if (portId === undefined) {\n                    throw new Error('The given port is not connected.');\n                }\n\n                await call('disconnect', { portId });\n            };\n        },\n        isSupported: ({ call }) => {\n            return () => call('isSupported');\n        }\n    };\n","export const isMessagePort = (sender: MessagePort | Worker): sender is MessagePort => {\n    return typeof (<MessagePort>sender).start === 'function';\n};\n","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/toConsumableArray'), require('dashify'), require('indefinite-article')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/toConsumableArray', 'dashify', 'indefinite-article'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.compilerr = {}, global._toConsumableArray, global.dashify, global.indefiniteArticle));\n})(this, (function (exports, _toConsumableArray, dashify, indefiniteArticle) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);\n    var dashify__default = /*#__PURE__*/_interopDefaultLegacy(dashify);\n    var indefiniteArticle__default = /*#__PURE__*/_interopDefaultLegacy(indefiniteArticle);\n\n    var applyModifiers = function applyModifiers(name, modifiers) {\n      if (modifiers === undefined) {\n        return name;\n      }\n\n      return modifiers.reduce(function (modifiedName, modifier) {\n        if (modifier === 'capitalize') {\n          var head = modifiedName.charAt(0).toUpperCase();\n          var tail = modifiedName.slice(1);\n          return \"\".concat(head).concat(tail);\n        }\n\n        if (modifier === 'dashify') {\n          return dashify__default[\"default\"](modifiedName);\n        }\n\n        if (modifier === 'prependIndefiniteArticle') {\n          return \"\".concat(indefiniteArticle__default[\"default\"](modifiedName), \" \").concat(modifiedName);\n        }\n\n        return modifiedName;\n      }, name);\n    };\n\n    var buildRegex = function buildRegex(variable) {\n      var expression = variable.name + variable.modifiers.map(function (modifier) {\n        return \"\\\\.\".concat(modifier, \"\\\\(\\\\)\");\n      }).join('');\n      return new RegExp(\"\\\\$\\\\{\".concat(expression, \"}\"), 'g');\n    };\n\n    var preRenderString = function preRenderString(string, parameters) {\n      var expressionRegex = /\\${([^.}]+)((\\.[^(]+\\(\\))*)}/g;\n      var variables = [];\n      var expressionResult = expressionRegex.exec(string);\n\n      while (expressionResult !== null) {\n        var variable = {\n          modifiers: [],\n          name: expressionResult[1]\n        };\n\n        if (expressionResult[3] !== undefined) {\n          var modifiersRegex = /\\.[^(]+\\(\\)/g;\n          var modifiersRegexResult = modifiersRegex.exec(expressionResult[2]);\n\n          while (modifiersRegexResult !== null) {\n            variable.modifiers.push(modifiersRegexResult[0].slice(1, -2));\n            modifiersRegexResult = modifiersRegex.exec(expressionResult[2]);\n          }\n        }\n\n        variables.push(variable);\n        expressionResult = expressionRegex.exec(string);\n      }\n\n      var preRenderedParts = variables.reduce(function (parts, variable) {\n        return parts.map(function (part) {\n          if (typeof part === 'string') {\n            return part.split(buildRegex(variable)).reduce(function (prts, prt, index) {\n              if (index === 0) {\n                return [prt];\n              }\n\n              if (variable.name in parameters) {\n                return [].concat(_toConsumableArray__default[\"default\"](prts), [applyModifiers(parameters[variable.name], variable.modifiers), prt]);\n              }\n\n              return [].concat(_toConsumableArray__default[\"default\"](prts), [function (prmtrs) {\n                return applyModifiers(prmtrs[variable.name], variable.modifiers);\n              }, prt]);\n            }, []);\n          }\n\n          return [part];\n        }).reduce(function (prts, part) {\n          return [].concat(_toConsumableArray__default[\"default\"](prts), _toConsumableArray__default[\"default\"](part));\n        }, []);\n      }, [string]);\n      return function (missingParameters) {\n        return preRenderedParts.reduce(function (renderedParts, preRenderedPart) {\n          if (typeof preRenderedPart === 'string') {\n            return [].concat(_toConsumableArray__default[\"default\"](renderedParts), [preRenderedPart]);\n          }\n\n          return [].concat(_toConsumableArray__default[\"default\"](renderedParts), [preRenderedPart(missingParameters)]);\n        }, []).join('');\n      };\n    };\n\n    var compile = function compile(template) {\n      var knownParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var renderCode = template.code === undefined ? undefined : preRenderString(template.code, knownParameters);\n      var renderMessage = template.message === undefined ? undefined : preRenderString(template.message, knownParameters);\n\n      function render() {\n        var causeOrMissingParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var optionalCause = arguments.length > 1 ? arguments[1] : undefined;\n        var hasNoOptionalCause = optionalCause === undefined && (causeOrMissingParameters instanceof Error || causeOrMissingParameters.code !== undefined && causeOrMissingParameters.code.slice(-9) === 'Exception');\n\n        var _ref = hasNoOptionalCause ? {\n          cause: causeOrMissingParameters,\n          missingParameters: {}\n        } : {\n          cause: optionalCause,\n          missingParameters: causeOrMissingParameters\n        },\n            cause = _ref.cause,\n            missingParameters = _ref.missingParameters;\n\n        var err = renderMessage === undefined ? new Error() : new Error(renderMessage(missingParameters));\n\n        if (cause !== null) {\n          err.cause = cause;\n        }\n\n        if (renderCode !== undefined) {\n          err.code = renderCode(missingParameters);\n        }\n\n        if (template.status !== undefined) {\n          err.status = template.status;\n        }\n\n        return err;\n      }\n\n      return render;\n    };\n\n    exports.compile = compile;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n","/*!\n * dashify <https://github.com/jonschlinkert/dashify>\n *\n * Copyright (c) 2015-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = (str, options) => {\n  if (typeof str !== 'string') throw new TypeError('expected a string');\n  return str.trim()\n    .replace(/([a-z])([A-Z])/g, '$1-$2')\n    .replace(/\\W/g, m => /[-]/.test(m) ? m : '-')\n    .replace(/^-+|-+$/g, '')\n    .replace(/-{2,}/g, m => options && options.condense ? '-' : m)\n    .toLowerCase();\n};\n","import { createBroker } from 'broker-factory';\nimport { TExtendableMediaRecorderWavEncoderWorkerDefinition } from 'extendable-media-recorder-wav-encoder-worker';\nimport { IExtendableMediaRecorderWavEncoderBrokerDefinition } from './interfaces';\nimport { TExtendableMediaRecorderWavEncoderBrokerLoader, TExtendableMediaRecorderWavEncoderBrokerWrapper } from './types';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nexport const wrap: TExtendableMediaRecorderWavEncoderBrokerWrapper = createBroker<\n    IExtendableMediaRecorderWavEncoderBrokerDefinition,\n    TExtendableMediaRecorderWavEncoderWorkerDefinition\n>({\n    characterize: ({ call }) => {\n        return () => call('characterize');\n    },\n    encode: ({ call }) => {\n        return (recordingId, timeslice) => {\n            return call('encode', { recordingId, timeslice });\n        };\n    },\n    record: ({ call }) => {\n        return async (recordingId, sampleRate, typedArrays) => {\n            await call(\n                'record',\n                { recordingId, sampleRate, typedArrays },\n                typedArrays.map(({ buffer }) => buffer)\n            );\n        };\n    }\n});\n\nexport const load: TExtendableMediaRecorderWavEncoderBrokerLoader = (url: string) => {\n    const worker = new Worker(url);\n\n    return wrap(worker);\n};\n","import { load } from 'extendable-media-recorder-wav-encoder-broker';\nimport { worker } from './worker/worker';\n\nconst blob: Blob = new Blob([worker], { type: 'application/javascript; charset=utf-8' });\n\nconst url: string = URL.createObjectURL(blob);\n\nconst extendableMediaRecorderWavEncoder = load(url);\n\nexport const characterize = extendableMediaRecorderWavEncoder.characterize;\n\nexport const connect = extendableMediaRecorderWavEncoder.connect;\n\nexport const disconnect = extendableMediaRecorderWavEncoder.disconnect;\n\nexport const encode = extendableMediaRecorderWavEncoder.encode;\n\nexport const isSupported = extendableMediaRecorderWavEncoder.isSupported;\n\nexport const record = extendableMediaRecorderWavEncoder.record;\n\nURL.revokeObjectURL(url);\n","// This is the minified and stringified code of the extendable-media-recorder-wav-encoder-worker package.\nexport const worker = `(()=>{var e={775:function(e,t,r){!function(e,t,r,n){\"use strict\";function o(e){return e&&\"object\"==typeof e&&\"default\"in e?e:{default:e}}var s=o(t),a=o(r),i=o(n),u=function(e,t){return void 0===t?e:t.reduce((function(e,t){if(\"capitalize\"===t){var r=e.charAt(0).toUpperCase(),n=e.slice(1);return\"\".concat(r).concat(n)}return\"dashify\"===t?a.default(e):\"prependIndefiniteArticle\"===t?\"\".concat(i.default(e),\" \").concat(e):e}),e)},c=function(e){var t=e.name+e.modifiers.map((function(e){return\"\\\\\\\\.\".concat(e,\"\\\\\\\\(\\\\\\\\)\")})).join(\"\");return new RegExp(\"\\\\\\\\$\\\\\\\\{\".concat(t,\"}\"),\"g\")},l=function(e,t){for(var r=/\\\\\\${([^.}]+)((\\\\.[^(]+\\\\(\\\\))*)}/g,n=[],o=r.exec(e);null!==o;){var a={modifiers:[],name:o[1]};if(void 0!==o[3])for(var i=/\\\\.[^(]+\\\\(\\\\)/g,l=i.exec(o[2]);null!==l;)a.modifiers.push(l[0].slice(1,-2)),l=i.exec(o[2]);n.push(a),o=r.exec(e)}var d=n.reduce((function(e,r){return e.map((function(e){return\"string\"==typeof e?e.split(c(r)).reduce((function(e,n,o){return 0===o?[n]:r.name in t?[].concat(s.default(e),[u(t[r.name],r.modifiers),n]):[].concat(s.default(e),[function(e){return u(e[r.name],r.modifiers)},n])}),[]):[e]})).reduce((function(e,t){return[].concat(s.default(e),s.default(t))}),[])}),[e]);return function(e){return d.reduce((function(t,r){return[].concat(s.default(t),\"string\"==typeof r?[r]:[r(e)])}),[]).join(\"\")}},d=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=void 0===e.code?void 0:l(e.code,t),n=void 0===e.message?void 0:l(e.message,t);function o(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},o=arguments.length>1?arguments[1]:void 0,s=void 0===o&&(t instanceof Error||void 0!==t.code&&\"Exception\"===t.code.slice(-9))?{cause:t,missingParameters:{}}:{cause:o,missingParameters:t},a=s.cause,i=s.missingParameters,u=void 0===n?new Error:new Error(n(i));return null!==a&&(u.cause=a),void 0!==r&&(u.code=r(i)),void 0!==e.status&&(u.status=e.status),u}return o};e.compile=d,Object.defineProperty(e,\"__esModule\",{value:!0})}(t,r(106),r(881),r(507))},881:e=>{\"use strict\";e.exports=(e,t)=>{if(\"string\"!=typeof e)throw new TypeError(\"expected a string\");return e.trim().replace(/([a-z])([A-Z])/g,\"$1-$2\").replace(/\\\\W/g,(e=>/[-]/.test(e)?e:\"-\")).replace(/^-+|-+$/g,\"\").replace(/-{2,}/g,(e=>t&&t.condense?\"-\":e)).toLowerCase()}},107:function(e,t){!function(e){\"use strict\";var t=function(e){return function(t){var r=e(t);return t.add(r),r}},r=function(e){return function(t,r){return e.set(t,r),r}},n=void 0===Number.MAX_SAFE_INTEGER?9007199254740991:Number.MAX_SAFE_INTEGER,o=536870912,s=2*o,a=function(e,t){return function(r){var a=t.get(r),i=void 0===a?r.size:a<s?a+1:0;if(!r.has(i))return e(r,i);if(r.size<o){for(;r.has(i);)i=Math.floor(Math.random()*s);return e(r,i)}if(r.size>n)throw new Error(\"Congratulations, you created a collection of unique numbers which uses all available integers!\");for(;r.has(i);)i=Math.floor(Math.random()*n);return e(r,i)}},i=new WeakMap,u=r(i),c=a(u,i),l=t(c);e.addUniqueNumber=l,e.generateUniqueNumber=c,Object.defineProperty(e,\"__esModule\",{value:!0})}(t)},507:e=>{var t=function(e){var t,r,n=/\\\\w+/.exec(e);if(!n)return\"an\";var o=(r=n[0]).toLowerCase(),s=[\"honest\",\"hour\",\"hono\"];for(t in s)if(0==o.indexOf(s[t]))return\"an\";if(1==o.length)return\"aedhilmnorsx\".indexOf(o)>=0?\"an\":\"a\";if(r.match(/(?!FJO|[HLMNS]Y.|RY[EO]|SQU|(F[LR]?|[HL]|MN?|N|RH?|S[CHKLMNPTVW]?|X(YL)?)[AEIOU])[FHLMNRSX][A-Z]/))return\"an\";var a=[/^e[uw]/,/^onc?e\\\\b/,/^uni([^nmd]|mo)/,/^u[bcfhjkqrst][aeiou]/];for(t=0;t<a.length;t++)if(o.match(a[t]))return\"a\";return r.match(/^U[NK][AIEO]/)?\"a\":r==r.toUpperCase()?\"aedhilmnorsx\".indexOf(o[0])>=0?\"an\":\"a\":\"aeiou\".indexOf(o[0])>=0||o.match(/^y(b[lor]|cl[ea]|fere|gg|p[ios]|rou|tt)/)?\"an\":\"a\"};void 0!==e.exports?e.exports=t:window.indefiniteArticle=t},768:e=>{e.exports=function(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n},e.exports.__esModule=!0,e.exports.default=e.exports},907:(e,t,r)=>{var n=r(768);e.exports=function(e){if(Array.isArray(e))return n(e)},e.exports.__esModule=!0,e.exports.default=e.exports},642:e=>{e.exports=function(e){if(\"undefined\"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e[\"@@iterator\"])return Array.from(e)},e.exports.__esModule=!0,e.exports.default=e.exports},344:e=>{e.exports=function(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")},e.exports.__esModule=!0,e.exports.default=e.exports},106:(e,t,r)=>{var n=r(907),o=r(642),s=r(906),a=r(344);e.exports=function(e){return n(e)||o(e)||s(e)||a()},e.exports.__esModule=!0,e.exports.default=e.exports},906:(e,t,r)=>{var n=r(768);e.exports=function(e,t){if(e){if(\"string\"==typeof e)return n(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return\"Object\"===r&&e.constructor&&(r=e.constructor.name),\"Map\"===r||\"Set\"===r?Array.from(e):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?n(e,t):void 0}},e.exports.__esModule=!0,e.exports.default=e.exports}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var s=t[n]={exports:{}};return e[n].call(s.exports,s,s.exports,r),s.exports}(()=>{\"use strict\";var e=r(775);const t=-32603,n=-32602,o=-32601,s=(0,e.compile)({message:'The requested method called \"\\${method}\" is not supported.',status:o}),a=(0,e.compile)({message:'The handler of the method called \"\\${method}\" returned no required result.',status:t}),i=(0,e.compile)({message:'The handler of the method called \"\\${method}\" returned an unexpected result.',status:t}),u=(0,e.compile)({message:'The specified parameter called \"portId\" with the given value \"\\${portId}\" does not identify a port connected to this worker.',status:n}),c=(e,t)=>async r=>{let{data:{id:n,method:o,params:u}}=r;const c=t[o];try{if(void 0===c)throw s({method:o});const t=void 0===u?c():c(u);if(void 0===t)throw a({method:o});const r=t instanceof Promise?await t:t;if(null===n){if(void 0!==r.result)throw i({method:o})}else{if(void 0===r.result)throw i({method:o});const{result:t,transferables:s=[]}=r;e.postMessage({id:n,result:t},s)}}catch(t){const{message:r,status:o=-32603}=t;e.postMessage({error:{code:o,message:r},id:n})}};var l=r(107);const d=new Map,f=(e,t,r)=>({...t,connect:r=>{let{port:n}=r;n.start();const o=e(n,t),s=(0,l.generateUniqueNumber)(d);return d.set(s,(()=>{o(),n.close(),d.delete(s)})),{result:s}},disconnect:e=>{let{portId:t}=e;const r=d.get(t);if(void 0===r)throw u({portId:t.toString()});return r(),{result:null}},isSupported:async()=>{if(await new Promise((e=>{const t=new ArrayBuffer(0),{port1:r,port2:n}=new MessageChannel;r.onmessage=t=>{let{data:r}=t;return e(null!==r)},n.postMessage(t,[t])}))){const e=r();return{result:e instanceof Promise?await e:e}}return{result:!1}}}),p=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:()=>!0;const n=f(p,t,r),o=c(e,n);return e.addEventListener(\"message\",o),()=>e.removeEventListener(\"message\",o)},m=e=>e.reduce(((e,t)=>e+t.length),0),h=(e,t)=>{const r=[];let n=0;e:for(;n<t;){const t=e.length;for(let o=0;o<t;o+=1){const t=e[o];void 0===r[o]&&(r[o]=[]);const s=t.shift();if(void 0===s)break e;r[o].push(s),0===o&&(n+=s.length)}}if(n>t){const o=n-t;r.forEach(((t,r)=>{const n=t.pop(),s=n.length-o;t.push(n.subarray(0,s)),e[r].unshift(n.subarray(s))}))}return r},v=new Map,g=(e=>(t,r,n)=>{const o=e.get(t);if(void 0===o){const o={channelDataArrays:n.map((e=>[e])),isComplete:!0,sampleRate:r};return e.set(t,o),o}return o.channelDataArrays.forEach(((e,t)=>e.push(n[t]))),o})(v),x=((e,t)=>(r,n,o,s)=>{const a=o>>3,i=\"subsequent\"===n?0:44,u=r.length,c=e(r[0]),l=new ArrayBuffer(c*u*a+i),d=new DataView(l);return\"subsequent\"!==n&&t(d,o,u,\"complete\"===n?c:Number.POSITIVE_INFINITY,s),r.forEach(((e,t)=>{let r=i+t*a;e.forEach((e=>{const t=e.length;for(let n=0;n<t;n+=1){const t=e[n];d.setInt16(r,t<0?32768*Math.max(-1,t):32767*Math.min(1,t),!0),r+=u*a}}))})),[l]})(m,((e,t,r,n,o)=>{const s=t>>3,a=Math.min(n*r*s,4294967251);e.setUint32(0,1380533830),e.setUint32(4,a+36,!0),e.setUint32(8,1463899717),e.setUint32(12,1718449184),e.setUint32(16,16,!0),e.setUint16(20,1,!0),e.setUint16(22,r,!0),e.setUint32(24,o,!0),e.setUint32(28,o*r*s,!0),e.setUint16(32,r*s,!0),e.setUint16(34,t,!0),e.setUint32(36,1684108385),e.setUint32(40,a,!0)})),w=new Map;p(self,{characterize:()=>({result:/^audio\\\\/wav$/}),encode:e=>{let{recordingId:t,timeslice:r}=e;const n=w.get(t);void 0!==n&&(w.delete(t),n.reject(new Error(\"Another request was made to initiate an encoding.\")));const o=v.get(t);if(null!==r){if(void 0===o||m(o.channelDataArrays[0])*(1e3/o.sampleRate)<r)return new Promise(((e,n)=>{w.set(t,{reject:n,resolve:e,timeslice:r})}));const e=h(o.channelDataArrays,Math.ceil(r*(o.sampleRate/1e3))),n=x(e,o.isComplete?\"initial\":\"subsequent\",16,o.sampleRate);return o.isComplete=!1,{result:n,transferables:n}}if(void 0!==o){const e=x(o.channelDataArrays,o.isComplete?\"complete\":\"subsequent\",16,o.sampleRate);return v.delete(t),{result:e,transferables:e}}return{result:[],transferables:[]}},record:e=>{let{recordingId:t,sampleRate:r,typedArrays:n}=e;const o=g(t,r,n),s=w.get(t);if(void 0!==s&&m(o.channelDataArrays[0])*(1e3/r)>=s.timeslice){const e=h(o.channelDataArrays,Math.ceil(s.timeslice*(r/1e3))),n=x(e,o.isComplete?\"initial\":\"subsequent\",16,r);o.isComplete=!1,w.delete(t),s.resolve({result:n,transferables:n})}return{result:null}}})})()})();`; // tslint:disable-line:max-line-length\n","import { createBroker } from 'broker-factory';\nimport { addUniqueNumber } from 'fast-unique-numbers';\nimport { TMediaEncoderHostWorkerDefinition } from 'media-encoder-host-worker';\nimport { IMediaEncoderHostBrokerDefinition } from './interfaces';\nimport { TMediaEncoderHostBrokerLoader, TMediaEncoderHostBrokerWrapper } from './types';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nconst encoderIds: Set<number> = new Set();\n\nexport const wrap: TMediaEncoderHostBrokerWrapper = createBroker<IMediaEncoderHostBrokerDefinition, TMediaEncoderHostWorkerDefinition>({\n    encode: ({ call }) => {\n        return async (encoderId, timeslice) => {\n            const arrayBuffers = await call('encode', { encoderId, timeslice });\n\n            encoderIds.delete(encoderId);\n\n            return arrayBuffers;\n        };\n    },\n    instantiate: ({ call }) => {\n        return async (mimeType, sampleRate) => {\n            const encoderId = addUniqueNumber(encoderIds);\n            const port = await call('instantiate', { encoderId, mimeType, sampleRate });\n\n            return { encoderId, port };\n        };\n    },\n    register: ({ call }) => {\n        return (port) => {\n            return call('register', { port }, [port]);\n        };\n    }\n});\n\nexport const load: TMediaEncoderHostBrokerLoader = (url: string) => {\n    const worker = new Worker(url);\n\n    return wrap(worker);\n};\n","import { load as loadWorker } from 'media-encoder-host-broker';\nimport { worker } from './worker/worker';\n\nconst blob: Blob = new Blob([worker], { type: 'application/javascript; charset=utf-8' });\n\nconst url: string = URL.createObjectURL(blob);\n\nconst mediaEncoderHost = loadWorker(url);\n\nexport const connect = mediaEncoderHost.connect;\n\nexport const disconnect = mediaEncoderHost.disconnect;\n\nexport const encode = mediaEncoderHost.encode;\n\nexport const instantiate = mediaEncoderHost.instantiate;\n\nexport const isSupported = mediaEncoderHost.isSupported;\n\nexport const register = mediaEncoderHost.register;\n\nURL.revokeObjectURL(url);\n","// This is the minified and stringified code of the media-encoder-host-worker package.\nexport const worker = `(()=>{var e={775:function(e,t,r){!function(e,t,r,n){\"use strict\";function o(e){return e&&\"object\"==typeof e&&\"default\"in e?e:{default:e}}var a=o(t),s=o(r),i=o(n),c=function(e,t){return void 0===t?e:t.reduce((function(e,t){if(\"capitalize\"===t){var r=e.charAt(0).toUpperCase(),n=e.slice(1);return\"\".concat(r).concat(n)}return\"dashify\"===t?s.default(e):\"prependIndefiniteArticle\"===t?\"\".concat(i.default(e),\" \").concat(e):e}),e)},u=function(e){var t=e.name+e.modifiers.map((function(e){return\"\\\\\\\\.\".concat(e,\"\\\\\\\\(\\\\\\\\)\")})).join(\"\");return new RegExp(\"\\\\\\\\$\\\\\\\\{\".concat(t,\"}\"),\"g\")},l=function(e,t){for(var r=/\\\\\\${([^.}]+)((\\\\.[^(]+\\\\(\\\\))*)}/g,n=[],o=r.exec(e);null!==o;){var s={modifiers:[],name:o[1]};if(void 0!==o[3])for(var i=/\\\\.[^(]+\\\\(\\\\)/g,l=i.exec(o[2]);null!==l;)s.modifiers.push(l[0].slice(1,-2)),l=i.exec(o[2]);n.push(s),o=r.exec(e)}var d=n.reduce((function(e,r){return e.map((function(e){return\"string\"==typeof e?e.split(u(r)).reduce((function(e,n,o){return 0===o?[n]:r.name in t?[].concat(a.default(e),[c(t[r.name],r.modifiers),n]):[].concat(a.default(e),[function(e){return c(e[r.name],r.modifiers)},n])}),[]):[e]})).reduce((function(e,t){return[].concat(a.default(e),a.default(t))}),[])}),[e]);return function(e){return d.reduce((function(t,r){return[].concat(a.default(t),\"string\"==typeof r?[r]:[r(e)])}),[]).join(\"\")}},d=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=void 0===e.code?void 0:l(e.code,t),n=void 0===e.message?void 0:l(e.message,t);function o(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},o=arguments.length>1?arguments[1]:void 0,a=void 0===o&&(t instanceof Error||void 0!==t.code&&\"Exception\"===t.code.slice(-9))?{cause:t,missingParameters:{}}:{cause:o,missingParameters:t},s=a.cause,i=a.missingParameters,c=void 0===n?new Error:new Error(n(i));return null!==s&&(c.cause=s),void 0!==r&&(c.code=r(i)),void 0!==e.status&&(c.status=e.status),c}return o};e.compile=d,Object.defineProperty(e,\"__esModule\",{value:!0})}(t,r(106),r(881),r(507))},881:e=>{\"use strict\";e.exports=(e,t)=>{if(\"string\"!=typeof e)throw new TypeError(\"expected a string\");return e.trim().replace(/([a-z])([A-Z])/g,\"$1-$2\").replace(/\\\\W/g,(e=>/[-]/.test(e)?e:\"-\")).replace(/^-+|-+$/g,\"\").replace(/-{2,}/g,(e=>t&&t.condense?\"-\":e)).toLowerCase()}},107:function(e,t){!function(e){\"use strict\";var t=function(e){return function(t){var r=e(t);return t.add(r),r}},r=function(e){return function(t,r){return e.set(t,r),r}},n=void 0===Number.MAX_SAFE_INTEGER?9007199254740991:Number.MAX_SAFE_INTEGER,o=536870912,a=2*o,s=function(e,t){return function(r){var s=t.get(r),i=void 0===s?r.size:s<a?s+1:0;if(!r.has(i))return e(r,i);if(r.size<o){for(;r.has(i);)i=Math.floor(Math.random()*a);return e(r,i)}if(r.size>n)throw new Error(\"Congratulations, you created a collection of unique numbers which uses all available integers!\");for(;r.has(i);)i=Math.floor(Math.random()*n);return e(r,i)}},i=new WeakMap,c=r(i),u=s(c,i),l=t(u);e.addUniqueNumber=l,e.generateUniqueNumber=u,Object.defineProperty(e,\"__esModule\",{value:!0})}(t)},507:e=>{var t=function(e){var t,r,n=/\\\\w+/.exec(e);if(!n)return\"an\";var o=(r=n[0]).toLowerCase(),a=[\"honest\",\"hour\",\"hono\"];for(t in a)if(0==o.indexOf(a[t]))return\"an\";if(1==o.length)return\"aedhilmnorsx\".indexOf(o)>=0?\"an\":\"a\";if(r.match(/(?!FJO|[HLMNS]Y.|RY[EO]|SQU|(F[LR]?|[HL]|MN?|N|RH?|S[CHKLMNPTVW]?|X(YL)?)[AEIOU])[FHLMNRSX][A-Z]/))return\"an\";var s=[/^e[uw]/,/^onc?e\\\\b/,/^uni([^nmd]|mo)/,/^u[bcfhjkqrst][aeiou]/];for(t=0;t<s.length;t++)if(o.match(s[t]))return\"a\";return r.match(/^U[NK][AIEO]/)?\"a\":r==r.toUpperCase()?\"aedhilmnorsx\".indexOf(o[0])>=0?\"an\":\"a\":\"aeiou\".indexOf(o[0])>=0||o.match(/^y(b[lor]|cl[ea]|fere|gg|p[ios]|rou|tt)/)?\"an\":\"a\"};void 0!==e.exports?e.exports=t:window.indefiniteArticle=t},768:e=>{e.exports=function(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n},e.exports.__esModule=!0,e.exports.default=e.exports},907:(e,t,r)=>{var n=r(768);e.exports=function(e){if(Array.isArray(e))return n(e)},e.exports.__esModule=!0,e.exports.default=e.exports},642:e=>{e.exports=function(e){if(\"undefined\"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e[\"@@iterator\"])return Array.from(e)},e.exports.__esModule=!0,e.exports.default=e.exports},344:e=>{e.exports=function(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")},e.exports.__esModule=!0,e.exports.default=e.exports},106:(e,t,r)=>{var n=r(907),o=r(642),a=r(906),s=r(344);e.exports=function(e){return n(e)||o(e)||a(e)||s()},e.exports.__esModule=!0,e.exports.default=e.exports},906:(e,t,r)=>{var n=r(768);e.exports=function(e,t){if(e){if(\"string\"==typeof e)return n(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return\"Object\"===r&&e.constructor&&(r=e.constructor.name),\"Map\"===r||\"Set\"===r?Array.from(e):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?n(e,t):void 0}},e.exports.__esModule=!0,e.exports.default=e.exports}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var a=t[n]={exports:{}};return e[n].call(a.exports,a,a.exports,r),a.exports}(()=>{\"use strict\";var e=r(775);const t=-32603,n=-32602,o=-32601,a=(0,e.compile)({message:'The requested method called \"\\${method}\" is not supported.',status:o}),s=(0,e.compile)({message:'The handler of the method called \"\\${method}\" returned no required result.',status:t}),i=(0,e.compile)({message:'The handler of the method called \"\\${method}\" returned an unexpected result.',status:t}),c=(0,e.compile)({message:'The specified parameter called \"portId\" with the given value \"\\${portId}\" does not identify a port connected to this worker.',status:n}),u=(e,t)=>async r=>{let{data:{id:n,method:o,params:c}}=r;const u=t[o];try{if(void 0===u)throw a({method:o});const t=void 0===c?u():u(c);if(void 0===t)throw s({method:o});const r=t instanceof Promise?await t:t;if(null===n){if(void 0!==r.result)throw i({method:o})}else{if(void 0===r.result)throw i({method:o});const{result:t,transferables:a=[]}=r;e.postMessage({id:n,result:t},a)}}catch(t){const{message:r,status:o=-32603}=t;e.postMessage({error:{code:o,message:r},id:n})}};var l=r(107);const d=new Map,f=(e,t,r)=>({...t,connect:r=>{let{port:n}=r;n.start();const o=e(n,t),a=(0,l.generateUniqueNumber)(d);return d.set(a,(()=>{o(),n.close(),d.delete(a)})),{result:a}},disconnect:e=>{let{portId:t}=e;const r=d.get(t);if(void 0===r)throw c({portId:t.toString()});return r(),{result:null}},isSupported:async()=>{if(await new Promise((e=>{const t=new ArrayBuffer(0),{port1:r,port2:n}=new MessageChannel;r.onmessage=t=>{let{data:r}=t;return e(null!==r)},n.postMessage(t,[t])}))){const e=r();return{result:e instanceof Promise?await e:e}}return{result:!1}}}),p=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:()=>!0;const n=f(p,t,r),o=u(e,n);return e.addEventListener(\"message\",o),()=>e.removeEventListener(\"message\",o)},m=e=>{e.onmessage=null,e.close()},h=new WeakMap,g=new WeakMap,v=(e=>{const t=(r=e,{...r,connect:e=>{let{call:t}=e;return async()=>{const{port1:e,port2:r}=new MessageChannel,n=await t(\"connect\",{port:e},[e]);return h.set(r,n),r}},disconnect:e=>{let{call:t}=e;return async e=>{const r=h.get(e);if(void 0===r)throw new Error(\"The given port is not connected.\");await t(\"disconnect\",{portId:r})}},isSupported:e=>{let{call:t}=e;return()=>t(\"isSupported\")}});var r;return e=>{const r=(e=>{if(g.has(e))return g.get(e);const t=new Map;return g.set(e,t),t})(e);e.addEventListener(\"message\",(e=>{let{data:t}=e;const{id:n}=t;if(null!==n&&r.has(n)){const{reject:e,resolve:o}=r.get(n);r.delete(n),void 0===t.error?o(t.result):e(new Error(t.error.message))}})),(e=>\"function\"==typeof e.start)(e)&&e.start();const n=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return new Promise(((a,s)=>{const i=(0,l.generateUniqueNumber)(r);r.set(i,{reject:s,resolve:a}),null===n?e.postMessage({id:i,method:t},o):e.postMessage({id:i,method:t,params:n},o)}))},o=function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];e.postMessage({id:null,method:t,params:r},n)};let a={};for(const[e,r]of Object.entries(t))a={...a,[e]:r({call:n,notify:o})};return{...a}}})({characterize:e=>{let{call:t}=e;return()=>t(\"characterize\")},encode:e=>{let{call:t}=e;return(e,r)=>t(\"encode\",{recordingId:e,timeslice:r})},record:e=>{let{call:t}=e;return async(e,r,n)=>{await t(\"record\",{recordingId:e,sampleRate:r,typedArrays:n},n.map((e=>{let{buffer:t}=e;return t})))}}}),w=async(e,t)=>{const r=v(t),n=await r.characterize(),o=n.toString();if(e.has(o))throw new Error(\"There is already an encoder stored which handles exactly the same mime types.\");return e.set(o,[n,r]),n},x=new Map,y=(e=>t=>{const r=e.get(t);if(void 0===r)throw new Error(\"There was no instance of an encoder stored with the given id.\");return r})(x),M=((e,t)=>r=>{const n=t(r);return e.delete(r),n})(x,y),b=new Map,E=((e,t)=>r=>{const[n,o,a,s]=t(r);return a?new Promise((t=>{o.onmessage=a=>{let{data:i}=a;0===i.length?(e(o),t(n.encode(r,null))):n.record(r,s,i)}})):n.encode(r,null)})(m,M),A=(e=>t=>{for(const[r,n]of Array.from(e.values()))if(r.test(t))return n;throw new Error(\"There is no encoder registered which could handle the given mimeType.\")})(b),_=((e,t,r)=>(n,o,a)=>{if(t.has(n))throw new Error('There is already an encoder registered with an id called \"'.concat(n,'\".'));const s=r(o),{port1:i,port2:c}=new MessageChannel,u=[s,i,!0,a];return t.set(n,u),i.onmessage=t=>{let{data:r}=t;0===r.length?(e(i),u[2]=!1):s.record(n,a,r)},c})(m,x,A),I=(e=>(t,r)=>{const[n]=e(t);return n.encode(t,r)})(y);p(self,{encode:async e=>{let{encoderId:t,timeslice:r}=e;const n=null===r?await E(t):await I(t,r);return{result:n,transferables:n}},instantiate:e=>{let{encoderId:t,mimeType:r,sampleRate:n}=e;const o=_(t,r,n);return{result:o,transferables:[o]}},register:async e=>{let{port:t}=e;return{result:await w(b,t)}}})})()})();`; // tslint:disable-line:max-line-length\n","import { TInvalidModificationErrorFactory } from '../types';\n\nexport const createInvalidModificationError: TInvalidModificationErrorFactory = (message = '') => {\n    try {\n        return new DOMException(message, 'InvalidModificationError');\n    } catch (err) {\n        // @todo Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 13;\n        err.message = message;\n        err.name = 'InvalidModificationError';\n\n        return err;\n    }\n};\n","import { TNotSupportedErrorFactory } from '../types';\n\nexport const createNotSupportedError: TNotSupportedErrorFactory = () => {\n    try {\n        return new DOMException('', 'NotSupportedError');\n    } catch (err) {\n        // @todo Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 9;\n        err.name = 'NotSupportedError';\n\n        return err;\n    }\n};\n","/**\n * @license Use of this source code is governed by an MIT-style license that\n * can be found in the LICENSE file at https://github.com/cartant/rxjs-interop\n */\n\ndeclare global {\n  interface SymbolConstructor {\n    readonly observable: symbol;\n  }\n}\n\nexport const observable = Symbol.observable || \"@@observable\";\n","/**\n * @license Use of this source code is governed by an MIT-style license that\n * can be found in the LICENSE file at https://github.com/cartant/rxjs-interop\n */\n\nimport { Observer, PartialObserver } from \"./types\";\n\nconst noop = () => {};\nconst rethrow = (error: unknown) => {\n  /* eslint-disable-next-line etc/throw-error */\n  throw error;\n};\n\nexport function toObserver<T>(observer?: PartialObserver<T>): Observer<T> {\n  if (observer) {\n    if (observer.next && observer.error && observer.complete) {\n      return observer as Observer<T>;\n    }\n    return {\n      complete: (observer.complete ?? noop).bind(observer),\n      error: (observer.error ?? rethrow).bind(observer),\n      next: (observer.next ?? noop).bind(observer),\n    };\n  }\n  return {\n    complete: noop,\n    error: rethrow,\n    next: noop,\n  };\n}\n","import { TAnimationFrameFactory } from '../types';\n\nexport const createAnimationFrame: TAnimationFrameFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return () =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.cancelAnimationFrame === undefined || window.requestAnimationFrame === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            let animationFrameHandle = window.requestAnimationFrame(function animationFrameCallback(timestamp): void {\n                animationFrameHandle = window.requestAnimationFrame(animationFrameCallback);\n\n                observer.next(timestamp);\n            });\n\n            return () => window.cancelAnimationFrame(animationFrameHandle);\n        });\n};\n","import { TEmitNotSupportedErrorFunction } from '../types';\n\nexport const emitNotSupportedError: TEmitNotSupportedErrorFunction = (observer) => {\n    observer.error(new Error('The required browser API seems to be not supported.'));\n\n    return () => {}; // tslint:disable-line:no-empty\n};\n","import { patch, toObserver } from 'rxjs-interop';\nimport { createAnimationFrame } from './factories/animation-frame';\nimport { createAttribute } from './factories/attribute';\nimport { createGeolocation } from './factories/geolocation';\nimport { createIntersections } from './factories/intersections';\nimport { createMapSubscribableThing } from './factories/map-subscribable-thing';\nimport { createMediaDevices } from './factories/media-devices';\nimport { createMediaQueryMatch } from './factories/media-query-match';\nimport { createMetrics } from './factories/metrics';\nimport { createMidiInputs } from './factories/midi-inputs';\nimport { createMidiOutputs } from './factories/midi-outputs';\nimport { createMutations } from './factories/mutations';\nimport { createOn } from './factories/on';\nimport { createOnline } from './factories/online';\nimport { createPermissionState } from './factories/permission-state';\nimport { createPrependSubscribableThing } from './factories/prepend-subscribable-thing';\nimport { createReports } from './factories/reports';\nimport { createResizes } from './factories/resizes';\nimport { createUnhandledRejection } from './factories/unhandled-rejection';\nimport { createVideoFrame } from './factories/video-frame';\nimport { createWakeLock } from './factories/wake-lock';\nimport { createWindow } from './factories/window';\nimport { createWrapSubscribeFunction } from './factories/wrap-subscribe-function';\nimport { emitNotSupportedError } from './functions/emit-not-supported-error';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nconst window = createWindow();\nconst wrapSubscribeFunction = createWrapSubscribeFunction(patch, toObserver);\n\nexport const animationFrame = createAnimationFrame(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const mutations = createMutations(emitNotSupportedError, window, wrapSubscribeFunction);\n\nconst mapSubscribableThing = createMapSubscribableThing(wrapSubscribeFunction);\nconst prependSubscribableThing = createPrependSubscribableThing(wrapSubscribeFunction);\n\nexport const attribute = createAttribute(mapSubscribableThing, mutations, prependSubscribableThing);\n\nexport const geolocation = createGeolocation(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const intersections = createIntersections(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const mediaDevices = createMediaDevices(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const mediaQueryMatch = createMediaQueryMatch(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const metrics = createMetrics(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const midiInputs = createMidiInputs(wrapSubscribeFunction);\n\nexport const midiOutputs = createMidiOutputs(wrapSubscribeFunction);\n\nexport const on = createOn(wrapSubscribeFunction);\n\nexport const online = createOnline(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const permissionState = createPermissionState(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const reports = createReports(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const resizes = createResizes(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const unhandledRejection = createUnhandledRejection(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const videoFrame = createVideoFrame(emitNotSupportedError, wrapSubscribeFunction);\n\nexport const wakeLock = createWakeLock(emitNotSupportedError, window, wrapSubscribeFunction);\n","import { TWindow, TWindowFactory } from '../types';\n\n// @todo TypeScript does not include type definitions for the Reporting API yet.\nexport const createWindow: TWindowFactory = () => (typeof window === 'undefined' ? null : <TWindow>window);\n","import { Observer, Subscribable } from 'rxjs-interop';\nimport { TObserverParameters, TSubscribableThing, TSubscribeFunction, TWrapSubscribeFunctionFactory } from '../types';\n\nexport const createWrapSubscribeFunction: TWrapSubscribeFunctionFactory = (patch, toObserver) => {\n    const emptyFunction = () => {}; // tslint:disable-line:no-empty\n    const isNextFunction = <T>(args: TObserverParameters<T>): args is [Observer<T>['next']] => typeof args[0] === 'function';\n\n    return <T>(innerSubscribe: TSubscribeFunction<T>) => {\n        const subscribe = <TSubscribableThing<T>>((...args: TObserverParameters<T>) => {\n            const unsubscribe = innerSubscribe(isNextFunction(args) ? toObserver({ next: args[0] }) : toObserver(...args));\n\n            if (unsubscribe !== undefined) {\n                return unsubscribe;\n            }\n\n            return emptyFunction;\n        });\n\n        subscribe[Symbol.observable] = () => ({\n            subscribe: (...args: Parameters<Subscribable<T>['subscribe']>) => ({ unsubscribe: subscribe(...args) })\n        });\n\n        return patch(subscribe);\n    };\n};\n","/**\n * @license Use of this source code is governed by an MIT-style license that\n * can be found in the LICENSE file at https://github.com/cartant/rxjs-interop\n */\n\nimport { observable } from \"./symbols\";\nimport { InteropObservable } from \"./types\";\n\nexport function patch<T extends InteropObservable<any>>(instance: T): T;\nexport function patch<T extends new (...args: any[]) => InteropObservable<any>>(\n  constructor: T\n): T;\nexport function patch(\n  arg: InteropObservable<any> | (new (...args: any[]) => InteropObservable<any>)\n): InteropObservable<any> | (new (...args: any[]) => InteropObservable<any>) {\n  if (!Symbol.observable) {\n    if (\n      typeof arg === \"function\" &&\n      arg.prototype &&\n      arg.prototype[Symbol.observable]\n    ) {\n      (arg.prototype as any)[observable] = arg.prototype[Symbol.observable];\n      delete arg.prototype[Symbol.observable];\n    } else {\n      (arg as any)[observable] = arg[Symbol.observable];\n      delete arg[Symbol.observable];\n    }\n  }\n  return arg;\n}\n","import { TMutationsFactory } from '../types';\n\nexport const createMutations: TMutationsFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (htmlElement, options) =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.MutationObserver === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const mutationObserver = new window.MutationObserver((records) => observer.next(records));\n\n            try {\n                mutationObserver.observe(htmlElement, options);\n            } catch (err) {\n                observer.error(err);\n            }\n\n            return () => mutationObserver.disconnect();\n        });\n};\n","import { TSubscribableThing, TWrapSubscribeFunctionFunction } from '../types';\n\nexport const createMapSubscribableThing =\n    (wrapSubscribeFunction: TWrapSubscribeFunctionFunction) =>\n    <TValue, TMappedValue>(\n        subscribableThing: TSubscribableThing<TValue>,\n        map: (value: TValue) => TMappedValue\n    ): TSubscribableThing<TMappedValue> =>\n        wrapSubscribeFunction((observer) => subscribableThing({ ...observer, next: (value) => observer.next(map(value)) }));\n","import { TSubscribableThing, TWrapSubscribeFunctionFunction } from '../types';\n\nexport const createPrependSubscribableThing =\n    (wrapSubscribeFunction: TWrapSubscribeFunctionFunction) =>\n    <TValue, TPrependedValue>(\n        subscribableThing: TSubscribableThing<TValue>,\n        prependedValue: TPrependedValue\n    ): TSubscribableThing<TPrependedValue | TValue> =>\n        wrapSubscribeFunction((observer) => {\n            observer.next(prependedValue);\n\n            return subscribableThing(observer);\n        });\n","import { TSubscribableThing } from '../types';\nimport type { createMapSubscribableThing } from './map-subscribable-thing';\nimport type { createMutations } from './mutations';\nimport type { createPrependSubscribableThing } from './prepend-subscribable-thing';\n\nexport const createAttribute = (\n    mapSubscribableThing: ReturnType<typeof createMapSubscribableThing>,\n    mutations: ReturnType<typeof createMutations>,\n    prependSubscribableThing: ReturnType<typeof createPrependSubscribableThing>\n) => {\n    return (htmlElement: HTMLElement, name: string): TSubscribableThing<null | string> => {\n        const getAttribute = () => htmlElement.getAttribute(name);\n\n        return prependSubscribableThing(\n            mapSubscribableThing(\n                mutations(htmlElement, {\n                    attributeFilter: [name],\n                    childList: false,\n                    subtree: false\n                }),\n                () => getAttribute()\n            ),\n            getAttribute()\n        );\n    };\n};\n","import { TEmitNotSupportedErrorFunction, TSubscribableThing, TWindow, TWrapSubscribeFunctionFunction } from '../types';\n\nexport const createGeolocation = (\n    emitNotSupportedError: TEmitNotSupportedErrorFunction,\n    window: null | TWindow,\n    wrapSubscribeFunction: TWrapSubscribeFunctionFunction\n) => {\n    return (options?: PositionOptions): TSubscribableThing<GeolocationPosition> =>\n        wrapSubscribeFunction((observer) => {\n            if (\n                window === null ||\n                window.navigator === undefined ||\n                window.navigator.geolocation === undefined ||\n                window.navigator.geolocation.clearWatch === undefined ||\n                window.navigator.geolocation.watchPosition === undefined\n            ) {\n                return emitNotSupportedError(observer);\n            }\n\n            const watchId = window.navigator.geolocation.watchPosition(\n                (position) => observer.next(position),\n                (err) => observer.error(err),\n                options\n            );\n\n            return () => window.navigator.geolocation.clearWatch(watchId);\n        });\n};\n","import { TIntersectionsFactory } from '../types';\n\nexport const createIntersections: TIntersectionsFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (htmlElement, options) =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.IntersectionObserver === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const intersectionObserverObserver = new window.IntersectionObserver((entries) => observer.next(entries), options);\n\n            try {\n                intersectionObserverObserver.observe(htmlElement);\n            } catch (err) {\n                observer.error(err);\n            }\n\n            return () => intersectionObserverObserver.disconnect();\n        });\n};\n","import { TMediaDevicesFactory } from '../types';\n\nexport const createMediaDevices: TMediaDevicesFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return () =>\n        wrapSubscribeFunction((observer) => {\n            if (\n                window === null ||\n                window.navigator === undefined ||\n                window.navigator.mediaDevices === undefined ||\n                window.navigator.mediaDevices.enumerateDevices === undefined\n            ) {\n                return emitNotSupportedError(observer);\n            }\n\n            let isActive = true;\n\n            const enumerateDevices = () => {\n                window.navigator.mediaDevices.enumerateDevices().then(\n                    (mediaDevices) => {\n                        if (isActive) {\n                            observer.next(mediaDevices);\n                        }\n                    },\n                    (err) => {\n                        if (isActive) {\n                            unsubscribe();\n\n                            observer.error(err);\n                        }\n                    }\n                );\n            };\n            const unsubscribe = () => {\n                isActive = false;\n                window.navigator.mediaDevices.removeEventListener('devicechange', enumerateDevices);\n            };\n\n            enumerateDevices();\n            window.navigator.mediaDevices.addEventListener('devicechange', enumerateDevices);\n\n            return unsubscribe;\n        });\n};\n","import { TMediaQueryMatchFactory } from '../types';\n\nexport const createMediaQueryMatch: TMediaQueryMatchFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (mediaQueryString) =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.matchMedia === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const mediaQueryList = window.matchMedia(mediaQueryString);\n\n            observer.next(mediaQueryList.matches);\n\n            mediaQueryList.onchange = () => observer.next(mediaQueryList.matches);\n\n            return () => {\n                mediaQueryList.onchange = null;\n            };\n        });\n};\n","import { TMetricsFactory } from '../types';\n\nexport const createMetrics: TMetricsFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (options) =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.PerformanceObserver === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const performanceObserver = new window.PerformanceObserver((entryList) => observer.next(entryList.getEntries()));\n\n            try {\n                performanceObserver.observe(options);\n            } catch (err) {\n                observer.error(err);\n            }\n\n            return () => performanceObserver.disconnect();\n        });\n};\n","import { TMidiInputsFactory } from '../types';\n\nexport const createMidiInputs: TMidiInputsFactory = (wrapSubscribeFunction) => {\n    return (midiAccess) =>\n        wrapSubscribeFunction((observer) => {\n            let midiInputs = Array.from(midiAccess.inputs.values());\n\n            const emitMidiInputs = () => {\n                const midiAccessInputs = midiAccess.inputs;\n\n                if (midiInputs.length !== midiAccessInputs.size || midiInputs.some(({ id }) => !midiAccessInputs.has(id))) {\n                    midiInputs = Array.from(midiAccessInputs.values());\n\n                    observer.next(midiInputs);\n                }\n            };\n\n            observer.next(midiInputs);\n            midiAccess.addEventListener('statechange', emitMidiInputs);\n\n            return () => midiAccess.removeEventListener('statechange', emitMidiInputs);\n        });\n};\n","import { TMidiOutputsFactory } from '../types';\n\nexport const createMidiOutputs: TMidiOutputsFactory = (wrapSubscribeFunction) => {\n    return (midiAccess) =>\n        wrapSubscribeFunction((observer) => {\n            let midiOutputs = Array.from(midiAccess.outputs.values());\n\n            const emitMidiOutputs = () => {\n                const midiAccessOutputs = midiAccess.outputs;\n\n                if (midiOutputs.length !== midiAccessOutputs.size || midiOutputs.some(({ id }) => !midiAccessOutputs.has(id))) {\n                    midiOutputs = Array.from(midiAccessOutputs.values());\n\n                    observer.next(midiOutputs);\n                }\n            };\n\n            observer.next(midiOutputs);\n            midiAccess.addEventListener('statechange', emitMidiOutputs);\n\n            return () => midiAccess.removeEventListener('statechange', emitMidiOutputs);\n        });\n};\n","import { TEventHandler, TEventType, TOnFactory } from '../types';\n\nexport const createOn: TOnFactory = (wrapSubscribeFunction) => {\n    return (target, type, options) =>\n        wrapSubscribeFunction((observer) => {\n            const listener: TEventHandler<typeof target> = (event) => observer.next(<TEventType<typeof target, typeof type>>event);\n\n            target.addEventListener(type, listener, options);\n\n            return () => target.removeEventListener(type, listener, options);\n        });\n};\n","import { TOnlineFactory } from '../types';\n\nexport const createOnline: TOnlineFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return () =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.navigator === undefined || window.navigator.onLine === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const emitFalse = () => observer.next(false);\n            const emitTrue = () => observer.next(true);\n\n            window.addEventListener('offline', emitFalse);\n            window.addEventListener('online', emitTrue);\n\n            observer.next(window.navigator.onLine);\n\n            return () => {\n                window.removeEventListener('offline', emitFalse);\n                window.removeEventListener('online', emitTrue);\n            };\n        });\n};\n","import { TPermissionStateFactory } from '../types';\n\nexport const createPermissionState: TPermissionStateFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (permissionDescriptor) =>\n        wrapSubscribeFunction((observer) => {\n            if (\n                window === null ||\n                window.navigator === undefined ||\n                window.navigator.permissions === undefined ||\n                window.navigator.permissions.query === undefined\n            ) {\n                return emitNotSupportedError(observer);\n            }\n\n            let isActive = true;\n            let unsubscribe = () => {\n                isActive = false;\n            };\n\n            window.navigator.permissions.query(permissionDescriptor).then(\n                (permissionStatus) => {\n                    if (isActive) {\n                        observer.next(permissionStatus.state);\n                    }\n\n                    if (isActive) {\n                        permissionStatus.onchange = () => observer.next(permissionStatus.state);\n\n                        unsubscribe = () => {\n                            permissionStatus.onchange = null;\n                        };\n                    }\n                },\n                (err) => {\n                    if (isActive) {\n                        observer.error(err);\n                    }\n                }\n            );\n\n            return () => unsubscribe();\n        });\n};\n","import { TReportsFactory } from '../types';\n\nexport const createReports: TReportsFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (options) =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.ReportingObserver === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const reportingObserver = new window.ReportingObserver((reportList) => observer.next(reportList), options);\n\n            reportingObserver.observe();\n\n            return () => reportingObserver.disconnect();\n        });\n};\n","import { IResizeObserverEntry } from '../interfaces';\nimport { TResizesFactory } from '../types';\n\nexport const createResizes: TResizesFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (htmlElement, options) =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.ResizeObserver === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const resizeObserver = new window.ResizeObserver((entries) => observer.next(<IResizeObserverEntry[]>entries));\n\n            try {\n                resizeObserver.observe(htmlElement, options);\n            } catch (err) {\n                observer.error(err);\n            }\n\n            return () => resizeObserver.disconnect();\n        });\n};\n","import { TUnhandledRejectionFactory } from '../types';\n\nexport const createUnhandledRejection: TUnhandledRejectionFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (coolingOffPeriod) =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.clearInterval === undefined || window.setInterval === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const possiblyUnhandledRejections = new Map<Promise<any>, { reason: any; timestamp: number }>();\n\n            let intervalId: null | number = null;\n\n            const deletePossiblyUnhandledRejection = ({ promise }: PromiseRejectionEvent) => possiblyUnhandledRejections.delete(promise);\n            const emitUnhandledRejection = () => {\n                const latestTimestampToEmit = Date.now() - coolingOffPeriod;\n\n                possiblyUnhandledRejections.forEach(({ reason, timestamp }, promise) => {\n                    if (timestamp > latestTimestampToEmit) {\n                        return;\n                    }\n\n                    possiblyUnhandledRejections.delete(promise);\n                    observer.next(reason);\n                });\n\n                if (intervalId !== null && possiblyUnhandledRejections.size === 0) {\n                    window.clearInterval(intervalId);\n                    intervalId = null;\n                }\n            };\n            const registerPossiblyUnhandledRejection = (event: PromiseRejectionEvent) => {\n                event.preventDefault();\n\n                possiblyUnhandledRejections.set(event.promise, {\n                    reason: event.reason,\n                    timestamp: Date.now()\n                });\n\n                if (intervalId === null) {\n                    intervalId = window.setInterval(emitUnhandledRejection, coolingOffPeriod / 2);\n                }\n            };\n\n            window.addEventListener('rejectionhandled', deletePossiblyUnhandledRejection);\n            window.addEventListener('unhandledrejection', registerPossiblyUnhandledRejection);\n\n            return () => {\n                if (intervalId !== null) {\n                    window.clearInterval(intervalId);\n                }\n\n                window.removeEventListener('rejectionhandled', deletePossiblyUnhandledRejection);\n                window.removeEventListener('unhandledrejection', registerPossiblyUnhandledRejection);\n            };\n        });\n};\n","import { TVideoFrameFactory } from '../types';\n\nexport const createVideoFrame: TVideoFrameFactory = (emitNotSupportedError, wrapSubscribeFunction) => {\n    return (videoElement) =>\n        wrapSubscribeFunction((observer) => {\n            if (videoElement.cancelVideoFrameCallback === undefined || videoElement.requestVideoFrameCallback === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            let videoFrameHandle = videoElement.requestVideoFrameCallback(function videoFrameCallback(now, metadata): void {\n                videoFrameHandle = videoElement.requestVideoFrameCallback(videoFrameCallback);\n\n                observer.next({ ...metadata, now });\n            });\n\n            return () => videoElement.cancelVideoFrameCallback(videoFrameHandle);\n        });\n};\n","import { IWakeLockSentinel } from '../interfaces';\nimport { TWakeLockFactory } from '../types';\n\nexport const createWakeLock: TWakeLockFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (type) =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.navigator === undefined || window.navigator.wakeLock === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const releaseWakeLock = (wakeLockSentinel: IWakeLockSentinel) =>\n                wakeLockSentinel.release().catch(() => {\n                    // Ignore errors.\n                });\n            const removeReleaseEventListener = (wakeLockSentinel: IWakeLockSentinel) => {\n                wakeLockSentinel.onrelease = null;\n            };\n\n            let isActive = true;\n\n            const unsubscribeWhileRequesting = () => {\n                isActive = false;\n            };\n\n            let unsubscribe = unsubscribeWhileRequesting;\n\n            const requestWakeLock = () =>\n                window.navigator.wakeLock.request(type).then(\n                    (wakeLockSentinel) => {\n                        if (isActive) {\n                            observer.next(true);\n                        }\n\n                        if (isActive) {\n                            wakeLockSentinel.onrelease = () => {\n                                observer.next(false);\n\n                                unsubscribe = unsubscribeWhileRequesting;\n\n                                removeReleaseEventListener(wakeLockSentinel);\n                                requestWakeLock();\n                            };\n\n                            unsubscribe = () => {\n                                removeReleaseEventListener(wakeLockSentinel);\n                                releaseWakeLock(wakeLockSentinel);\n                            };\n                        } else {\n                            releaseWakeLock(wakeLockSentinel);\n                        }\n                    },\n                    (err) => {\n                        if (isActive) {\n                            observer.error(err);\n                        }\n                    }\n                );\n\n            requestWakeLock();\n\n            return () => unsubscribe();\n        });\n};\n","import { IAugmentedError, IParameterObject, compile } from 'compilerr';\n\nconst JSON_RPC_ERROR_CODES = { INTERNAL_ERROR: -32603, INVALID_PARAMS: -32602, METHOD_NOT_FOUND: -32601 };\n\nexport const renderMethodNotFoundError: (missingParameters: IParameterObject) => IAugmentedError = compile({\n    message: 'The requested method called \"${method}\" is not supported.',\n    status: JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND\n});\n\nexport const renderMissingResponseError: (missingParameters: IParameterObject) => IAugmentedError = compile({\n    message: 'The handler of the method called \"${method}\" returned no required result.',\n    status: JSON_RPC_ERROR_CODES.INTERNAL_ERROR\n});\n\nexport const renderUnexpectedResultError: (missingParameters: IParameterObject) => IAugmentedError = compile({\n    message: 'The handler of the method called \"${method}\" returned an unexpected result.',\n    status: JSON_RPC_ERROR_CODES.INTERNAL_ERROR\n});\n\nexport const renderUnknownPortIdError: (missingParameters: IParameterObject) => IAugmentedError = compile({\n    message: 'The specified parameter called \"portId\" with the given value \"${portId}\" does not identify a port connected to this worker.',\n    status: JSON_RPC_ERROR_CODES.INVALID_PARAMS\n});\n","import { generateUniqueNumber } from 'fast-unique-numbers';\nimport { on } from 'subscribable-things';\nimport { isSupported } from 'worker-factory';\nimport { createAddRecorderAudioWorkletModule } from './factories/add-recorder-audio-worklet-module';\nimport { createListener } from './factories/listener';\nimport { createPostMessageFactory } from './factories/post-message-factory';\nimport { createRecorderAudioWorkletNodeFactory } from './factories/recorder-audio-worklet-node-factory';\nimport { validateState } from './functions/validate-state';\nimport { worklet } from './worklet/worklet';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nexport const addRecorderAudioWorkletModule = createAddRecorderAudioWorkletModule(Blob, URL, worklet);\n\nexport const createRecorderAudioWorkletNode = createRecorderAudioWorkletNodeFactory(\n    createListener,\n    createPostMessageFactory(generateUniqueNumber),\n    on,\n    validateState\n);\n\nexport { isSupported };\n","import { generateUniqueNumber } from 'fast-unique-numbers';\nimport { IDefaultWorkerDefinition, IReceiver, IWorkerDefinition } from '../interfaces';\nimport { TDestroyWorkerFunction, TWorkerImplementation } from '../types';\nimport { renderUnknownPortIdError } from './error-renderers';\nimport { isSupportingTransferables } from './is-supporting-transferables';\n\nconst DESTROY_WORKER_FUNCTIONS: Map<number, TDestroyWorkerFunction> = new Map();\n\nexport const extendWorkerImplementation = <T extends IWorkerDefinition>(\n    createWorker: (receiver: IReceiver, workerImplementation: TWorkerImplementation<T>) => TDestroyWorkerFunction,\n    partialWorkerImplementation: TWorkerImplementation<T>,\n    isSupportedFunction: () => boolean | Promise<boolean>\n): TWorkerImplementation<T> & TWorkerImplementation<IDefaultWorkerDefinition> => ({\n    ...partialWorkerImplementation,\n    connect: ({ port }) => {\n        port.start();\n\n        const destroyWorker = createWorker(port, partialWorkerImplementation);\n        const portId = generateUniqueNumber(DESTROY_WORKER_FUNCTIONS);\n\n        DESTROY_WORKER_FUNCTIONS.set(portId, () => {\n            destroyWorker();\n            port.close();\n            DESTROY_WORKER_FUNCTIONS.delete(portId);\n        });\n\n        return { result: portId };\n    },\n    disconnect: ({ portId }) => {\n        const destroyWorker = DESTROY_WORKER_FUNCTIONS.get(portId);\n\n        if (destroyWorker === undefined) {\n            throw renderUnknownPortIdError({ portId: portId.toString() });\n        }\n\n        destroyWorker();\n\n        return { result: null };\n    },\n    isSupported: async () => {\n        const isSelfSupported = await isSupportingTransferables();\n\n        if (isSelfSupported) {\n            const result = isSupportedFunction();\n            const synchronousResult = result instanceof Promise ? await result : result;\n\n            return { result: synchronousResult };\n        }\n\n        return { result: false };\n    }\n});\n","export const createAddRecorderAudioWorkletModule = (blobConstructor: typeof Blob, urlConstructor: typeof URL, worklet: string) => {\n    return async (addAudioWorkletModule: (url: string) => Promise<void>) => {\n        const blob = new blobConstructor([worklet], { type: 'application/javascript; charset=utf-8' });\n        const url = urlConstructor.createObjectURL(blob);\n\n        try {\n            await addAudioWorkletModule(url);\n        } finally {\n            urlConstructor.revokeObjectURL(url);\n        }\n    };\n};\n","// This is the minified and stringified code of the recorder-audio-worklet-processor package.\nexport const worklet = `(()=>{\"use strict\";class e extends AudioWorkletProcessor{constructor(){super(),this._encoderPort=null,this._state=\"inactive\",this.port.onmessage=e=>{let{data:t}=e;\"pause\"===t.method?\"active\"===this._state||\"recording\"===this._state?(this._state=\"paused\",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):\"record\"===t.method?\"inactive\"===this._state?(this._encoderPort=t.params.encoderPort,this._state=\"active\",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):\"resume\"===t.method?\"paused\"===this._state?(this._state=\"active\",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):\"stop\"===t.method?\"active\"!==this._state&&\"paused\"!==this._state&&\"recording\"!==this._state||null===this._encoderPort?this._sendUnexpectedStateError(t.id):(this._stop(this._encoderPort),this._sendAcknowledgement(t.id)):\"number\"==typeof t.id&&this.port.postMessage({error:{code:-32601,message:\"The requested method is not supported.\"},id:t.id})}}process(e){let[t]=e;if(\"inactive\"===this._state||\"paused\"===this._state)return!0;if(\"active\"===this._state){if(void 0===t)throw new Error(\"No channelData was received for the first input.\");if(0===t.length)return!0;this._state=\"recording\"}if(\"recording\"===this._state&&null!==this._encoderPort){if(void 0===t)throw new Error(\"No channelData was received for the first input.\");if(0!==t.length)return this._encoderPort.postMessage(t,t.map((e=>{let{buffer:t}=e;return t}))),!0;this._stop(this._encoderPort)}return!1}_sendAcknowledgement(e){this.port.postMessage({id:e,result:null})}_sendUnexpectedStateError(e){this.port.postMessage({error:{code:-32603,message:\"The internal state does not allow to process the given message.\"},id:e})}_stop(e){e.postMessage([]),e.close(),this._encoderPort=null,this._state=\"stopped\"}}e.parameterDescriptors=[],registerProcessor(\"recorder-audio-worklet-processor\",e)})();`; // tslint:disable-line:max-line-length\n","import type {\n    IAudioWorkletNode,\n    TAudioWorkletNodeConstructor,\n    TContext,\n    TNativeAudioWorkletNode,\n    TNativeAudioWorkletNodeConstructor,\n    TNativeContext\n} from 'standardized-audio-context';\nimport type { on as onFunction } from 'subscribable-things';\nimport type { validateState as validateStateFunction } from '../functions/validate-state';\nimport { INativeRecorderAudioWorkletNode, IRecorderAudioWorkletNode } from '../interfaces';\nimport { TAnyRecorderAudioWorkletNodeOptions, TState } from '../types';\nimport type { createListener as createListenerFunction } from './listener';\nimport type { createPostMessageFactory } from './post-message-factory';\n\nexport const createRecorderAudioWorkletNodeFactory = (\n    createListener: typeof createListenerFunction,\n    createPostMessage: ReturnType<typeof createPostMessageFactory>,\n    on: typeof onFunction,\n    validateState: typeof validateStateFunction\n) => {\n    return <T extends TContext | TNativeContext>(\n        audioWorkletNodeConstructor: T extends TContext ? TAudioWorkletNodeConstructor : TNativeAudioWorkletNodeConstructor,\n        context: T,\n        options: Partial<TAnyRecorderAudioWorkletNodeOptions<T>> = {}\n    ): T extends TContext ? IRecorderAudioWorkletNode<T> : INativeRecorderAudioWorkletNode => {\n        type TAnyAudioWorkletNode = T extends TContext ? IAudioWorkletNode<T> : TNativeAudioWorkletNode;\n        type TAnyRecorderAudioWorkletNode = T extends TContext ? IRecorderAudioWorkletNode<T> : INativeRecorderAudioWorkletNode;\n\n        const audioWorkletNode: TAnyAudioWorkletNode = new (<any>audioWorkletNodeConstructor)(context, 'recorder-audio-worklet-processor', {\n            ...options,\n            channelCountMode: 'explicit',\n            numberOfInputs: 1,\n            numberOfOutputs: 0\n        });\n        const ongoingRequests: Map<number, { reject: Function; resolve: Function }> = new Map();\n        const postMessage = createPostMessage(ongoingRequests, audioWorkletNode.port);\n        const unsubscribe = on(audioWorkletNode.port, 'message')(createListener(ongoingRequests));\n\n        audioWorkletNode.port.start();\n\n        let state: TState = 'inactive';\n\n        Object.defineProperties(audioWorkletNode, {\n            pause: {\n                get(): TAnyRecorderAudioWorkletNode['pause'] {\n                    return async () => {\n                        validateState(['recording'], state);\n\n                        state = 'paused';\n\n                        return postMessage({\n                            method: 'pause'\n                        });\n                    };\n                }\n            },\n            port: {\n                get(): TAnyRecorderAudioWorkletNode['port'] {\n                    throw new Error(\"The port of a RecorderAudioWorkletNode can't be accessed.\");\n                }\n            },\n            record: {\n                get(): TAnyRecorderAudioWorkletNode['record'] {\n                    return async (encoderPort: MessagePort) => {\n                        validateState(['inactive'], state);\n\n                        state = 'recording';\n\n                        return postMessage(\n                            {\n                                method: 'record',\n                                params: { encoderPort }\n                            },\n                            [encoderPort]\n                        );\n                    };\n                }\n            },\n            resume: {\n                get(): TAnyRecorderAudioWorkletNode['resume'] {\n                    return async () => {\n                        validateState(['paused'], state);\n\n                        state = 'recording';\n\n                        return postMessage({\n                            method: 'resume'\n                        });\n                    };\n                }\n            },\n            stop: {\n                get(): TAnyRecorderAudioWorkletNode['stop'] {\n                    return async () => {\n                        validateState(['paused', 'recording'], state);\n\n                        state = 'stopped';\n\n                        try {\n                            await postMessage({ method: 'stop' });\n                        } finally {\n                            unsubscribe();\n                        }\n                    };\n                }\n            }\n        });\n\n        return <TAnyRecorderAudioWorkletNode>audioWorkletNode;\n    };\n};\n","import type { IWorkerEvent } from 'broker-factory';\nimport type { IWorkerErrorMessage, IWorkerResultMessage } from 'worker-factory';\n\nexport const createListener = (ongoingRequests: Map<number, { reject: Function; resolve: Function }>) => {\n    return ({ data: message }: IWorkerEvent) => {\n        const { id } = message;\n\n        if (id !== null) {\n            const ongoingRequest = ongoingRequests.get(id);\n\n            if (ongoingRequest !== undefined) {\n                const { reject, resolve } = ongoingRequest;\n\n                ongoingRequests.delete(id);\n\n                if ((<IWorkerErrorMessage>message).error === undefined) {\n                    resolve((<IWorkerResultMessage>message).result);\n                } else {\n                    reject(new Error((<IWorkerErrorMessage>message).error.message));\n                }\n            }\n        }\n    };\n};\n","import type { generateUniqueNumber as generateUniqueNumberFunction } from 'fast-unique-numbers';\n\nexport const createPostMessageFactory = (generateUniqueNumber: typeof generateUniqueNumberFunction) => {\n    return (ongoingRequests: Map<number, { reject: Function; resolve: Function }>, port: MessagePort) => {\n        return (message: { method: string; params?: object }, transferables: Transferable[] = []): Promise<void> => {\n            return new Promise((resolve, reject) => {\n                const id = generateUniqueNumber(ongoingRequests);\n\n                ongoingRequests.set(id, { reject, resolve });\n\n                port.postMessage({ id, ...message }, transferables);\n            });\n        };\n    };\n};\n","import { TState } from '../types';\n\nexport const validateState = (expectedStates: TState[], currentState: TState): void => {\n    if (!expectedStates.includes(currentState)) {\n        throw new Error(\n            `Expected the state to be ${expectedStates\n                .map((expectedState) => `\"${expectedState}\"`)\n                .join(' or ')} but it was \"${currentState}\".`\n        );\n    }\n};\n","import { IAudioNode, IAudioWorkletProcessor, IAudioWorkletProcessorConstructor } from './interfaces';\nimport {\n    TAudioNodeConnectionsStore,\n    TAudioNodeStore,\n    TAudioParamConnectionsStore,\n    TAudioParamStore,\n    TContext,\n    TContextStore,\n    TCycleCounters,\n    TInternalStateEventListener,\n    TNativeAudioWorkletNode,\n    TNativeContext\n} from './types';\n\nexport const ACTIVE_AUDIO_NODE_STORE: WeakSet<IAudioNode<TContext>> = new WeakSet();\n\nexport const AUDIO_NODE_CONNECTIONS_STORE: TAudioNodeConnectionsStore = new WeakMap();\n\nexport const AUDIO_NODE_STORE: TAudioNodeStore = new WeakMap();\n\nexport const AUDIO_PARAM_CONNECTIONS_STORE: TAudioParamConnectionsStore = new WeakMap();\n\nexport const AUDIO_PARAM_STORE: TAudioParamStore = new WeakMap();\n\nexport const CONTEXT_STORE: TContextStore = new WeakMap();\n\nexport const EVENT_LISTENERS: WeakMap<IAudioNode<TContext>, Set<TInternalStateEventListener>> = new WeakMap();\n\nexport const CYCLE_COUNTERS: TCycleCounters = new WeakMap();\n\n// This clunky name is borrowed from the spec. :-)\nexport const NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS: WeakMap<\n    TNativeContext,\n    Map<string, IAudioWorkletProcessorConstructor>\n> = new WeakMap();\n\nexport const NODE_TO_PROCESSOR_MAPS: WeakMap<\n    TNativeContext,\n    WeakMap<TNativeAudioWorkletNode, Promise<IAudioWorkletProcessor>>\n> = new WeakMap();\n","import { TConstructor } from '../types';\n\nconst handler = {\n    construct(): any {\n        return handler;\n    }\n};\n\nexport const isConstructible = (constructible: TConstructor): boolean => {\n    try {\n        const proxy = new Proxy(constructible, handler);\n\n        new proxy(); // tslint:disable-line:no-unused-expression\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n","/*\n * This massive regex tries to cover all the following cases.\n *\n * import './path';\n * import defaultImport from './path';\n * import { namedImport } from './path';\n * import { namedImport as renamendImport } from './path';\n * import * as namespaceImport from './path';\n * import defaultImport, { namedImport } from './path';\n * import defaultImport, { namedImport as renamendImport } from './path';\n * import defaultImport, * as namespaceImport from './path';\n */\nconst IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/; // tslint:disable-line:max-line-length\n\nexport const splitImportStatements = (source: string, url: string): [string, string] => {\n    const importStatements = [];\n\n    let sourceWithoutImportStatements = source.replace(/^[\\s]+/, '');\n    let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n\n    while (result !== null) {\n        const unresolvedUrl = result[1].slice(1, -1);\n\n        const importStatementWithResolvedUrl = result[0]\n            .replace(/([\\s]+)?;?$/, '')\n            .replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());\n        importStatements.push(importStatementWithResolvedUrl);\n\n        sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\\s]+/, '');\n        result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    }\n\n    return [importStatements.join(';'), sourceWithoutImportStatements];\n};\n","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\nimport { IAudioWorkletProcessorConstructor } from '../interfaces';\nimport { TAddAudioWorkletModuleFactory, TEvaluateAudioWorkletGlobalScopeFunction } from '../types';\n\nconst verifyParameterDescriptors = (parameterDescriptors: IAudioWorkletProcessorConstructor['parameterDescriptors']) => {\n    if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n    }\n};\n\nconst verifyProcessorCtor = <T extends IAudioWorkletProcessorConstructor>(processorCtor: T) => {\n    if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n    }\n\n    if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n    }\n};\n\nexport const createAddAudioWorkletModule: TAddAudioWorkletModuleFactory = (\n    cacheTestResult,\n    createNotSupportedError,\n    evaluateSource,\n    exposeCurrentFrameAndCurrentTime,\n    fetchSource,\n    getNativeContext,\n    getOrCreateBackupOfflineAudioContext,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor,\n    ongoingRequests,\n    resolvedRequests,\n    testAudioWorkletProcessorPostMessageSupport,\n    window\n) => {\n    let index = 0;\n\n    return (context, moduleURL, options = { credentials: 'omit' }) => {\n        const resolvedRequestsOfContext = resolvedRequests.get(context);\n\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n            return Promise.resolve();\n        }\n\n        const ongoingRequestsOfContext = ongoingRequests.get(context);\n\n        if (ongoingRequestsOfContext !== undefined) {\n            const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n\n            if (promiseOfOngoingRequest !== undefined) {\n                return promiseOfOngoingRequest;\n            }\n        }\n\n        const nativeContext = getNativeContext(context);\n\n        // Bug #59: Safari does not implement the audioWorklet property.\n        const promise =\n            nativeContext.audioWorklet === undefined\n                ? fetchSource(moduleURL)\n                      .then(([source, absoluteUrl]) => {\n                          const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n\n                          /*\n                           * This is the unminified version of the code used below:\n                           *\n                           * ```js\n                           * ${ importStatements };\n                           * ((a, b) => {\n                           *     (a[b] = a[b] || [ ]).push(\n                           *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n                           *             ${ sourceWithoutImportStatements }\n                           *         }\n                           *     );\n                           * })(window, '_AWGS');\n                           * ```\n                           */\n                          // tslint:disable-next-line:max-line-length\n                          const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`;\n\n                          // @todo Evaluating the given source code is a possible security problem.\n                          return evaluateSource(wrappedSource);\n                      })\n                      .then(() => {\n                          const evaluateAudioWorkletGlobalScope = (<TEvaluateAudioWorkletGlobalScopeFunction[]>(<any>window)._AWGS).pop();\n\n                          if (evaluateAudioWorkletGlobalScope === undefined) {\n                              // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                              throw new SyntaxError();\n                          }\n\n                          exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () =>\n                              evaluateAudioWorkletGlobalScope(\n                                  class AudioWorkletProcessor {},\n                                  undefined,\n                                  (name, processorCtor) => {\n                                      if (name.trim() === '') {\n                                          throw createNotSupportedError();\n                                      }\n\n                                      const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n\n                                      if (nodeNameToProcessorConstructorMap !== undefined) {\n                                          if (nodeNameToProcessorConstructorMap.has(name)) {\n                                              throw createNotSupportedError();\n                                          }\n\n                                          verifyProcessorCtor(processorCtor);\n                                          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n\n                                          nodeNameToProcessorConstructorMap.set(name, processorCtor);\n                                      } else {\n                                          verifyProcessorCtor(processorCtor);\n                                          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n\n                                          NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n                                      }\n                                  },\n                                  nativeContext.sampleRate,\n                                  undefined,\n                                  undefined\n                              )\n                          );\n                      })\n                : Promise.all([\n                      fetchSource(moduleURL),\n                      Promise.resolve(\n                          cacheTestResult(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport)\n                      )\n                  ]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {\n                      const currentIndex = index + 1;\n\n                      index = currentIndex;\n\n                      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                      /*\n                       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                       *\n                       * This is the unminified version of the code used below.\n                       *\n                       * ```js\n                       * class extends AudioWorkletProcessor {\n                       *\n                       *     __buffers = new WeakSet();\n                       *\n                       *     constructor () {\n                       *         super();\n                       *\n                       *         this.port.postMessage = ((postMessage) => {\n                       *             return (message, transferables) => {\n                       *                 const filteredTransferables = (transferables)\n                       *                     ? transferables.filter((transferable) => !this.__buffers.has(transferable))\n                       *                     : transferables;\n                       *\n                       *                 return postMessage.call(this.port, message, filteredTransferables);\n                       *              };\n                       *         })(this.port.postMessage);\n                       *     }\n                       * }\n                       * ```\n                       */\n                      const patchedAudioWorkletProcessor = isSupportingPostMessage\n                          ? 'AudioWorkletProcessor'\n                          : 'class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}';\n                      /*\n                       * Bug #170: Chrome and Edge do call process() with an array with empty channelData for each input if no input is connected.\n                       *\n                       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                       *\n                       * Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                       *\n                       * This is the unminified version of the code used below:\n                       *\n                       * ```js\n                       * `${ importStatements };\n                       * ((AudioWorkletProcessor, registerProcessor) => {${ sourceWithoutImportStatements }\n                       * })(\n                       *     ${patchedAudioWorkletProcessor },\n                       *     (name, processorCtor) => registerProcessor(name, class extends processorCtor {\n                       *\n                       *         __collectBuffers = (array) => {\n                       *             array.forEach((element) => this.__buffers.add(element.buffer));\n                       *         };\n                       *\n                       *         process (inputs, outputs, parameters) {\n                       *             inputs.forEach(this.__collectBuffers);\n                       *             outputs.forEach(this.__collectBuffers);\n                       *             this.__collectBuffers(Object.values(parameters));\n                       *\n                       *             return super.process(\n                       *                 (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n                       *                 outputs,\n                       *                 parameters\n                       *             );\n                       *         }\n                       *\n                       *     })\n                       * );\n                       *\n                       * registerProcessor(`__sac${currentIndex}`, class extends AudioWorkletProcessor{\n                       *\n                       *     process () {\n                       *         return false;\n                       *     }\n                       *\n                       * })`\n                       * ```\n                       */\n                      const memberDefinition = isSupportingPostMessage ? '' : '__c = (a) => a.forEach(e=>this.__b.add(e.buffer));';\n                      const bufferRegistration = isSupportingPostMessage\n                          ? ''\n                          : 'i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));';\n                      const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}\n})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;\n                      const blob = new Blob([wrappedSource], { type: 'application/javascript; charset=utf-8' });\n                      const url = URL.createObjectURL(blob);\n\n                      return nativeContext.audioWorklet\n                          .addModule(url, options)\n                          .then(() => {\n                              if (isNativeOfflineAudioContext(nativeContext)) {\n                                  return nativeContext;\n                              }\n\n                              // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n                              const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext(nativeContext);\n\n                              return backupOfflineAudioContext.audioWorklet.addModule(url, options).then(() => backupOfflineAudioContext);\n                          })\n                          .then((nativeContextOrBackupOfflineAudioContext) => {\n                              if (nativeAudioWorkletNodeConstructor === null) {\n                                  throw new SyntaxError();\n                              }\n\n                              try {\n                                  // Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                                  new nativeAudioWorkletNodeConstructor(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`); // tslint:disable-line:no-unused-expression\n                              } catch {\n                                  throw new SyntaxError();\n                              }\n                          })\n                          .finally(() => URL.revokeObjectURL(url));\n                  });\n\n        if (ongoingRequestsOfContext === undefined) {\n            ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        } else {\n            ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n\n        promise\n            .then(() => {\n                const updatedResolvedRequestsOfContext = resolvedRequests.get(context);\n\n                if (updatedResolvedRequestsOfContext === undefined) {\n                    resolvedRequests.set(context, new Set([moduleURL]));\n                } else {\n                    updatedResolvedRequestsOfContext.add(moduleURL);\n                }\n            })\n            .finally(() => {\n                const updatedOngoingRequestsOfContext = ongoingRequests.get(context);\n\n                if (updatedOngoingRequestsOfContext !== undefined) {\n                    updatedOngoingRequestsOfContext.delete(moduleURL);\n                }\n            });\n\n        return promise;\n    };\n};\n","import { TGetValueForKeyFunction } from '../types';\n\nexport const getValueForKey: TGetValueForKeyFunction = (map, key) => {\n    const value = map.get(key);\n\n    if (value === undefined) {\n        throw new Error('A value with the given key could not be found.');\n    }\n\n    return value;\n};\n","import { TPickElementFromSetFunction } from '../types';\n\nexport const pickElementFromSet: TPickElementFromSetFunction = (set, predicate) => {\n    const matchingElements = Array.from(set).filter(predicate);\n\n    if (matchingElements.length > 1) {\n        throw Error('More than one element was found.');\n    }\n\n    if (matchingElements.length === 0) {\n        throw Error('No element was found.');\n    }\n\n    const [matchingElement] = matchingElements;\n\n    set.delete(matchingElement);\n\n    return matchingElement;\n};\n","import { IAudioNode } from '../interfaces';\nimport { TContext, TPassiveAudioNodeInputConnection } from '../types';\nimport { getValueForKey } from './get-value-for-key';\nimport { pickElementFromSet } from './pick-element-from-set';\n\nexport const deletePassiveInputConnectionToAudioNode = <T extends TContext>(\n    passiveInputs: WeakMap<IAudioNode<T>, Set<TPassiveAudioNodeInputConnection>>,\n    source: IAudioNode<T>,\n    output: number,\n    input: number\n) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(\n        passiveInputConnections,\n        (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input\n    );\n\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n\n    return matchingConnection;\n};\n","import { EVENT_LISTENERS } from '../globals';\nimport { TGetEventListenersOfAudioNodeFunction } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getEventListenersOfAudioNode: TGetEventListenersOfAudioNodeFunction = (audioNode) => {\n    return getValueForKey(EVENT_LISTENERS, audioNode);\n};\n","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\n\nexport const setInternalStateToActive = <T extends TContext>(audioNode: IAudioNode<T>) => {\n    if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is already stored.');\n    }\n\n    ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(true));\n};\n","import { IAudioNode, IAudioWorkletNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isAudioWorkletNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IAudioWorkletNode<T> => {\n    return 'port' in audioNode;\n};\n","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\n\nexport const setInternalStateToPassive = <T extends TContext>(audioNode: IAudioNode<T>) => {\n    if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is not stored.');\n    }\n\n    ACTIVE_AUDIO_NODE_STORE.delete(audioNode);\n\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(false));\n};\n","import { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext } from '../types';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\n\n// Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.\nexport const setInternalStateToPassiveWhenNecessary = <T extends TContext>(\n    audioNode: IAudioNode<T>,\n    activeInputs: Set<TActiveInputConnection<T>>[]\n) => {\n    if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => connections.size === 0)) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n","import { IAnalyserNode, IAnalyserOptions } from '../interfaces';\nimport { TAnalyserNodeConstructorFactory, TAudioNodeRenderer, TContext, TNativeAnalyserNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    fftSize: 2048,\n    maxDecibels: -30,\n    minDecibels: -100,\n    smoothingTimeConstant: 0.8\n} as const;\n\nexport const createAnalyserNodeConstructor: TAnalyserNodeConstructorFactory = (\n    audionNodeConstructor,\n    createAnalyserNodeRenderer,\n    createIndexSizeError,\n    createNativeAnalyserNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class AnalyserNode<T extends TContext> extends audionNodeConstructor<T> implements IAnalyserNode<T> {\n        private _nativeAnalyserNode: TNativeAnalyserNode;\n\n        constructor(context: T, options?: Partial<IAnalyserOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAnalyserNode = createNativeAnalyserNode(nativeContext, mergedOptions);\n            const analyserNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isNativeOfflineAudioContext(nativeContext) ? createAnalyserNodeRenderer() : null)\n            );\n\n            super(context, false, nativeAnalyserNode, analyserNodeRenderer);\n\n            this._nativeAnalyserNode = nativeAnalyserNode;\n        }\n\n        get fftSize(): number {\n            return this._nativeAnalyserNode.fftSize;\n        }\n\n        set fftSize(value) {\n            this._nativeAnalyserNode.fftSize = value;\n        }\n\n        get frequencyBinCount(): number {\n            return this._nativeAnalyserNode.frequencyBinCount;\n        }\n\n        get maxDecibels(): number {\n            return this._nativeAnalyserNode.maxDecibels;\n        }\n\n        set maxDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const maxDecibels = this._nativeAnalyserNode.maxDecibels;\n\n            this._nativeAnalyserNode.maxDecibels = value;\n\n            if (!(value > this._nativeAnalyserNode.minDecibels)) {\n                this._nativeAnalyserNode.maxDecibels = maxDecibels;\n\n                throw createIndexSizeError();\n            }\n        }\n\n        get minDecibels(): number {\n            return this._nativeAnalyserNode.minDecibels;\n        }\n\n        set minDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const minDecibels = this._nativeAnalyserNode.minDecibels;\n\n            this._nativeAnalyserNode.minDecibels = value;\n\n            if (!(this._nativeAnalyserNode.maxDecibels > value)) {\n                this._nativeAnalyserNode.minDecibels = minDecibels;\n\n                throw createIndexSizeError();\n            }\n        }\n\n        get smoothingTimeConstant(): number {\n            return this._nativeAnalyserNode.smoothingTimeConstant;\n        }\n\n        set smoothingTimeConstant(value) {\n            this._nativeAnalyserNode.smoothingTimeConstant = value;\n        }\n\n        public getByteFrequencyData(array: Uint8Array): void {\n            this._nativeAnalyserNode.getByteFrequencyData(array);\n        }\n\n        public getByteTimeDomainData(array: Uint8Array): void {\n            this._nativeAnalyserNode.getByteTimeDomainData(array);\n        }\n\n        public getFloatFrequencyData(array: Float32Array): void {\n            this._nativeAnalyserNode.getFloatFrequencyData(array);\n        }\n\n        public getFloatTimeDomainData(array: Float32Array): void {\n            this._nativeAnalyserNode.getFloatTimeDomainData(array);\n        }\n    };\n};\n","import { TNativeAudioNode, TNativeContext } from '../types';\n\nexport const isOwnedByContext = (nativeAudioNode: TNativeAudioNode, nativeContext: TNativeContext): boolean => {\n    return nativeAudioNode.context === nativeContext;\n};\n","import { TNativeAudioBuffer } from '../types';\n\nexport const testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer: TNativeAudioBuffer): boolean => {\n    try {\n        nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n","import { TIndexSizeErrorFactory } from '../types';\n\nexport const createIndexSizeError: TIndexSizeErrorFactory = () => new DOMException('', 'IndexSizeError');\n","import { createIndexSizeError } from '../factories/index-size-error';\nimport { TNativeAudioBuffer } from '../types';\n\nexport const wrapAudioBufferGetChannelDataMethod = (audioBuffer: TNativeAudioBuffer): void => {\n    audioBuffer.getChannelData = ((getChannelData) => {\n        return (channel: number) => {\n            try {\n                return getChannelData.call(audioBuffer, channel);\n            } catch (err) {\n                if (err.code === 12) {\n                    throw createIndexSizeError();\n                }\n\n                throw err;\n            }\n        };\n    })(audioBuffer.getChannelData);\n};\n","import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { IAudioBuffer, IAudioBufferOptions } from '../interfaces';\nimport { TAudioBufferConstructorFactory, TNativeOfflineAudioContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createAudioBufferConstructor: TAudioBufferConstructorFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    createNotSupportedError,\n    nativeAudioBufferConstructor,\n    nativeOfflineAudioContextConstructor,\n    testNativeAudioBufferConstructorSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    let nativeOfflineAudioContext: null | TNativeOfflineAudioContext = null;\n\n    return class AudioBuffer implements IAudioBuffer {\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public copyFromChannel!: (destination: Float32Array, channelNumber: number, bufferOffset?: number) => void;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public copyToChannel!: (source: Float32Array, channelNumber: number, bufferOffset?: number) => void;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public duration!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public getChannelData!: (channel: number) => Float32Array;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public length!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public numberOfChannels!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public sampleRate!: number;\n\n        constructor(options: IAudioBufferOptions) {\n            if (nativeOfflineAudioContextConstructor === null) {\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            if (nativeOfflineAudioContext === null) {\n                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n            }\n\n            /*\n             * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n             * factory function. But since Firefox also supports the constructor everything should be fine.\n             */\n            const audioBuffer =\n                nativeAudioBufferConstructor !== null &&\n                cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport)\n                    ? new nativeAudioBufferConstructor({ length, numberOfChannels, sampleRate })\n                    : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n\n            // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n            if (audioBuffer.numberOfChannels === 0) {\n                throw createNotSupportedError();\n            }\n\n            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n            // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n            if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n            } else if (\n                !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                    testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                )\n            ) {\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n\n            audioBufferStore.add(audioBuffer);\n\n            /*\n             * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n             * (Offline)AudioContexts.\n             */\n            return audioBuffer;\n        }\n\n        public static [Symbol.hasInstance](instance: unknown): boolean {\n            return (\n                (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype) ||\n                audioBufferStore.has(<any>instance)\n            );\n        }\n    };\n};\n","export const MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;\n\nexport const MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;\n","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { TIsActiveAudioNodeFunction } from '../types';\n\nexport const isActiveAudioNode: TIsActiveAudioNodeFunction = (audioNode) => ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport { IAudioBufferSourceNode, IAudioBufferSourceOptions, IAudioParam, IAudioScheduledSourceNodeEventMap } from '../interfaces';\nimport {\n    TAnyAudioBuffer,\n    TAudioBufferSourceNodeConstructorFactory,\n    TAudioBufferSourceNodeRenderer,\n    TContext,\n    TEventHandler,\n    TNativeAudioBufferSourceNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    loop: false,\n    loopEnd: 0,\n    loopStart: 0,\n    playbackRate: 1\n} as const;\n\nexport const createAudioBufferSourceNodeConstructor: TAudioBufferSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioBufferSourceNodeRenderer,\n    createAudioParam,\n    createInvalidStateError,\n    createNativeAudioBufferSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n) => {\n    return class AudioBufferSourceNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioScheduledSourceNodeEventMap>\n        implements IAudioBufferSourceNode<T>\n    {\n        private _audioBufferSourceNodeRenderer: TAudioBufferSourceNodeRenderer<T>;\n\n        private _isBufferNullified: boolean;\n\n        private _isBufferSet: boolean;\n\n        private _nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode;\n\n        private _onended: null | TEventHandler<this>;\n\n        private _playbackRate: IAudioParam;\n\n        constructor(context: T, options?: Partial<IAudioBufferSourceOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const audioBufferSourceNodeRenderer = <TAudioBufferSourceNodeRenderer<T>>(\n                (isOffline ? createAudioBufferSourceNodeRenderer() : null)\n            );\n\n            super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n\n            this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n            this._isBufferNullified = false;\n            this._isBufferSet = mergedOptions.buffer !== null;\n            this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n            this._onended = null;\n            // Bug #73: Safari does not export the correct values for maxValue and minValue.\n            this._playbackRate = createAudioParam(\n                this,\n                isOffline,\n                nativeAudioBufferSourceNode.playbackRate,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n        }\n\n        get buffer(): null | TAnyAudioBuffer {\n            if (this._isBufferNullified) {\n                return null;\n            }\n\n            return this._nativeAudioBufferSourceNode.buffer;\n        }\n\n        set buffer(value) {\n            this._nativeAudioBufferSourceNode.buffer = value;\n\n            // Bug #72: Only Chrome & Edge do not allow to reassign the buffer yet.\n            if (value !== null) {\n                if (this._isBufferSet) {\n                    throw createInvalidStateError();\n                }\n\n                this._isBufferSet = true;\n            }\n        }\n\n        get loop(): boolean {\n            return this._nativeAudioBufferSourceNode.loop;\n        }\n\n        set loop(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n        }\n\n        get loopEnd(): number {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n        }\n\n        set loopEnd(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n        }\n\n        get loopStart(): number {\n            return this._nativeAudioBufferSourceNode.loopStart;\n        }\n\n        set loopStart(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n        }\n\n        get onended(): null | TEventHandler<this> {\n            return this._onended;\n        }\n\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n\n            const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n\n        get playbackRate(): IAudioParam {\n            return this._playbackRate;\n        }\n\n        public start(when = 0, offset = 0, duration?: number): void {\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n            }\n\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n\n                const resetInternalStateToPassive = () => {\n                    this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n\n                this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n\n        public stop(when = 0): void {\n            this._nativeAudioBufferSourceNode.stop(when);\n\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n","import { AUDIO_NODE_CONNECTIONS_STORE } from '../globals';\nimport { IAudioNode } from '../interfaces';\nimport { TAudioNodeConnections, TContext, TGetAudioNodeConnectionsFunction } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getAudioNodeConnections: TGetAudioNodeConnectionsFunction = <T extends TContext>(\n    audioNode: IAudioNode<T>\n): TAudioNodeConnections<T> => {\n    return <TAudioNodeConnections<T>>getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);\n};\n","import { AUDIO_PARAM_CONNECTIONS_STORE } from '../globals';\nimport { IAudioParam } from '../interfaces';\nimport { TAudioParamConnections, TContext, TGetAudioParamConnectionsFunction } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getAudioParamConnections: TGetAudioParamConnectionsFunction = <T extends TContext>(\n    audioParam: IAudioParam\n): TAudioParamConnections<T> => {\n    return <TAudioParamConnections<T>>getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);\n};\n","import { isAudioBufferSourceNode } from '../guards/audio-buffer-source-node';\nimport { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { isBiquadFilterNode } from '../guards/biquad-filter-node';\nimport { isConstantSourceNode } from '../guards/constant-source-node';\nimport { isGainNode } from '../guards/gain-node';\nimport { isOscillatorNode } from '../guards/oscillator-node';\nimport { isStereoPannerNode } from '../guards/stereo-panner-node';\nimport { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { getAudioNodeConnections } from './get-audio-node-connections';\nimport { getAudioParamConnections } from './get-audio-param-connections';\nimport { isActiveAudioNode } from './is-active-audio-node';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\n\nexport const deactivateActiveAudioNodeInputConnections = <T extends TContext>(\n    audioNode: IAudioNode<T>,\n    trace: readonly IAudioNode<T>[]\n) => {\n    const { activeInputs } = getAudioNodeConnections(audioNode);\n\n    activeInputs.forEach((connections) =>\n        connections.forEach(([source]) => {\n            if (!trace.includes(audioNode)) {\n                deactivateActiveAudioNodeInputConnections(source, [...trace, audioNode]);\n            }\n        })\n    );\n\n    const audioParams = isAudioBufferSourceNode(audioNode)\n        ? [\n              // Bug #149: Safari does not yet support the detune AudioParam.\n              audioNode.playbackRate\n          ]\n        : isAudioWorkletNode(audioNode)\n        ? Array.from(audioNode.parameters.values())\n        : isBiquadFilterNode(audioNode)\n        ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain]\n        : isConstantSourceNode(audioNode)\n        ? [audioNode.offset]\n        : isGainNode(audioNode)\n        ? [audioNode.gain]\n        : isOscillatorNode(audioNode)\n        ? [audioNode.detune, audioNode.frequency]\n        : isStereoPannerNode(audioNode)\n        ? [audioNode.pan]\n        : [];\n\n    for (const audioParam of audioParams) {\n        const audioParamConnections = getAudioParamConnections<T>(audioParam);\n\n        if (audioParamConnections !== undefined) {\n            audioParamConnections.activeInputs.forEach(([source]) => deactivateActiveAudioNodeInputConnections(source, trace));\n        }\n    }\n\n    if (isActiveAudioNode(audioNode)) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n","import { IAudioBufferSourceNode, IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isAudioBufferSourceNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IAudioBufferSourceNode<T> => {\n    return 'playbackRate' in audioNode;\n};\n","import { IAudioNode, IBiquadFilterNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isBiquadFilterNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IBiquadFilterNode<T> => {\n    return 'frequency' in audioNode && 'gain' in audioNode;\n};\n","import { IAudioNode, IConstantSourceNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isConstantSourceNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IConstantSourceNode<T> => {\n    return 'offset' in audioNode;\n};\n","import { IAudioNode, IGainNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isGainNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IGainNode<T> => {\n    return !('frequency' in audioNode) && 'gain' in audioNode;\n};\n","import { IAudioNode, IOscillatorNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isOscillatorNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IOscillatorNode<T> => {\n    return 'detune' in audioNode && 'frequency' in audioNode;\n};\n","import { IAudioNode, IStereoPannerNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isStereoPannerNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IStereoPannerNode<T> => {\n    return 'pan' in audioNode;\n};\n","import { IAudioDestinationNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { deactivateActiveAudioNodeInputConnections } from './deactivate-active-audio-node-input-connections';\n\nexport const deactivateAudioGraph = <T extends TContext>(context: T): void => {\n    deactivateActiveAudioNodeInputConnections(<IAudioDestinationNode<T>>context.destination, []);\n};\n","import { IAudioContextOptions } from '../interfaces';\n\nexport const isValidLatencyHint = (latencyHint: IAudioContextOptions['latencyHint']) => {\n    return (\n        latencyHint === undefined ||\n        typeof latencyHint === 'number' ||\n        (typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback'))\n    );\n};\n","import { IAudioNode, IAudioParam } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isAudioNode = <T extends TContext>(\n    audioNodeOrAudioParam: IAudioNode<T> | IAudioParam\n): audioNodeOrAudioParam is IAudioNode<T> => {\n    return 'context' in audioNodeOrAudioParam;\n};\n","import { TAudioNodeOutputConnection, TContext, TOutputConnection } from '../types';\nimport { isAudioNode } from './audio-node';\n\nexport const isAudioNodeOutputConnection = <T extends TContext>(\n    outputConnection: TOutputConnection<T>\n): outputConnection is TAudioNodeOutputConnection<T> => {\n    return isAudioNode(outputConnection[0]);\n};\n","import { TInsertElementInSetFunction } from '../types';\n\nexport const insertElementInSet: TInsertElementInSetFunction = (set, element, predicate, ignoreDuplicates) => {\n    for (const lmnt of set) {\n        if (predicate(lmnt)) {\n            if (ignoreDuplicates) {\n                return false;\n            }\n\n            throw Error('The set contains at least one similar element.');\n        }\n    }\n\n    set.add(element);\n\n    return true;\n};\n","import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext, TPassiveAudioParamInputConnection } from '../types';\nimport { insertElementInSet } from './insert-element-in-set';\n\nexport const addActiveInputConnectionToAudioParam = <T extends TContext>(\n    activeInputs: Set<TActiveInputConnection<T>>,\n    source: IAudioNode<T>,\n    [output, eventListener]: TPassiveAudioParamInputConnection,\n    ignoreDuplicates: boolean\n) => {\n    insertElementInSet(\n        activeInputs,\n        [source, output, eventListener],\n        (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output,\n        ignoreDuplicates\n    );\n};\n","import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext, TPassiveAudioParamInputConnection } from '../types';\nimport { insertElementInSet } from './insert-element-in-set';\n\nexport const addPassiveInputConnectionToAudioParam = <T extends TContext>(\n    passiveInputs: WeakMap<IAudioNode<T>, Set<TPassiveAudioParamInputConnection>>,\n    [source, output, eventListener]: TActiveInputConnection<T>,\n    ignoreDuplicates: boolean\n) => {\n    const passiveInputConnections = passiveInputs.get(source);\n\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, eventListener]]));\n    } else {\n        insertElementInSet(\n            passiveInputConnections,\n            [output, eventListener],\n            (passiveInputConnection) => passiveInputConnection[0] === output,\n            ignoreDuplicates\n        );\n    }\n};\n","import { INativeAudioNodeFaker } from '../interfaces';\nimport { TNativeAudioNode } from '../types';\n\nexport const isNativeAudioNodeFaker = (\n    nativeAudioNodeOrNativeAudioNodeFaker: TNativeAudioNode | INativeAudioNodeFaker\n): nativeAudioNodeOrNativeAudioNodeFaker is INativeAudioNodeFaker => {\n    return 'inputs' in nativeAudioNodeOrNativeAudioNodeFaker;\n};\n","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { INativeAudioNodeFaker } from '../interfaces';\nimport { TConnectNativeAudioNodeToNativeAudioNodeFunction, TNativeAudioNode } from '../types';\n\nexport const connectNativeAudioNodeToNativeAudioNode: TConnectNativeAudioNodeToNativeAudioNodeFunction = (\n    nativeSourceAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n    nativeDestinationAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n    output: number,\n    input: number\n): [TNativeAudioNode, number, number] => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];\n\n        nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);\n\n        return [fakeNativeDestinationAudioNode, output, 0];\n    }\n\n    nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n\n    return [nativeDestinationAudioNode, output, input];\n};\n","import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext } from '../types';\n\nexport const deleteActiveInputConnection = <T extends TContext>(\n    activeInputConnections: Set<TActiveInputConnection<T>>,\n    source: IAudioNode<T>,\n    output: number\n): null | TActiveInputConnection<T> => {\n    for (const activeInputConnection of activeInputConnections) {\n        if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n            activeInputConnections.delete(activeInputConnection);\n\n            return activeInputConnection;\n        }\n    }\n\n    return null;\n};\n","import { IAudioNode } from '../interfaces';\nimport { TContext, TInternalStateEventListener } from '../types';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\n\nexport const deleteEventListenerOfAudioNode = <T extends TContext>(\n    audioNode: IAudioNode<T>,\n    eventListener: TInternalStateEventListener\n) => {\n    const eventListeners = getEventListenersOfAudioNode(audioNode);\n\n    if (!eventListeners.delete(eventListener)) {\n        throw new Error('Missing the expected event listener.');\n    }\n};\n","import { IAudioNode } from '../interfaces';\nimport { TContext, TPassiveAudioParamInputConnection } from '../types';\nimport { getValueForKey } from './get-value-for-key';\nimport { pickElementFromSet } from './pick-element-from-set';\n\nexport const deletePassiveInputConnectionToAudioParam = <T extends TContext>(\n    passiveInputs: WeakMap<IAudioNode<T>, Set<TPassiveAudioParamInputConnection>>,\n    source: IAudioNode<T>,\n    output: number\n) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(\n        passiveInputConnections,\n        (passiveInputConnection) => passiveInputConnection[0] === output\n    );\n\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n\n    return matchingConnection;\n};\n","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { TDisconnectNativeAudioNodeFromNativeAudioNodeFunction } from '../types';\n\nexport const disconnectNativeAudioNodeFromNativeAudioNode: TDisconnectNativeAudioNodeFromNativeAudioNodeFunction = (\n    nativeSourceAudioNode,\n    nativeDestinationAudioNode,\n    output,\n    input\n) => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);\n    } else {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n    }\n};\n","import { AUDIO_NODE_STORE } from '../globals';\nimport { IAudioNode, INativeAudioNodeFaker } from '../interfaces';\nimport { TContext, TGetNativeAudioNodeFunction, TNativeAudioNode } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getNativeAudioNode: TGetNativeAudioNodeFunction = <T extends TContext, U extends TNativeAudioNode | INativeAudioNodeFaker>(\n    audioNode: IAudioNode<T>\n): U => {\n    return <U>getValueForKey(AUDIO_NODE_STORE, audioNode);\n};\n","import { AUDIO_PARAM_STORE } from '../globals';\nimport { IAudioParam } from '../interfaces';\nimport { TNativeAudioParam } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getNativeAudioParam = (audioParam: IAudioParam): TNativeAudioParam => {\n    return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n};\n","import { CYCLE_COUNTERS } from '../globals';\nimport { TIsPartOfACycleFunction } from '../types';\n\nexport const isPartOfACycle: TIsPartOfACycleFunction = (audioNode) => {\n    return CYCLE_COUNTERS.has(audioNode);\n};\n","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { TIsPassiveAudioNodeFunction } from '../types';\n\nexport const isPassiveAudioNode: TIsPassiveAudioNodeFunction = (audioNode) => {\n    return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};\n","import { TNativeAudioContext, TNativeAudioWorkletNodeConstructor } from '../types';\n\nexport const testAudioNodeDisconnectMethodSupport = (\n    nativeAudioContext: TNativeAudioContext,\n    nativeAudioWorkletNodeConstructor: null | TNativeAudioWorkletNodeConstructor\n): Promise<boolean> => {\n    return new Promise((resolve) => {\n        /*\n         * This bug existed in Safari up until v14.0.2. Since AudioWorklets were not supported in Safari until v14.1 the presence of the\n         * constructor for an AudioWorkletNode can be used here to skip the test.\n         */\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            resolve(true);\n        } else {\n            const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1); // tslint:disable-line deprecation\n            const dummy = nativeAudioContext.createGain();\n            // Bug #95: Safari does not play one sample buffers.\n            const ones = nativeAudioContext.createBuffer(1, 2, 44100);\n            const channelData = ones.getChannelData(0);\n\n            channelData[0] = 1;\n            channelData[1] = 1;\n\n            const source = nativeAudioContext.createBufferSource();\n\n            source.buffer = ones;\n            source.loop = true;\n\n            source.connect(analyzer).connect(nativeAudioContext.destination);\n            source.connect(dummy);\n            source.disconnect(dummy);\n\n            // tslint:disable-next-line:deprecation\n            analyzer.onaudioprocess = (event) => {\n                const chnnlDt = event.inputBuffer.getChannelData(0); // tslint:disable-line deprecation\n\n                if (Array.prototype.some.call(chnnlDt, (sample: number) => sample === 1)) {\n                    resolve(true);\n                } else {\n                    resolve(false);\n                }\n\n                source.stop();\n\n                analyzer.onaudioprocess = null; // tslint:disable-line:deprecation\n\n                source.disconnect(analyzer);\n                analyzer.disconnect(nativeAudioContext.destination);\n            };\n\n            source.start();\n        }\n    });\n};\n","import { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const visitEachAudioNodeOnce = <T extends TContext>(\n    cycles: IAudioNode<T>[][],\n    visitor: (audioNode: IAudioNode<T>, count: number) => void\n): void => {\n    const counts = new Map<IAudioNode<T>, number>();\n\n    for (const cycle of cycles) {\n        for (const audioNode of cycle) {\n            const count = counts.get(audioNode);\n\n            counts.set(audioNode, count === undefined ? 1 : count + 1);\n        }\n    }\n\n    counts.forEach((count, audioNode) => visitor(audioNode, count));\n};\n","import { TNativeAudioNode, TNativeAudioParam } from '../types';\n\nexport const isNativeAudioNode = (\n    nativeAudioNodeOrAudioParam: TNativeAudioNode | TNativeAudioParam\n): nativeAudioNodeOrAudioParam is TNativeAudioNode => {\n    return 'context' in nativeAudioNodeOrAudioParam;\n};\n","import { isNativeAudioNode } from '../guards/native-audio-node';\nimport { TNativeAudioNode, TNativeAudioParam } from '../types';\n\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode: TNativeAudioNode): void => {\n    const connections = new Map<TNativeAudioNode | TNativeAudioParam, { input: number; output: number }[]>();\n\n    nativeAudioNode.connect = <TNativeAudioNode['connect']>((connect) => {\n        // tslint:disable-next-line:invalid-void no-inferrable-types\n        return (destination: TNativeAudioNode | TNativeAudioParam, output = 0, input: number = 0): void | TNativeAudioNode => {\n            const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output);\n\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            } else {\n                if (connectionsToDestination.every((connection) => connection.input !== input || connection.output !== output)) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput?: number | TNativeAudioNode | TNativeAudioParam, output?: number, input?: number): void => {\n            disconnect.apply(nativeAudioNode);\n\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            } else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);\n\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    } else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            } else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                } else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination.filter(\n                            (connection) => connection.output !== output && (connection.input !== input || input === undefined)\n                        );\n\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        } else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination.forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    } else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n","import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nimport {\n    IAudioNode,\n    IAudioNodeRenderer,\n    IAudioParam,\n    IMinimalOfflineAudioContext,\n    INativeAudioNodeFaker,\n    IOfflineAudioContext\n} from '../interfaces';\nimport {\n    TAudioNodeConstructorFactory,\n    TChannelCountMode,\n    TChannelInterpretation,\n    TContext,\n    TInternalStateEventListener,\n    TNativeAudioNode,\n    TNativeAudioParam\n} from '../types';\n\nconst addConnectionToAudioParamOfAudioContext = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number,\n    isOffline: boolean\n): boolean => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n\n    const eventListener: TInternalStateEventListener = (isActive) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.connect(nativeAudioParam, output);\n            }\n        } else {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.disconnect(nativeAudioParam, output);\n            }\n        }\n    };\n\n    if (\n        insertElementInSet(\n            outputs,\n            [destination, output],\n            (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output,\n            true\n        )\n    ) {\n        eventListeners.add(eventListener);\n\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        } else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n\n        return true;\n    }\n\n    return false;\n};\n\nconst deleteInputConnectionOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n\n        return [passiveInputConnection[2], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputConnectionOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n        return [passiveInputConnection[1], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputsOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\n\nconst deleteInputsOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioParam,\n    output: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\n\nconst deleteAnyConnection = <T extends TContext>(source: IAudioNode<T>, isOffline: boolean): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n        } else {\n            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n        }\n\n        destinations.push(outputConnection[0]);\n    }\n\n    audioNodeConnectionsOfSource.outputs.clear();\n\n    return destinations;\n};\n\nconst deleteConnectionAtOutput = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    output: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n\n    return destinations;\n};\n\nconst deleteConnectionToDestination = <T extends TContext, U extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<U> | IAudioParam,\n    output?: number,\n    input?: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n\n    return Array.from(audioNodeConnectionsOfSource.outputs)\n        .filter(\n            (outputConnection) =>\n                outputConnection[0] === destination &&\n                (output === undefined || outputConnection[1] === output) &&\n                (input === undefined || outputConnection[2] === input)\n        )\n        .map((outputConnection) => {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n\n            return outputConnection[0];\n        });\n};\n\nexport const createAudioNodeConstructor: TAudioNodeConstructorFactory = (\n    addAudioNodeConnections,\n    addConnectionToAudioNode,\n    cacheTestResult,\n    createIncrementCycleCounter,\n    createIndexSizeError,\n    createInvalidAccessError,\n    createNotSupportedError,\n    decrementCycleCounter,\n    detectCycles,\n    eventTargetConstructor,\n    getNativeContext,\n    isNativeAudioContext,\n    isNativeAudioNode,\n    isNativeAudioParam,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor\n) => {\n    return class AudioNode<T extends TContext, EventMap extends Record<string, Event> = {}>\n        extends eventTargetConstructor<EventMap>\n        implements IAudioNode<T, EventMap>\n    {\n        private _context: T;\n\n        private _nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode;\n\n        constructor(\n            context: T,\n            isActive: boolean,\n            nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n            audioNodeRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioNodeRenderer<T, IAudioNode<T>> : null\n        ) {\n            super(nativeAudioNode);\n\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n\n            const nativeContext = getNativeContext(context);\n\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            if (\n                isNativeAudioContext(nativeContext) &&\n                true !==\n                    cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);\n                    })\n            ) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n\n            if (context.state !== 'closed' && isActive) {\n                setInternalStateToActive(this);\n            }\n\n            addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n        }\n\n        get channelCount(): number {\n            return this._nativeAudioNode.channelCount;\n        }\n\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeAudioNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n\n        get channelInterpretation(): TChannelInterpretation {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n\n        get context(): T {\n            return this._context;\n        }\n\n        get numberOfInputs(): number {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n\n        get numberOfOutputs(): number {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n\n        public connect<U extends TContext, V extends IAudioNode<U>>(destinationNode: V, output?: number, input?: number): V;\n        public connect(destinationParam: IAudioParam, output?: number): void;\n        // tslint:disable-next-line:invalid-void\n        public connect<U extends TContext, V extends IAudioNode<U>>(destination: V | IAudioParam, output = 0, input = 0): void | V {\n            // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n            if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(\n                        this._nativeAudioNode,\n                        nativeDestinationAudioNode,\n                        output,\n                        input\n                    );\n\n                    const isPassive = isPassiveAudioNode(this);\n\n                    if (isOffline || isPassive) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n\n                    if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n                        setInternalStateToActive(destination);\n                    }\n                } catch (err) {\n                    // Bug #41: Safari does not throw the correct exception so far.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n\n                    throw err;\n                }\n\n                const isNewConnectionToAudioNode = addConnectionToAudioNode(\n                    this,\n                    <IAudioNode<TContext>>destination,\n                    output,\n                    input,\n                    isOffline\n                );\n\n                // Bug #164: Only Firefox detects cycles so far.\n                if (isNewConnectionToAudioNode) {\n                    const cycles = detectCycles([this], <IAudioNode<T>>(<unknown>destination));\n\n                    visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n                }\n\n                return destination;\n            }\n\n            const nativeAudioParam = getNativeAudioParam(destination);\n\n            /*\n             * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n             */\n            if ((<TNativeAudioParam & { name: string }>nativeAudioParam).name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n                throw createNotSupportedError();\n            }\n\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            } catch (err) {\n                // Bug #58: Safari doesn't throw an InvalidAccessError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n\n                throw err;\n            }\n\n            const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n            }\n        }\n\n        public disconnect(output?: number): void;\n        public disconnect<U extends TContext>(destinationNode: IAudioNode<U>, output?: number, input?: number): void;\n        public disconnect(destinationParam: IAudioParam, output?: number): void;\n        public disconnect<U extends TContext>(\n            destinationOrOutput?: number | IAudioNode<U> | IAudioParam,\n            output?: number,\n            input?: number\n        ): void {\n            let destinations: (IAudioNode<T> | IAudioParam)[];\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (destinationOrOutput === undefined) {\n                destinations = deleteAnyConnection(this, isOffline);\n            } else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n            } else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n\n                if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n\n                if (destinations.length === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n\n            // Bug #164: Only Firefox detects cycles so far.\n            for (const destination of destinations) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n            }\n        }\n    };\n};\n","import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext } from '../types';\nimport { pickElementFromSet } from './pick-element-from-set';\n\nexport const deleteActiveInputConnectionToAudioParam = <T extends TContext>(\n    activeInputs: Set<TActiveInputConnection<T>>,\n    source: IAudioNode<T>,\n    output: number\n) => {\n    return pickElementFromSet(\n        activeInputs,\n        (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output\n    );\n};\n","import { IReadOnlyMap } from './interfaces';\n\nexport class ReadOnlyMap<T, U> implements IReadOnlyMap<T, U> {\n    private _map: Map<T, U>;\n\n    constructor(parameters: [T, U][]) {\n        this._map = new Map(parameters);\n    }\n\n    get size(): number {\n        return this._map.size;\n    }\n\n    public entries(): IterableIterator<[T, U]> {\n        return this._map.entries();\n    }\n\n    public forEach(callback: (audioParam: U, name: T, map: ReadOnlyMap<T, U>) => void, thisArg: any = null): void {\n        return this._map.forEach((value: U, key: T) => callback.call(thisArg, value, key, this));\n    }\n\n    public get(name: T): undefined | U {\n        return this._map.get(name);\n    }\n\n    public has(name: T): boolean {\n        return this._map.has(name);\n    }\n\n    public keys(): IterableIterator<T> {\n        return this._map.keys();\n    }\n\n    public values(): IterableIterator<U> {\n        return this._map.values();\n    }\n}\n","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport {\n    IAudioParam,\n    IAudioWorkletNode,\n    IAudioWorkletNodeEventMap,\n    IAudioWorkletNodeOptions,\n    IMinimalAudioContext,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IReadOnlyMap\n} from '../interfaces';\nimport { ReadOnlyMap } from '../read-only-map';\nimport {\n    TAudioNodeRenderer,\n    TAudioParamMap,\n    TAudioWorkletNodeConstructorFactory,\n    TContext,\n    TErrorEventHandler,\n    TNativeAudioContext,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    parameterData: {},\n    processorOptions: {}\n} as const;\n\nexport const createAudioWorkletNodeConstructor: TAudioWorkletNodeConstructorFactory = (\n    addUnrenderedAudioWorkletNode,\n    audioNodeConstructor,\n    createAudioParam,\n    createAudioWorkletNodeRenderer,\n    createNativeAudioWorkletNode,\n    getAudioNodeConnections,\n    getBackupOfflineAudioContext,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor,\n    sanitizeAudioWorkletNodeOptions,\n    setActiveAudioWorkletNodeInputs,\n    testAudioWorkletNodeOptionsClonability,\n    wrapEventListener\n) => {\n    return class AudioWorkletNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioWorkletNodeEventMap>\n        implements IAudioWorkletNode<T>\n    {\n        private _nativeAudioWorkletNode: TNativeAudioWorkletNode;\n\n        private _onprocessorerror: null | TErrorEventHandler<this>;\n\n        private _parameters: null | TAudioParamMap;\n\n        constructor(context: T, name: string, options?: Partial<IAudioWorkletNodeOptions>) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizeAudioWorkletNodeOptions({ ...DEFAULT_OPTIONS, ...options });\n\n            // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n            testAudioWorkletNodeOptionsClonability(mergedOptions);\n\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = nodeNameToProcessorConstructorMap?.get(name);\n            // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n            const nativeContextOrBackupOfflineAudioContext =\n                isOffline || nativeContext.state !== 'closed'\n                    ? nativeContext\n                    : getBackupOfflineAudioContext(<TNativeAudioContext>nativeContext) ?? nativeContext;\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(\n                nativeContextOrBackupOfflineAudioContext,\n                isOffline ? null : (<IMinimalAudioContext>(<any>context)).baseLatency,\n                nativeAudioWorkletNodeConstructor,\n                name,\n                processorConstructor,\n                mergedOptions\n            );\n            const audioWorkletNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null)\n            );\n\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n\n            const parameters: [string, IAudioParam][] = [];\n\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n\n                parameters.push([nm, audioParam]);\n            });\n\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n             * the destination.\n             */\n            if (isOffline) {\n                addUnrenderedAudioWorkletNode(nativeContext, <IAudioWorkletNode<IMinimalOfflineAudioContext | IOfflineAudioContext>>this);\n            }\n\n            const { activeInputs } = getAudioNodeConnections(this);\n\n            setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n        }\n\n        get onprocessorerror(): null | TErrorEventHandler<this> {\n            return this._onprocessorerror;\n        }\n\n        set onprocessorerror(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, <EventListenerOrEventListenerObject>value) : null;\n\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n\n            this._onprocessorerror =\n                nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener\n                    ? value\n                    : <null | TErrorEventHandler<this>>nativeOnProcessorError;\n        }\n\n        get parameters(): TAudioParamMap {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return <IReadOnlyMap<string, TNativeAudioParam>>this._nativeAudioWorkletNode.parameters;\n            }\n\n            return this._parameters;\n        }\n\n        get port(): MessagePort {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n","import { TNativeAudioBuffer } from '../types';\n\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    parent: { [key: number]: Float32Array },\n    key: number,\n    channelNumber: number,\n    bufferOffset: number\n): void;\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    parent: { [key: string]: Float32Array },\n    key: string,\n    channelNumber: number,\n    bufferOffset: number\n): void;\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    // @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\n    parent: any,\n    key: number | string,\n    channelNumber: number,\n    bufferOffset: number\n): void {\n    if (typeof audioBuffer.copyFromChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = new Float32Array(128);\n        }\n\n        audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n\n        // Bug #5: Safari does not support copyFromChannel().\n    } else {\n        const channelData = audioBuffer.getChannelData(channelNumber);\n\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n        } else {\n            const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n\n            parent[key].set(slicedInput);\n        }\n    }\n}\n","import { TNativeAudioBuffer } from '../types';\n\nexport const copyToChannel = (\n    audioBuffer: TNativeAudioBuffer,\n    parent: { [key: number]: Float32Array },\n    key: number,\n    channelNumber: number,\n    bufferOffset: number\n): void => {\n    if (typeof audioBuffer.copyToChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n        }\n\n        // Bug #5: Safari does not support copyToChannel().\n    } else {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);\n        }\n    }\n};\n","export const createNestedArrays = (x: number, y: number | number[]): Float32Array[][] => {\n    const arrays: Float32Array[][] = [];\n\n    for (let i = 0; i < x; i += 1) {\n        const array = [];\n\n        const length = typeof y === 'number' ? y : y[i];\n\n        for (let j = 0; j < length; j += 1) {\n            array.push(new Float32Array(128));\n        }\n\n        arrays.push(array);\n    }\n\n    return arrays;\n};\n","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { IAudioNode, IAudioWorkletProcessor } from '../interfaces';\nimport { TContext, TNativeAudioWorkletNode, TNativeOfflineAudioContext } from '../types';\nimport { getNativeAudioNode } from './get-native-audio-node';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getAudioWorkletProcessor = <T extends TContext>(\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    proxy: IAudioNode<T>\n): Promise<IAudioWorkletProcessor> => {\n    const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n    const nativeAudioWorkletNode = getNativeAudioNode<T, TNativeAudioWorkletNode>(proxy);\n\n    return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n};\n","import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport {\n    IAudioWorkletNode,\n    IAudioWorkletNodeOptions,\n    IAudioWorkletProcessorConstructor,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IReadOnlyMap\n} from '../interfaces';\nimport {\n    TAudioWorkletNodeRendererFactoryFactory,\n    TExposeCurrentFrameAndCurrentTimeFunction,\n    TNativeAudioBuffer,\n    TNativeAudioNode,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode,\n    TNativeChannelMergerNode,\n    TNativeChannelSplitterNode,\n    TNativeGainNode,\n    TNativeOfflineAudioContext\n} from '../types';\n\nconst processBuffer = async <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n    proxy: IAudioWorkletNode<T>,\n    renderedBuffer: null | TNativeAudioBuffer,\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    options: IAudioWorkletNodeOptions,\n    outputChannelCount: number[],\n    processorConstructor: undefined | IAudioWorkletProcessorConstructor,\n    exposeCurrentFrameAndCurrentTime: TExposeCurrentFrameAndCurrentTimeFunction\n): Promise<null | TNativeAudioBuffer> => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer =\n        numberOfOutputChannels === 0\n            ? null\n            : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters: { [name: string]: Float32Array } = Array.from(proxy.parameters.keys()).reduce(\n        (prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }),\n        {}\n    );\n\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n\n        try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(\n                i / nativeOfflineAudioContext.sampleRate,\n                nativeOfflineAudioContext.sampleRate,\n                () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters)\n            );\n\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[j];\n                }\n            }\n\n            if (!activeSourceFlag) {\n                break;\n            }\n        } catch (error) {\n            proxy.dispatchEvent(\n                new ErrorEvent('processorerror', {\n                    colno: error.colno,\n                    filename: error.filename,\n                    lineno: error.lineno,\n                    message: error.message\n                })\n            );\n\n            break;\n        }\n    }\n\n    return processedBuffer;\n};\n\nexport const createAudioWorkletNodeRendererFactory: TAudioWorkletNodeRendererFactoryFactory = (\n    connectAudioParam,\n    connectMultipleOutputs,\n    createNativeAudioBufferSourceNode,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    deleteUnrenderedAudioWorkletNode,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getNativeAudioNode,\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        name: string,\n        options: IAudioWorkletNodeOptions,\n        processorConstructor: undefined | IAudioWorkletProcessorConstructor\n    ) => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioWorkletNode | TNativeGainNode>();\n\n        let processedBufferPromise: null | Promise<null | TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IAudioWorkletNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioWorkletNode = getNativeAudioNode<T, TNativeAudioWorkletNode>(proxy);\n            let nativeOutputNodes: null | [TNativeChannelSplitterNode, TNativeChannelMergerNode[], TNativeGainNode] = null;\n\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            const outputChannelCount = Array.isArray(options.outputChannelCount)\n                ? options.outputChannelCount\n                : Array.from(options.outputChannelCount);\n\n            // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes: TNativeChannelMergerNode[] = [];\n\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(\n                        createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: outputChannelCount[i]\n                        })\n                    );\n                }\n\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n\n                outputGainNode.connect = <TNativeAudioNode['connect']>connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = <TNativeAudioNode['disconnect']>disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n\n            renderedNativeAudioNodes.set(\n                nativeOfflineAudioContext,\n                nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]\n            );\n\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters =\n                        processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                            numberOfChannels,\n                            // Ceil the length to the next full render quantum.\n                            // Bug #17: Safari does not yet expose the length.\n                            Math.ceil(proxy.context.length / 128) * 128,\n                            nativeOfflineAudioContext.sampleRate\n                        );\n                        const gainNodes: TNativeGainNode[] = [];\n                        const inputChannelSplitterNodes = [];\n\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(\n                                createNativeGainNode(partialOfflineAudioContext, {\n                                    channelCount: options.channelCount,\n                                    channelCountMode: options.channelCountMode,\n                                    channelInterpretation: options.channelInterpretation,\n                                    gain: 1\n                                })\n                            );\n                            inputChannelSplitterNodes.push(\n                                createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                    channelCount: options.channelCount,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    numberOfOutputs: options.channelCount\n                                })\n                            );\n                        }\n\n                        const constantSourceNodes = await Promise.all(\n                            Array.from(proxy.parameters.values()).map(async (audioParam) => {\n                                const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                    channelCount: 1,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    offset: audioParam.value\n                                });\n\n                                await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n\n                                return constantSourceNode;\n                            })\n                        );\n\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                            }\n                        }\n\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n\n                        await Promise.all(\n                            gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode))\n                        );\n\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n\n                    processedBufferPromise = processBuffer(\n                        proxy,\n                        numberOfChannels === 0 ? null : await renderBuffer(),\n                        nativeOfflineAudioContext,\n                        options,\n                        outputChannelCount,\n                        processorConstructor,\n                        exposeCurrentFrameAndCurrentTime\n                    );\n                }\n\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n\n                return outputGainNode;\n            }\n\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(\n                        nativeOfflineAudioContext,\n                        audioParam,\n                        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                        <TNativeAudioParam>(<IReadOnlyMap<string, TNativeAudioParam>>nativeAudioWorkletNode.parameters).get(nm)\n                    );\n                }\n            } else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(\n                        nativeOfflineAudioContext,\n                        audioParam,\n                        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                        <TNativeAudioParam>(<IReadOnlyMap<string, TNativeAudioParam>>nativeAudioWorkletNode.parameters).get(nm)\n                    );\n                }\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n\n            return nativeAudioWorkletNode;\n        };\n\n        return {\n            render(\n                proxy: IAudioWorkletNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioWorkletNode | TNativeGainNode> {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam, IBiquadFilterNode, IBiquadFilterOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TBiquadFilterNodeConstructorFactory, TBiquadFilterType, TContext, TNativeBiquadFilterNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    Q: 1,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 350,\n    gain: 0,\n    type: 'lowpass'\n} as const;\n\nexport const createBiquadFilterNodeConstructor: TBiquadFilterNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createBiquadFilterNodeRenderer,\n    createInvalidAccessError,\n    createNativeBiquadFilterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class BiquadFilterNode<T extends TContext> extends audioNodeConstructor<T> implements IBiquadFilterNode<T> {\n        private _detune: IAudioParam;\n\n        private _frequency: IAudioParam;\n\n        private _gain: IAudioParam;\n\n        private _nativeBiquadFilterNode: TNativeBiquadFilterNode;\n\n        private _Q: IAudioParam;\n\n        constructor(context: T, options?: Partial<IBiquadFilterOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const biquadFilterNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createBiquadFilterNodeRenderer() : null);\n\n            super(context, false, nativeBiquadFilterNode, biquadFilterNodeRenderer);\n\n            // Bug #80: Safari does not export the correct values for maxValue and minValue.\n            this._Q = createAudioParam(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #78: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(\n                this,\n                isOffline,\n                nativeBiquadFilterNode.detune,\n                1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT),\n                -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT)\n            );\n            // Bug #77: Firefox & Safari do not export the correct value for minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeBiquadFilterNode.frequency, context.sampleRate / 2, 0);\n            // Bug #79: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(\n                this,\n                isOffline,\n                nativeBiquadFilterNode.gain,\n                40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT),\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._nativeBiquadFilterNode = nativeBiquadFilterNode;\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        get detune(): IAudioParam {\n            return this._detune;\n        }\n\n        get frequency(): IAudioParam {\n            return this._frequency;\n        }\n\n        get gain(): IAudioParam {\n            return this._gain;\n        }\n\n        get Q(): IAudioParam {\n            return this._Q;\n        }\n\n        get type(): TBiquadFilterType {\n            return this._nativeBiquadFilterNode.type;\n        }\n\n        set type(value) {\n            this._nativeBiquadFilterNode.type = value;\n        }\n\n        public getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void {\n            // Bug #189: Safari does throw an InvalidStateError.\n            try {\n                this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n            } catch (err) {\n                if (err.code === 11) {\n                    throw createInvalidAccessError();\n                }\n\n                throw err;\n            }\n\n            // Bug #68: Safari does not throw an error if the parameters differ in their length.\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                throw createInvalidAccessError();\n            }\n        }\n    };\n};\n","import { IChannelMergerOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TChannelMergerNodeConstructorFactory, TContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 1,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 6\n} as const;\n\nexport const createChannelMergerNodeConstructor: TChannelMergerNodeConstructorFactory = (\n    audioNodeConstructor,\n    createChannelMergerNodeRenderer,\n    createNativeChannelMergerNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class ChannelMergerNode<T extends TContext> extends audioNodeConstructor<T> {\n        constructor(context: T, options?: Partial<IChannelMergerOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeChannelMergerNode = createNativeChannelMergerNode(nativeContext, mergedOptions);\n            const channelMergerNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isNativeOfflineAudioContext(nativeContext) ? createChannelMergerNodeRenderer() : null)\n            );\n\n            super(context, false, nativeChannelMergerNode, channelMergerNodeRenderer);\n        }\n    };\n};\n","import { IChannelSplitterOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TChannelSplitterNodeConstructorFactory, TContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 6,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'discrete',\n    numberOfOutputs: 6\n} as const;\n\nexport const createChannelSplitterNodeConstructor: TChannelSplitterNodeConstructorFactory = (\n    audioNodeConstructor,\n    createChannelSplitterNodeRenderer,\n    createNativeChannelSplitterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    sanitizeChannelSplitterOptions\n) => {\n    return class ChannelSplitterNode<T extends TContext> extends audioNodeConstructor<T> {\n        constructor(context: T, options?: Partial<IChannelSplitterOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizeChannelSplitterOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nativeChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, mergedOptions);\n            const channelSplitterNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isNativeOfflineAudioContext(nativeContext) ? createChannelSplitterNodeRenderer() : null)\n            );\n\n            super(context, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);\n        }\n    };\n};\n","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport { IAudioParam, IAudioScheduledSourceNodeEventMap, IConstantSourceNode, IConstantSourceOptions } from '../interfaces';\nimport {\n    TConstantSourceNodeConstructorFactory,\n    TConstantSourceNodeRenderer,\n    TContext,\n    TEventHandler,\n    TNativeConstantSourceNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    offset: 1\n} as const;\n\nexport const createConstantSourceNodeConstructor: TConstantSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createConstantSourceNodeRendererFactory,\n    createNativeConstantSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n) => {\n    return class ConstantSourceNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioScheduledSourceNodeEventMap>\n        implements IConstantSourceNode<T>\n    {\n        private _constantSourceNodeRenderer: TConstantSourceNodeRenderer<T>;\n\n        private _nativeConstantSourceNode: TNativeConstantSourceNode;\n\n        private _offset: IAudioParam;\n\n        private _onended: null | TEventHandler<this>;\n\n        constructor(context: T, options?: Partial<IConstantSourceOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConstantSourceNode = createNativeConstantSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const constantSourceNodeRenderer = <TConstantSourceNodeRenderer<T>>(\n                (isOffline ? createConstantSourceNodeRendererFactory() : null)\n            );\n\n            super(context, false, nativeConstantSourceNode, constantSourceNodeRenderer);\n\n            this._constantSourceNodeRenderer = constantSourceNodeRenderer;\n            this._nativeConstantSourceNode = nativeConstantSourceNode;\n            /*\n             * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and minValue\n             * for GainNodes.\n             */\n            this._offset = createAudioParam(\n                this,\n                isOffline,\n                nativeConstantSourceNode.offset,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._onended = null;\n        }\n\n        get offset(): IAudioParam {\n            return this._offset;\n        }\n\n        get onended(): null | TEventHandler<this> {\n            return this._onended;\n        }\n\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeConstantSourceNode.onended = wrappedListener;\n\n            const nativeOnEnded = this._nativeConstantSourceNode.onended;\n\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n\n        public start(when = 0): void {\n            this._nativeConstantSourceNode.start(when);\n\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.start = when;\n            }\n\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n\n                const resetInternalStateToPassive = () => {\n                    this._nativeConstantSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n\n                this._nativeConstantSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n\n        public stop(when = 0): void {\n            this._nativeConstantSourceNode.stop(when);\n\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n","import { IConvolverNode, IConvolverOptions } from '../interfaces';\nimport { TAnyAudioBuffer, TAudioNodeRenderer, TContext, TConvolverNodeConstructorFactory, TNativeConvolverNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    disableNormalization: false\n} as const;\n\nexport const createConvolverNodeConstructor: TConvolverNodeConstructorFactory = (\n    audioNodeConstructor,\n    createConvolverNodeRenderer,\n    createNativeConvolverNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class ConvolverNode<T extends TContext> extends audioNodeConstructor<T> implements IConvolverNode<T> {\n        private _isBufferNullified: boolean;\n\n        private _nativeConvolverNode: TNativeConvolverNode;\n\n        constructor(context: T, options?: Partial<IConvolverOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const convolverNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createConvolverNodeRenderer() : null);\n\n            super(context, false, nativeConvolverNode, convolverNodeRenderer);\n\n            this._isBufferNullified = false;\n            this._nativeConvolverNode = nativeConvolverNode;\n\n            if (mergedOptions.buffer !== null) {\n                setAudioNodeTailTime(this, mergedOptions.buffer.duration);\n            }\n        }\n\n        get buffer(): null | TAnyAudioBuffer {\n            if (this._isBufferNullified) {\n                return null;\n            }\n\n            return this._nativeConvolverNode.buffer;\n        }\n\n        set buffer(value) {\n            this._nativeConvolverNode.buffer = value;\n\n            // Bug #115: Safari does not allow to set the buffer to null.\n            if (value === null && this._nativeConvolverNode.buffer !== null) {\n                const nativeContext = this._nativeConvolverNode.context;\n\n                this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, 44100);\n                this._isBufferNullified = true;\n\n                setAudioNodeTailTime(this, 0);\n            } else {\n                this._isBufferNullified = false;\n\n                setAudioNodeTailTime(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);\n            }\n        }\n\n        get normalize(): boolean {\n            return this._nativeConvolverNode.normalize;\n        }\n\n        set normalize(value) {\n            this._nativeConvolverNode.normalize = value;\n        }\n    };\n};\n","export const detachArrayBuffer = (arrayBuffer: ArrayBuffer): Promise<void> => {\n    const { port1, port2 } = new MessageChannel();\n\n    return new Promise((resolve) => {\n        const closeAndResolve = () => {\n            port2.onmessage = null;\n\n            port1.close();\n            port2.close();\n\n            resolve();\n        };\n\n        port2.onmessage = () => closeAndResolve();\n\n        try {\n            port1.postMessage(arrayBuffer, [arrayBuffer]);\n        } finally {\n            closeAndResolve();\n        }\n    });\n};\n","import { IAudioParam, IDelayNode, IDelayOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TDelayNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    delayTime: 0,\n    maxDelayTime: 1\n} as const;\n\nexport const createDelayNodeConstructor: TDelayNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createDelayNodeRenderer,\n    createNativeDelayNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class DelayNode<T extends TContext> extends audioNodeConstructor<T> implements IDelayNode<T> {\n        private _delayTime: IAudioParam;\n\n        constructor(context: T, options?: Partial<IDelayOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDelayNode = createNativeDelayNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const delayNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createDelayNodeRenderer(mergedOptions.maxDelayTime) : null);\n\n            super(context, false, nativeDelayNode, delayNodeRenderer);\n\n            this._delayTime = createAudioParam(this, isOffline, nativeDelayNode.delayTime);\n\n            setAudioNodeTailTime(this, mergedOptions.maxDelayTime);\n        }\n\n        get delayTime(): IAudioParam {\n            return this._delayTime;\n        }\n    };\n};\n","import { isNativeAudioNode } from '../guards/native-audio-node';\nimport { TDisconnectMultipleOutputsFactory, TIndexSizeErrorFactory, TNativeAudioNode } from '../types';\n\nconst getOutputAudioNodeAtIndex = (\n    createIndexSizeError: TIndexSizeErrorFactory,\n    outputAudioNodes: TNativeAudioNode[],\n    output: number\n): TNativeAudioNode => {\n    const outputAudioNode = outputAudioNodes[output];\n\n    if (outputAudioNode === undefined) {\n        throw createIndexSizeError();\n    }\n\n    return outputAudioNode;\n};\n\nexport const createDisconnectMultipleOutputs: TDisconnectMultipleOutputsFactory = (createIndexSizeError) => {\n    return (outputAudioNodes, destinationOrOutput = undefined, output = undefined, input = 0) => {\n        if (destinationOrOutput === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect());\n        }\n\n        if (typeof destinationOrOutput === 'number') {\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput).disconnect();\n        }\n\n        if (isNativeAudioNode(destinationOrOutput)) {\n            if (output === undefined) {\n                return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n            }\n\n            if (input === undefined) {\n                return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n            }\n\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input);\n        }\n\n        if (output === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n        }\n\n        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n    };\n};\n","import { IAudioParam, IDynamicsCompressorNode, IDynamicsCompressorOptions } from '../interfaces';\nimport {\n    TAudioNodeRenderer,\n    TChannelCountMode,\n    TContext,\n    TDynamicsCompressorNodeConstructorFactory,\n    TNativeAudioParam,\n    TNativeDynamicsCompressorNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    attack: 0.003,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    knee: 30,\n    ratio: 12,\n    release: 0.25,\n    threshold: -24\n} as const;\n\nexport const createDynamicsCompressorNodeConstructor: TDynamicsCompressorNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createDynamicsCompressorNodeRenderer,\n    createNativeDynamicsCompressorNode,\n    createNotSupportedError,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class DynamicsCompressorNode<T extends TContext> extends audioNodeConstructor<T> implements IDynamicsCompressorNode<T> {\n        private _attack: IAudioParam;\n\n        private _knee: IAudioParam;\n\n        private _nativeDynamicsCompressorNode: TNativeDynamicsCompressorNode;\n\n        private _ratio: IAudioParam;\n\n        private _release: IAudioParam;\n\n        private _threshold: IAudioParam;\n\n        constructor(context: T, options?: Partial<IDynamicsCompressorOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const dynamicsCompressorNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createDynamicsCompressorNodeRenderer() : null);\n\n            super(context, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);\n\n            this._attack = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.attack);\n            this._knee = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.knee);\n            this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;\n            this._ratio = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.ratio);\n            this._release = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.release);\n            this._threshold = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.threshold);\n\n            setAudioNodeTailTime(this, 0.006);\n        }\n\n        get attack(): IAudioParam {\n            return this._attack;\n        }\n\n        // Bug #108: Safari allows a channelCount of three and above which is why the getter and setter needs to be overwritten here.\n        get channelCount(): number {\n            return this._nativeDynamicsCompressorNode.channelCount;\n        }\n\n        set channelCount(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;\n\n            this._nativeDynamicsCompressorNode.channelCount = value;\n\n            if (value > 2) {\n                this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;\n\n                throw createNotSupportedError();\n            }\n        }\n\n        /*\n         * Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be\n         * overwritten here.\n         */\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeDynamicsCompressorNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;\n\n            this._nativeDynamicsCompressorNode.channelCountMode = value;\n\n            if (value === 'max') {\n                this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;\n\n                throw createNotSupportedError();\n            }\n        }\n\n        get knee(): IAudioParam {\n            return this._knee;\n        }\n\n        get ratio(): IAudioParam {\n            return this._ratio;\n        }\n\n        get reduction(): number {\n            // Bug #111: Safari returns an AudioParam instead of a number.\n            if (typeof (<TNativeAudioParam>(<any>this._nativeDynamicsCompressorNode.reduction)).value === 'number') {\n                return (<TNativeAudioParam>(<any>this._nativeDynamicsCompressorNode.reduction)).value;\n            }\n\n            return this._nativeDynamicsCompressorNode.reduction;\n        }\n\n        get release(): IAudioParam {\n            return this._release;\n        }\n\n        get threshold(): IAudioParam {\n            return this._threshold;\n        }\n    };\n};\n","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam, IGainNode, IGainOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TGainNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    gain: 1\n} as const;\n\nexport const createGainNodeConstructor: TGainNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createGainNodeRenderer,\n    createNativeGainNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class GainNode<T extends TContext> extends audioNodeConstructor<T> implements IGainNode<T> {\n        private _gain: IAudioParam;\n\n        constructor(context: T, options?: Partial<IGainOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const gainNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createGainNodeRenderer() : null);\n\n            super(context, false, nativeGainNode, gainNodeRenderer);\n\n            // Bug #74: Safari does not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n\n        get gain(): IAudioParam {\n            return this._gain;\n        }\n    };\n};\n","import { TInvalidStateErrorFactory } from '../types';\n\nexport const createInvalidStateError: TInvalidStateErrorFactory = () => new DOMException('', 'InvalidStateError');\n","import { TInvalidAccessErrorFactory } from '../types';\n\nexport const createInvalidAccessError: TInvalidAccessErrorFactory = () => new DOMException('', 'InvalidAccessError');\n","import { wrapIIRFilterNodeGetFrequencyResponseMethod } from '../helpers/wrap-iir-filter-node-get-frequency-response-method';\nimport { IIIRFilterNode, IIIRFilterOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TIIRFilterNodeConstructorFactory, TNativeIIRFilterNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers'\n} as const;\n\nexport const createIIRFilterNodeConstructor: TIIRFilterNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeIIRFilterNode,\n    createIIRFilterNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class IIRFilterNode<T extends TContext> extends audioNodeConstructor<T> implements IIIRFilterNode<T> {\n        private _nativeIIRFilterNode: TNativeIIRFilterNode;\n\n        constructor(\n            context: T,\n            options: { feedback: IIIRFilterOptions['feedback']; feedforward: IIIRFilterOptions['feedforward'] } & Partial<IIIRFilterOptions>\n        ) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeIIRFilterNode = createNativeIIRFilterNode(\n                nativeContext,\n                isOffline ? null : (<IMinimalAudioContext>(<any>context)).baseLatency,\n                mergedOptions\n            );\n            const iirFilterNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward) : null)\n            );\n\n            super(context, false, nativeIIRFilterNode, iirFilterNodeRenderer);\n\n            // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.\n            // @todo Write a test which allows other browsers to remain unpatched.\n            wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);\n\n            this._nativeIIRFilterNode = nativeIIRFilterNode;\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        public getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void {\n            return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n        }\n    };\n};\n","// This implementation as shamelessly inspired by source code of\n// tslint:disable-next-line:max-line-length\n// {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.\nexport const filterBuffer = (\n    feedback: Float64Array,\n    feedbackLength: number,\n    feedforward: Float64Array,\n    feedforwardLength: number,\n    minLength: number,\n    xBuffer: Float32Array,\n    yBuffer: Float32Array,\n    bufferIndex: number,\n    bufferLength: number,\n    input: Float32Array,\n    output: Float32Array\n) => {\n    const inputLength = input.length;\n\n    let i = bufferIndex;\n\n    for (let j = 0; j < inputLength; j += 1) {\n        let y = feedforward[0] * input[j];\n\n        for (let k = 1; k < minLength; k += 1) {\n            const x = (i - k) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n\n            y += feedforward[k] * xBuffer[x];\n            y -= feedback[k] * yBuffer[x];\n        }\n\n        for (let k = minLength; k < feedforwardLength; k += 1) {\n            y += feedforward[k] * xBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n\n        for (let k = minLength; k < feedbackLength; k += 1) {\n            y -= feedback[k] * yBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n\n        xBuffer[i] = input[j];\n        yBuffer[i] = y;\n\n        i = (i + 1) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n\n        output[j] = y;\n    }\n\n    return i;\n};\n","import { filterBuffer } from '../helpers/filter-buffer';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IIIRFilterNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport {\n    TIIRFilterNodeRendererFactoryFactory,\n    TNativeAudioBuffer,\n    TNativeAudioBufferSourceNode,\n    TNativeIIRFilterNode,\n    TNativeOfflineAudioContext\n} from '../types';\n\nconst filterFullBuffer = (\n    renderedBuffer: TNativeAudioBuffer,\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    feedback: Iterable<number>,\n    feedforward: Iterable<number>\n) => {\n    const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n    const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n    const feedbackLength = convertedFeedback.length;\n    const feedforwardLength = convertedFeedforward.length;\n    const minLength = Math.min(feedbackLength, feedforwardLength);\n\n    if (convertedFeedback[0] !== 1) {\n        for (let i = 0; i < feedbackLength; i += 1) {\n            convertedFeedforward[i] /= convertedFeedback[0];\n        }\n\n        for (let i = 1; i < feedforwardLength; i += 1) {\n            convertedFeedback[i] /= convertedFeedback[0];\n        }\n    }\n\n    const bufferLength = 32;\n    const xBuffer = new Float32Array(bufferLength);\n    const yBuffer = new Float32Array(bufferLength);\n\n    const filteredBuffer = nativeOfflineAudioContext.createBuffer(\n        renderedBuffer.numberOfChannels,\n        renderedBuffer.length,\n        renderedBuffer.sampleRate\n    );\n\n    const numberOfChannels = renderedBuffer.numberOfChannels;\n\n    for (let i = 0; i < numberOfChannels; i += 1) {\n        const input = renderedBuffer.getChannelData(i);\n        const output = filteredBuffer.getChannelData(i);\n\n        xBuffer.fill(0);\n        yBuffer.fill(0);\n\n        filterBuffer(\n            convertedFeedback,\n            feedbackLength,\n            convertedFeedforward,\n            feedforwardLength,\n            minLength,\n            xBuffer,\n            yBuffer,\n            0,\n            bufferLength,\n            input,\n            output\n        );\n    }\n\n    return filteredBuffer;\n};\n\nexport const createIIRFilterNodeRendererFactory: TIIRFilterNodeRendererFactoryFactory = (\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(feedback: Iterable<number>, feedforward: Iterable<number>) => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioBufferSourceNode | TNativeIIRFilterNode>();\n\n        let filteredBufferPromise: null | Promise<null | TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IIIRFilterNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioBufferSourceNode: null | TNativeAudioBufferSourceNode = null;\n            let nativeIIRFilterNode = getNativeAudioNode<T, TNativeIIRFilterNode>(proxy);\n\n            // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);\n\n            // Bug #9: Safari does not support IIRFilterNodes.\n            if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n            } else if (!nativeIIRFilterNodeIsOwnedByContext) {\n                // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n                nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(<number[]>feedforward, <number[]>feedback);\n            }\n\n            renderedNativeAudioNodes.set(\n                nativeOfflineAudioContext,\n                nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode\n            );\n\n            if (nativeAudioBufferSourceNode !== null) {\n                if (filteredBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                        // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                        proxy.context.destination.channelCount,\n                        // Bug #17: Safari does not yet expose the length.\n                        proxy.context.length,\n                        nativeOfflineAudioContext.sampleRate\n                    );\n\n                    filteredBufferPromise = (async () => {\n                        await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination);\n\n                        const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n\n                        return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n                    })();\n                }\n\n                const filteredBuffer = await filteredBufferPromise;\n\n                nativeAudioBufferSourceNode.buffer = filteredBuffer;\n                nativeAudioBufferSourceNode.start(0);\n\n                return nativeAudioBufferSourceNode;\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode);\n\n            return nativeIIRFilterNode;\n        };\n\n        return {\n            render(\n                proxy: IIIRFilterNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioBufferSourceNode | TNativeIIRFilterNode> {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { IAudioContext, IAudioNodeOptions, IMediaStreamAudioDestinationNode, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaStreamAudioDestinationNodeConstructorFactory, TNativeMediaStreamAudioDestinationNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers'\n} as const;\n\nexport const createMediaStreamAudioDestinationNodeConstructor: TMediaStreamAudioDestinationNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaStreamAudioDestinationNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class MediaStreamAudioDestinationNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaStreamAudioDestinationNode<T> {\n        private _nativeMediaStreamAudioDestinationNode: TNativeMediaStreamAudioDestinationNode;\n\n        constructor(context: T, options?: Partial<IAudioNodeOptions>) {\n            const nativeContext = getNativeContext(context);\n\n            // Bug #173: Safari allows to create a MediaStreamAudioDestinationNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode(nativeContext, mergedOptions);\n\n            super(context, false, nativeMediaStreamAudioDestinationNode, <TAudioNodeRenderer<T>>null);\n\n            this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;\n        }\n\n        get stream(): MediaStream {\n            return this._nativeMediaStreamAudioDestinationNode.stream;\n        }\n    };\n};\n","import { TNativeContext } from '../types';\n\nexport const testPromiseSupport = (nativeContext: TNativeContext): boolean => {\n    // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.\n    const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);\n\n    try {\n        // Bug #1: Safari requires a successCallback.\n        const promise = nativeContext.decodeAudioData(<ArrayBuffer>uint32Array.buffer, () => {\n            // Ignore the success callback.\n        });\n\n        if (promise === undefined) {\n            return false;\n        }\n\n        promise.catch(() => {\n            // Ignore rejected errors.\n        });\n\n        return true;\n    } catch {\n        // Ignore errors.\n    }\n\n    return false;\n};\n","import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IAudioBuffer, IMinimalOfflineAudioContext, IOfflineAudioContextOptions } from '../interfaces';\nimport { TAudioContextState, TMinimalOfflineAudioContextConstructorFactory, TNativeOfflineAudioContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createMinimalOfflineAudioContextConstructor: TMinimalOfflineAudioContextConstructorFactory = (\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    minimalBaseAudioContextConstructor,\n    startRendering\n) => {\n    return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor<IMinimalOfflineAudioContext>\n        implements IMinimalOfflineAudioContext {\n        private _length: number;\n\n        private _nativeOfflineAudioContext: TNativeOfflineAudioContext;\n\n        private _state: null | TAudioContextState;\n\n        constructor(options: IOfflineAudioContextOptions) {\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener(\n                    'statechange',\n                    (() => {\n                        let i = 0;\n\n                        const delayStateChangeEvent = (event: Event) => {\n                            if (this._state === 'running') {\n                                if (i > 0) {\n                                    nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                    event.stopImmediatePropagation();\n\n                                    this._waitForThePromiseToSettle(event);\n                                } else {\n                                    i += 1;\n                                }\n                            }\n                        };\n\n                        return delayStateChangeEvent;\n                    })()\n                );\n            }\n\n            super(nativeOfflineAudioContext, numberOfChannels);\n\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n\n        get length(): number {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n\n            return this._nativeOfflineAudioContext.length;\n        }\n\n        get state(): TAudioContextState {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n\n        public startRendering(): Promise<IAudioBuffer> {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n\n            this._state = 'running';\n\n            return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n                this._state = null;\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        private _waitForThePromiseToSettle(event: Event): void {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            } else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n","export const assignNativeAudioNodeOption = <T extends keyof any, U extends any>(\n    nativeAudioNode: Record<T, U>,\n    options: Record<T, U>,\n    option: T\n) => {\n    const value = options[option];\n\n    if (value !== undefined && value !== nativeAudioNode[option]) {\n        nativeAudioNode[option] = value;\n    }\n};\n","import { IAudioNodeOptions } from '../interfaces';\nimport { TNativeAudioNode } from '../types';\nimport { assignNativeAudioNodeOption } from './assign-native-audio-node-option';\n\nexport const assignNativeAudioNodeOptions = (nativeAudioNode: TNativeAudioNode, options: IAudioNodeOptions): void => {\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');\n};\n","import { TNativeAnalyserNode } from '../types';\n\nexport const testAnalyserNodeGetFloatTimeDomainDataMethodSupport = (nativeAnalyserNode: TNativeAnalyserNode): boolean => {\n    return typeof nativeAnalyserNode.getFloatTimeDomainData === 'function';\n};\n","export const assignNativeAudioNodeAudioParamValue = <T extends { [key: string]: any }, U extends { [key: string]: any }>(\n    nativeAudioNode: T,\n    options: U,\n    audioParam: keyof T & keyof U\n) => {\n    const value = options[audioParam];\n\n    if (value !== undefined && value !== nativeAudioNode[audioParam].value) {\n        nativeAudioNode[audioParam].value = value;\n    }\n};\n","import { TNativeAudioBufferSourceNode, TNativeConstantSourceNode, TNativeOscillatorNode } from '../types';\n\nexport const wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (\n    nativeAudioScheduledSourceNode: TNativeAudioBufferSourceNode | TNativeConstantSourceNode | TNativeOscillatorNode\n): void => {\n    nativeAudioScheduledSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration?: number) => {\n            if ((typeof duration === 'number' && duration < 0) || offset < 0 || when < 0) {\n                throw new RangeError(\"The parameters can't be negative.\");\n            }\n\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            (<(when: number, offset: number, duration?: number) => void>start).call(nativeAudioScheduledSourceNode, when, offset, duration);\n        };\n    })(nativeAudioScheduledSourceNode.start);\n};\n","import { TNativeAudioBufferSourceNode, TNativeConstantSourceNode, TNativeOscillatorNode } from '../types';\n\nexport const wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (\n    nativeAudioScheduledSourceNode: TNativeAudioBufferSourceNode | TNativeConstantSourceNode | TNativeOscillatorNode\n): void => {\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            if (when < 0) {\n                throw new RangeError(\"The parameter can't be negative.\");\n            }\n\n            stop.call(nativeAudioScheduledSourceNode, when);\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n","export const computeBufferSize = (baseLatency: null | number, sampleRate: number) => {\n    if (baseLatency === null) {\n        return 512;\n    }\n\n    return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n};\n","import { IAudioWorkletNodeOptions } from '../interfaces';\n\nexport const cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions: IAudioWorkletNodeOptions): Promise<IAudioWorkletNodeOptions> => {\n    return new Promise((resolve, reject) => {\n        const { port1, port2 } = new MessageChannel();\n\n        port1.onmessage = ({ data }) => {\n            port1.close();\n            port2.close();\n\n            resolve(data);\n        };\n        port1.onmessageerror = ({ data }) => {\n            port1.close();\n            port2.close();\n\n            reject(data);\n        };\n\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port2.postMessage(audioWorkletNodeOptions);\n    });\n};\n","import { IAudioWorkletNodeOptions, IAudioWorkletProcessor, IAudioWorkletProcessorConstructor } from '../interfaces';\nimport { cloneAudioWorkletNodeOptions } from './clone-audio-worklet-node-options';\n\nexport const createAudioWorkletProcessorPromise = async (\n    processorConstructor: IAudioWorkletProcessorConstructor,\n    audioWorkletNodeOptions: IAudioWorkletNodeOptions\n): Promise<IAudioWorkletProcessor> => {\n    const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n\n    return new processorConstructor(clonedAudioWorkletNodeOptions);\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeBiquadFilterNodeFactory } from '../types';\n\nexport const createNativeBiquadFilterNode: TNativeBiquadFilterNodeFactory = (nativeContext, options) => {\n    const nativeBiquadFilterNode = nativeContext.createBiquadFilter();\n\n    assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);\n\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'Q');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'detune');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'frequency');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'gain');\n\n    assignNativeAudioNodeOption(nativeBiquadFilterNode, options, 'type');\n\n    return nativeBiquadFilterNode;\n};\n","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapChannelSplitterNode } from '../helpers/wrap-channel-splitter-node';\nimport { TNativeChannelSplitterNodeFactory } from '../types';\n\nexport const createNativeChannelSplitterNode: TNativeChannelSplitterNodeFactory = (nativeContext, options) => {\n    const nativeChannelSplitterNode = nativeContext.createChannelSplitter(options.numberOfOutputs);\n\n    // Bug #96: Safari does not have the correct channelCount.\n    // Bug #29: Safari does not have the correct channelCountMode.\n    // Bug #31: Safari does not have the correct channelInterpretation.\n    assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);\n\n    // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Edge & Firefox partially support the spec yet.\n    wrapChannelSplitterNode(nativeChannelSplitterNode);\n\n    return nativeChannelSplitterNode;\n};\n","import { createInvalidStateError } from '../factories/invalid-state-error';\nimport { TNativeChannelSplitterNode } from '../types';\n\nexport const wrapChannelSplitterNode = (channelSplitterNode: TNativeChannelSplitterNode): void => {\n    const channelCount = channelSplitterNode.numberOfOutputs;\n\n    // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.\n    Object.defineProperty(channelSplitterNode, 'channelCount', {\n        get: () => channelCount,\n        set: (value) => {\n            if (value !== channelCount) {\n                throw createInvalidStateError();\n            }\n        }\n    });\n\n    // Bug #30: Safari does not throw an error when attempting to change the channelCountMode to something other than explicit.\n    Object.defineProperty(channelSplitterNode, 'channelCountMode', {\n        get: () => 'explicit',\n        set: (value) => {\n            if (value !== 'explicit') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n\n    // Bug #32: Safari does not throw an error when attempting to change the channelInterpretation to something other than discrete.\n    Object.defineProperty(channelSplitterNode, 'channelInterpretation', {\n        get: () => 'discrete',\n        set: (value) => {\n            if (value !== 'discrete') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n};\n","import { TNativeAudioNode } from '../types';\n\nexport const interceptConnections = <T extends object>(\n    original: T,\n    interceptor: TNativeAudioNode\n): T & { connect: TNativeAudioNode['connect']; disconnect: TNativeAudioNode['disconnect'] } => {\n    (<T & { connect: TNativeAudioNode['connect'] }>original).connect = interceptor.connect.bind(interceptor);\n\n    (<T & { disconnect: TNativeAudioNode['disconnect'] }>original).disconnect = interceptor.disconnect.bind(interceptor);\n\n    return <T & { connect: TNativeAudioNode['connect']; disconnect: TNativeAudioNode['disconnect'] }>original;\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeDelayNodeFactory } from '../types';\n\nexport const createNativeDelayNode: TNativeDelayNodeFactory = (nativeContext, options) => {\n    const nativeDelayNode = nativeContext.createDelay(options.maxDelayTime);\n\n    assignNativeAudioNodeOptions(nativeDelayNode, options);\n\n    assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, 'delayTime');\n\n    return nativeDelayNode;\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeGainNodeFactory } from '../types';\n\nexport const createNativeGainNode: TNativeGainNodeFactory = (nativeContext, options) => {\n    const nativeGainNode = nativeContext.createGain();\n\n    assignNativeAudioNodeOptions(nativeGainNode, options);\n\n    assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');\n\n    return nativeGainNode;\n};\n","import { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { filterBuffer } from '../helpers/filter-buffer';\nimport { interceptConnections } from '../helpers/intercept-connections';\nimport { TNativeAudioNode, TNativeIIRFilterNode, TNativeIIRFilterNodeFakerFactoryFactory } from '../types';\n\nfunction divide(a: [number, number], b: [number, number]): [number, number] {\n    const denominator = b[0] * b[0] + b[1] * b[1];\n\n    return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];\n}\n\nfunction multiply(a: [number, number], b: [number, number]): [number, number] {\n    return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];\n}\n\nfunction evaluatePolynomial(coefficient: Float64Array, z: [number, number]): [number, number] {\n    let result: [number, number] = [0, 0];\n\n    for (let i = coefficient.length - 1; i >= 0; i -= 1) {\n        result = multiply(result, z);\n\n        result[0] += coefficient[i];\n    }\n\n    return result;\n}\n\nexport const createNativeIIRFilterNodeFakerFactory: TNativeIIRFilterNodeFakerFactoryFactory = (\n    createInvalidAccessError,\n    createInvalidStateError,\n    createNativeScriptProcessorNode,\n    createNotSupportedError\n) => {\n    return (nativeContext, baseLatency, { channelCount, channelCountMode, channelInterpretation, feedback, feedforward }) => {\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n        const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n        const feedbackLength = convertedFeedback.length;\n        const feedforwardLength = convertedFeedforward.length;\n        const minLength = Math.min(feedbackLength, feedforwardLength);\n\n        if (feedbackLength === 0 || feedbackLength > 20) {\n            throw createNotSupportedError();\n        }\n\n        if (convertedFeedback[0] === 0) {\n            throw createInvalidStateError();\n        }\n\n        if (feedforwardLength === 0 || feedforwardLength > 20) {\n            throw createNotSupportedError();\n        }\n\n        if (convertedFeedforward[0] === 0) {\n            throw createInvalidStateError();\n        }\n\n        if (convertedFeedback[0] !== 1) {\n            for (let i = 0; i < feedforwardLength; i += 1) {\n                convertedFeedforward[i] /= convertedFeedback[0];\n            }\n\n            for (let i = 1; i < feedbackLength; i += 1) {\n                convertedFeedback[i] /= convertedFeedback[0];\n            }\n        }\n\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);\n\n        scriptProcessorNode.channelCount = channelCount;\n        scriptProcessorNode.channelCountMode = channelCountMode;\n        scriptProcessorNode.channelInterpretation = channelInterpretation;\n\n        const bufferLength = 32;\n        const bufferIndexes: number[] = [];\n        const xBuffers: Float32Array[] = [];\n        const yBuffers: Float32Array[] = [];\n\n        for (let i = 0; i < channelCount; i += 1) {\n            bufferIndexes.push(0);\n\n            const xBuffer = new Float32Array(bufferLength);\n            const yBuffer = new Float32Array(bufferLength);\n\n            xBuffer.fill(0);\n            yBuffer.fill(0);\n\n            xBuffers.push(xBuffer);\n            yBuffers.push(yBuffer);\n        }\n\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = (event: AudioProcessingEvent) => {\n            const inputBuffer = event.inputBuffer;\n            const outputBuffer = event.outputBuffer;\n\n            const numberOfChannels = inputBuffer.numberOfChannels;\n\n            for (let i = 0; i < numberOfChannels; i += 1) {\n                const input = inputBuffer.getChannelData(i);\n                const output = outputBuffer.getChannelData(i);\n\n                bufferIndexes[i] = filterBuffer(\n                    convertedFeedback,\n                    feedbackLength,\n                    convertedFeedforward,\n                    feedforwardLength,\n                    minLength,\n                    xBuffers[i],\n                    yBuffers[i],\n                    bufferIndexes[i],\n                    bufferLength,\n                    input,\n                    output\n                );\n            }\n        };\n\n        const nyquist = nativeContext.sampleRate / 2;\n\n        const nativeIIRFilterNodeFaker = {\n            get bufferSize(): number {\n                return bufferSize;\n            },\n            get channelCount(): number {\n                return scriptProcessorNode.channelCount;\n            },\n            set channelCount(value) {\n                scriptProcessorNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeIIRFilterNode['channelCountMode'] {\n                return scriptProcessorNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                scriptProcessorNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeIIRFilterNode['channelInterpretation'] {\n                return scriptProcessorNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                scriptProcessorNode.channelInterpretation = value;\n            },\n            get context(): TNativeIIRFilterNode['context'] {\n                return scriptProcessorNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [scriptProcessorNode];\n            },\n            get numberOfInputs(): number {\n                return scriptProcessorNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return scriptProcessorNode.numberOfOutputs;\n            },\n            addEventListener(...args: any[]): void {\n                // @todo Dissallow adding an audioprocess listener.\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void {\n                if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                    throw createInvalidAccessError();\n                }\n\n                const length = frequencyHz.length;\n\n                for (let i = 0; i < length; i += 1) {\n                    const omega = -Math.PI * (frequencyHz[i] / nyquist);\n                    const z: [number, number] = [Math.cos(omega), Math.sin(omega)];\n                    const numerator = evaluatePolynomial(convertedFeedforward, z);\n                    const denominator = evaluatePolynomial(convertedFeedback, z);\n                    const response = divide(numerator, denominator);\n\n                    magResponse[i] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);\n                    phaseResponse[i] = Math.atan2(response[1], response[0]);\n                }\n            },\n            removeEventListener(...args: any[]): void {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);\n    };\n};\n","import { TCacheTestResultFactory } from '../types';\n\nexport const createCacheTestResult: TCacheTestResultFactory = (ongoingTests, testResults) => {\n    return (tester, test) => {\n        const cachedTestResult = testResults.get(tester);\n\n        if (cachedTestResult !== undefined) {\n            return cachedTestResult;\n        }\n\n        const ongoingTest = ongoingTests.get(tester);\n\n        if (ongoingTest !== undefined) {\n            return ongoingTest;\n        }\n\n        try {\n            const synchronousTestResult = test();\n\n            if (synchronousTestResult instanceof Promise) {\n                ongoingTests.set(tester, synchronousTestResult);\n\n                return synchronousTestResult\n                    .catch(() => false)\n                    .then((finalTestResult) => {\n                        ongoingTests.delete(tester);\n                        testResults.set(tester, finalTestResult);\n\n                        return finalTestResult;\n                    });\n            }\n\n            testResults.set(tester, synchronousTestResult);\n\n            return synchronousTestResult;\n        } catch {\n            testResults.set(tester, false);\n\n            return false;\n        }\n    };\n};\n","import { IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TContext, TGetNativeContextFactory, TNativeAudioContext, TNativeOfflineAudioContext } from '../types';\nimport { createInvalidStateError } from './invalid-state-error';\n\nexport const createGetNativeContext: TGetNativeContextFactory = (contextStore) => {\n    return <T extends TContext>(\n        context: T\n    ): T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? TNativeOfflineAudioContext : TNativeAudioContext => {\n        const nativeContext = contextStore.get(context);\n\n        if (nativeContext === undefined) {\n            throw createInvalidStateError();\n        }\n\n        return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? TNativeOfflineAudioContext : TNativeAudioContext>(\n            nativeContext\n        );\n    };\n};\n","import { IAudioNode, IAudioNodeRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TActiveInputConnection, TAddAudioNodeConnectionsFactory, TContext, TNativeAudioNode } from '../types';\n\nexport const createAddAudioNodeConnections: TAddAudioNodeConnectionsFactory = (audioNodeConnectionsStore) => {\n    return <T extends TContext>(\n        audioNode: IAudioNode<T>,\n        audioNodeRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioNodeRenderer<T, IAudioNode<T>> : null,\n        nativeAudioNode: TNativeAudioNode\n    ) => {\n        const activeInputs = [];\n\n        for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n            activeInputs.push(new Set<TActiveInputConnection<T>>());\n        }\n\n        audioNodeConnectionsStore.set(audioNode, {\n            activeInputs,\n            outputs: new Set(),\n            passiveInputs: new WeakMap(),\n            renderer: audioNodeRenderer\n        });\n    };\n};\n","import { TConvertNumberToUnsignedLongFactory } from '../types';\n\nexport const createConvertNumberToUnsignedLong: TConvertNumberToUnsignedLongFactory = (unit32Array) => {\n    return (value) => {\n        unit32Array[0] = value;\n\n        return unit32Array[0];\n    };\n};\n","import { IAudioParam, IAudioParamRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAddAudioParamConnectionsFactory, TContext } from '../types';\n\nexport const createAddAudioParamConnections: TAddAudioParamConnectionsFactory = (audioParamConnectionsStore) => {\n    return <T extends TContext>(\n        audioParam: IAudioParam,\n        audioParamRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioParamRenderer : null\n    ) => {\n        audioParamConnectionsStore.set(audioParam, { activeInputs: new Set(), passiveInputs: new WeakMap(), renderer: audioParamRenderer });\n    };\n};\n","import { TNativeScriptProcessorNodeFactory } from '../types';\n\nexport const createNativeScriptProcessorNode: TNativeScriptProcessorNodeFactory = (\n    nativeContext,\n    bufferSize,\n    numberOfInputChannels,\n    numberOfOutputChannels\n) => {\n    return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels); // tslint:disable-line deprecation\n};\n","import { TNotSupportedErrorFactory } from '../types';\n\nexport const createNotSupportedError: TNotSupportedErrorFactory = () => new DOMException('', 'NotSupportedError');\n","import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IAudioBuffer, IOfflineAudioContext, IOfflineAudioContextOptions } from '../interfaces';\nimport { TAudioContextState, TNativeOfflineAudioContext, TOfflineAudioContextConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createOfflineAudioContextConstructor: TOfflineAudioContextConstructorFactory = (\n    baseAudioContextConstructor,\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    startRendering\n) => {\n    return class OfflineAudioContext extends baseAudioContextConstructor<IOfflineAudioContext> implements IOfflineAudioContext {\n        private _length: number;\n\n        private _nativeOfflineAudioContext: TNativeOfflineAudioContext;\n\n        private _state: null | TAudioContextState;\n\n        constructor(options: IOfflineAudioContextOptions);\n        constructor(numberOfChannels: number, length: number, sampleRate: number);\n        constructor(a: number | IOfflineAudioContextOptions, b?: number, c?: number) {\n            let options: IOfflineAudioContextOptions;\n\n            if (typeof a === 'number' && b !== undefined && c !== undefined) {\n                options = { length: b, numberOfChannels: a, sampleRate: c };\n            } else if (typeof a === 'object') {\n                options = a;\n            } else {\n                throw new Error('The given parameters are not valid.');\n            }\n\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener(\n                    'statechange',\n                    (() => {\n                        let i = 0;\n\n                        const delayStateChangeEvent = (event: Event) => {\n                            if (this._state === 'running') {\n                                if (i > 0) {\n                                    nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                    event.stopImmediatePropagation();\n\n                                    this._waitForThePromiseToSettle(event);\n                                } else {\n                                    i += 1;\n                                }\n                            }\n                        };\n\n                        return delayStateChangeEvent;\n                    })()\n                );\n            }\n\n            super(nativeOfflineAudioContext, numberOfChannels);\n\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n\n        get length(): number {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n\n            return this._nativeOfflineAudioContext.length;\n        }\n\n        get state(): TAudioContextState {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n\n        public startRendering(): Promise<IAudioBuffer> {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n\n            this._state = 'running';\n\n            return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n                this._state = null;\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        private _waitForThePromiseToSettle(event: Event): void {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            } else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n","import { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport {\n    IAudioParam,\n    IAudioScheduledSourceNodeEventMap,\n    IMinimalOfflineAudioContext,\n    IOscillatorNode,\n    IOscillatorNodeRenderer,\n    IOscillatorOptions\n} from '../interfaces';\nimport {\n    TContext,\n    TEventHandler,\n    TNativeOscillatorNode,\n    TOscillatorNodeConstructorFactory,\n    TOscillatorNodeRenderer,\n    TOscillatorType\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max', // This attribute has no effect for nodes with no inputs.\n    channelInterpretation: 'speakers', // This attribute has no effect for nodes with no inputs.\n    detune: 0,\n    frequency: 440,\n    periodicWave: undefined,\n    type: 'sine'\n} as const;\n\nexport const createOscillatorNodeConstructor: TOscillatorNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeOscillatorNode,\n    createOscillatorNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n) => {\n    return class OscillatorNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioScheduledSourceNodeEventMap>\n        implements IOscillatorNode<T>\n    {\n        private _detune: IAudioParam;\n\n        private _frequency: IAudioParam;\n\n        private _nativeOscillatorNode: TNativeOscillatorNode;\n\n        private _onended: null | TEventHandler<this>;\n\n        private _oscillatorNodeRenderer: TOscillatorNodeRenderer<T>;\n\n        constructor(context: T, options?: Partial<IOscillatorOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOscillatorNode = createNativeOscillatorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const oscillatorNodeRenderer = <TOscillatorNodeRenderer<T>>(isOffline ? createOscillatorNodeRenderer() : null);\n            const nyquist = context.sampleRate / 2;\n\n            super(context, false, nativeOscillatorNode, oscillatorNodeRenderer);\n\n            // Bug #81: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeOscillatorNode.detune, 153600, -153600);\n            // Bug #76: Safari does not export the correct values for maxValue and minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);\n            this._nativeOscillatorNode = nativeOscillatorNode;\n            this._onended = null;\n            this._oscillatorNodeRenderer = oscillatorNodeRenderer;\n\n            if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== undefined) {\n                (<IOscillatorNodeRenderer<IMinimalOfflineAudioContext>>this._oscillatorNodeRenderer).periodicWave =\n                    mergedOptions.periodicWave;\n            }\n        }\n\n        get detune(): IAudioParam {\n            return this._detune;\n        }\n\n        get frequency(): IAudioParam {\n            return this._frequency;\n        }\n\n        get onended(): null | TEventHandler<this> {\n            return this._onended;\n        }\n\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeOscillatorNode.onended = wrappedListener;\n\n            const nativeOnEnded = this._nativeOscillatorNode.onended;\n\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n\n        get type(): TOscillatorType {\n            return this._nativeOscillatorNode.type;\n        }\n\n        set type(value) {\n            this._nativeOscillatorNode.type = value;\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = null;\n            }\n        }\n\n        public setPeriodicWave(periodicWave: PeriodicWave): void {\n            this._nativeOscillatorNode.setPeriodicWave(periodicWave);\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = periodicWave;\n            }\n        }\n\n        public start(when = 0): void {\n            this._nativeOscillatorNode.start(when);\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.start = when;\n            }\n\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n\n                const resetInternalStateToPassive = () => {\n                    this._nativeOscillatorNode.removeEventListener('ended', resetInternalStateToPassive);\n\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n\n                this._nativeOscillatorNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n\n        public stop(when = 0): void {\n            this._nativeOscillatorNode.stop(when);\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam, IPannerNode, IPannerOptions } from '../interfaces';\nimport {\n    TAudioNodeRenderer,\n    TContext,\n    TDistanceModelType,\n    TNativePannerNode,\n    TPannerNodeConstructorFactory,\n    TPanningModelType\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    coneInnerAngle: 360,\n    coneOuterAngle: 360,\n    coneOuterGain: 0,\n    distanceModel: 'inverse',\n    maxDistance: 10000,\n    orientationX: 1,\n    orientationY: 0,\n    orientationZ: 0,\n    panningModel: 'equalpower',\n    positionX: 0,\n    positionY: 0,\n    positionZ: 0,\n    refDistance: 1,\n    rolloffFactor: 1\n} as const;\n\nexport const createPannerNodeConstructor: TPannerNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createNativePannerNode,\n    createPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class PannerNode<T extends TContext> extends audioNodeConstructor<T> implements IPannerNode<T> {\n        private _nativePannerNode: TNativePannerNode;\n\n        private _orientationX: IAudioParam;\n\n        private _orientationY: IAudioParam;\n\n        private _orientationZ: IAudioParam;\n\n        private _positionX: IAudioParam;\n\n        private _positionY: IAudioParam;\n\n        private _positionZ: IAudioParam;\n\n        constructor(context: T, options?: Partial<IPannerOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativePannerNode = createNativePannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const pannerNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createPannerNodeRenderer() : null);\n\n            super(context, false, nativePannerNode, pannerNodeRenderer);\n\n            this._nativePannerNode = nativePannerNode;\n            // Bug #74: Safari does not export the correct values for maxValue and minValue.\n            this._orientationX = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.orientationX,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._orientationY = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.orientationY,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._orientationZ = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.orientationZ,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._positionX = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.positionX,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._positionY = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.positionY,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._positionZ = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.positionZ,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        get coneInnerAngle(): number {\n            return this._nativePannerNode.coneInnerAngle;\n        }\n\n        set coneInnerAngle(value) {\n            this._nativePannerNode.coneInnerAngle = value;\n        }\n\n        get coneOuterAngle(): number {\n            return this._nativePannerNode.coneOuterAngle;\n        }\n\n        set coneOuterAngle(value) {\n            this._nativePannerNode.coneOuterAngle = value;\n        }\n\n        get coneOuterGain(): number {\n            return this._nativePannerNode.coneOuterGain;\n        }\n\n        set coneOuterGain(value) {\n            this._nativePannerNode.coneOuterGain = value;\n        }\n\n        get distanceModel(): TDistanceModelType {\n            return this._nativePannerNode.distanceModel;\n        }\n\n        set distanceModel(value) {\n            this._nativePannerNode.distanceModel = value;\n        }\n\n        get maxDistance(): number {\n            return this._nativePannerNode.maxDistance;\n        }\n\n        set maxDistance(value) {\n            this._nativePannerNode.maxDistance = value;\n        }\n\n        get orientationX(): IAudioParam {\n            return this._orientationX;\n        }\n\n        get orientationY(): IAudioParam {\n            return this._orientationY;\n        }\n\n        get orientationZ(): IAudioParam {\n            return this._orientationZ;\n        }\n\n        get panningModel(): TPanningModelType {\n            return this._nativePannerNode.panningModel;\n        }\n\n        set panningModel(value) {\n            this._nativePannerNode.panningModel = value;\n        }\n\n        get positionX(): IAudioParam {\n            return this._positionX;\n        }\n\n        get positionY(): IAudioParam {\n            return this._positionY;\n        }\n\n        get positionZ(): IAudioParam {\n            return this._positionZ;\n        }\n\n        get refDistance(): number {\n            return this._nativePannerNode.refDistance;\n        }\n\n        set refDistance(value) {\n            this._nativePannerNode.refDistance = value;\n        }\n\n        get rolloffFactor(): number {\n            return this._nativePannerNode.rolloffFactor;\n        }\n\n        set rolloffFactor(value) {\n            this._nativePannerNode.rolloffFactor = value;\n        }\n    };\n};\n","import { IPeriodicWave, IPeriodicWaveOptions } from '../interfaces';\nimport { TContext, TPeriodicWaveConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    disableNormalization: false\n} as const;\n\nexport const createPeriodicWaveConstructor: TPeriodicWaveConstructorFactory = (\n    createNativePeriodicWave,\n    getNativeContext,\n    periodicWaveStore,\n    sanitizePeriodicWaveOptions\n) => {\n    return class PeriodicWave<T extends TContext> implements IPeriodicWave {\n        constructor(context: T, options?: Partial<IPeriodicWaveOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizePeriodicWaveOptions({ ...DEFAULT_OPTIONS, ...options });\n            const periodicWave = createNativePeriodicWave(nativeContext, mergedOptions);\n\n            periodicWaveStore.add(periodicWave);\n\n            // This does violate all good pratices but it is used here to simplify the handling of periodic waves.\n            return periodicWave;\n        }\n\n        public static [Symbol.hasInstance](instance: unknown): boolean {\n            return (\n                (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === PeriodicWave.prototype) ||\n                periodicWaveStore.has(<any>instance)\n            );\n        }\n    };\n};\n","import { IAudioParam, IStereoPannerNode, IStereoPannerOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TStereoPannerNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    /*\n     * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent\n     * behavior.\n     */\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    pan: 0\n} as const;\n\nexport const createStereoPannerNodeConstructor: TStereoPannerNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeStereoPannerNode,\n    createStereoPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class StereoPannerNode<T extends TContext> extends audioNodeConstructor<T> implements IStereoPannerNode<T> {\n        private _pan: IAudioParam;\n\n        constructor(context: T, options?: Partial<IStereoPannerOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeStereoPannerNode = createNativeStereoPannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const stereoPannerNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createStereoPannerNodeRenderer() : null);\n\n            super(context, false, nativeStereoPannerNode, stereoPannerNodeRenderer);\n\n            this._pan = createAudioParam(this, isOffline, nativeStereoPannerNode.pan);\n        }\n\n        get pan(): IAudioParam {\n            return this._pan;\n        }\n    };\n};\n","import { TUnknownErrorFactory } from '../types';\n\nexport const createUnknownError: TUnknownErrorFactory = () => new DOMException('', 'UnknownError');\n","import { IWaveShaperNode, IWaveShaperOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TNativeWaveShaperNode, TOverSampleType, TWaveShaperNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    curve: null,\n    oversample: 'none'\n} as const;\n\nexport const createWaveShaperNodeConstructor: TWaveShaperNodeConstructorFactory = (\n    audioNodeConstructor,\n    createInvalidStateError,\n    createNativeWaveShaperNode,\n    createWaveShaperNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class WaveShaperNode<T extends TContext> extends audioNodeConstructor<T> implements IWaveShaperNode<T> {\n        private _isCurveNullified: boolean;\n\n        private _nativeWaveShaperNode: TNativeWaveShaperNode;\n\n        constructor(context: T, options?: Partial<IWaveShaperOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const waveShaperNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createWaveShaperNodeRenderer() : null);\n\n            // @todo Add a mechanism to only switch a WaveShaperNode to active while it is connected.\n            super(context, true, nativeWaveShaperNode, waveShaperNodeRenderer);\n\n            this._isCurveNullified = false;\n            this._nativeWaveShaperNode = nativeWaveShaperNode;\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        get curve(): null | Float32Array {\n            if (this._isCurveNullified) {\n                return null;\n            }\n\n            return this._nativeWaveShaperNode.curve;\n        }\n\n        set curve(value) {\n            // Bug #103: Safari does not allow to set the curve to null.\n            if (value === null) {\n                this._isCurveNullified = true;\n                this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n            } else {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n                if (value.length < 2) {\n                    throw createInvalidStateError();\n                }\n\n                this._isCurveNullified = false;\n                this._nativeWaveShaperNode.curve = value;\n            }\n        }\n\n        get oversample(): TOverSampleType {\n            return this._nativeWaveShaperNode.oversample;\n        }\n\n        set oversample(value) {\n            this._nativeWaveShaperNode.oversample = value;\n        }\n    };\n};\n","import { TGetFirstSampleFunction } from '../types';\n\nexport const getFirstSample: TGetFirstSampleFunction = (audioBuffer, buffer, channelNumber) => {\n    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n    if (audioBuffer.copyFromChannel === undefined) {\n        return audioBuffer.getChannelData(channelNumber)[0];\n    }\n\n    audioBuffer.copyFromChannel(buffer, channelNumber);\n\n    return buffer[0];\n};\n","import { TIsDCCurveFunction } from '../types';\n\nexport const isDCCurve: TIsDCCurveFunction = (curve) => {\n    if (curve === null) {\n        return false;\n    }\n\n    const length = curve.length;\n\n    if (length % 2 !== 0) {\n        return curve[Math.floor(length / 2)] !== 0;\n    }\n\n    return curve[length / 2 - 1] + curve[length / 2] !== 0;\n};\n","import { TOverwriteAccessorsFunction } from '../types';\n\nexport const overwriteAccessors: TOverwriteAccessorsFunction = (object, property, createGetter, createSetter) => {\n    let prototype = object;\n\n    while (!prototype.hasOwnProperty(property)) {\n        prototype = Object.getPrototypeOf(prototype);\n    }\n\n    const { get, set } = <Required<PropertyDescriptor>>Object.getOwnPropertyDescriptor(prototype, property);\n\n    Object.defineProperty(object, property, { get: createGetter(get), set: createSetter(set) });\n};\n","import { TNativeContext } from '../types';\n\nexport const testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n\n    try {\n        nativeAudioBufferSourceNode.start(-1);\n    } catch (err) {\n        return err instanceof RangeError;\n    }\n\n    return false;\n};\n","import { TNativeContext } from '../types';\n\nexport const testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n    nativeAudioBufferSourceNode.start();\n    nativeAudioBufferSourceNode.stop();\n\n    try {\n        nativeAudioBufferSourceNode.stop();\n\n        return true;\n    } catch {\n        return false;\n    }\n};\n","import { TNativeContext } from '../types';\n\nexport const testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n\n    try {\n        nativeAudioBufferSourceNode.stop(-1);\n    } catch (err) {\n        return err instanceof RangeError;\n    }\n\n    return false;\n};\n","import { TNativeAudioNode, TWrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction } from '../types';\nimport { interceptConnections } from './intercept-connections';\n\nexport const wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls: TWrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction = (\n    nativeAudioScheduledSourceNode,\n    nativeContext\n) => {\n    const nativeGainNode = nativeContext.createGain();\n\n    nativeAudioScheduledSourceNode.connect(nativeGainNode);\n\n    const disconnectGainNode = ((disconnect) => {\n        return () => {\n            // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n            (<(destinaton: TNativeAudioNode) => void>disconnect).call(nativeAudioScheduledSourceNode, nativeGainNode);\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n        };\n    })(nativeAudioScheduledSourceNode.disconnect);\n\n    nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n\n    interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        let isStopped = false;\n\n        return (when = 0) => {\n            if (isStopped) {\n                try {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                } catch {\n                    nativeGainNode.gain.setValueAtTime(0, when);\n                }\n            } else {\n                stop.call(nativeAudioScheduledSourceNode, when);\n\n                isStopped = true;\n            }\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n","import { TWrapEventListenerFunction } from '../types';\n\nexport const wrapEventListener: TWrapEventListenerFunction = (target, eventListener) => {\n    return (event) => {\n        const descriptor = { value: target };\n\n        Object.defineProperties(event, {\n            currentTarget: descriptor,\n            target: descriptor\n        });\n\n        if (typeof eventListener === 'function') {\n            return eventListener.call(target, event);\n        }\n\n        return eventListener.handleEvent.call(target, event);\n    };\n};\n","import {\n    createCancelAndHoldAutomationEvent,\n    createCancelScheduledValuesAutomationEvent,\n    createExponentialRampToValueAutomationEvent,\n    createLinearRampToValueAutomationEvent,\n    createSetTargetAutomationEvent,\n    createSetValueAutomationEvent,\n    createSetValueCurveAutomationEvent\n} from 'automation-events';\nimport { createAbortError } from './factories/abort-error';\nimport { createAddActiveInputConnectionToAudioNode } from './factories/add-active-input-connection-to-audio-node';\nimport { createAddAudioNodeConnections } from './factories/add-audio-node-connections';\nimport { createAddAudioParamConnections } from './factories/add-audio-param-connections';\nimport { createAddAudioWorkletModule } from './factories/add-audio-worklet-module';\nimport { createAddConnectionToAudioNode } from './factories/add-connection-to-audio-node';\nimport { createAddPassiveInputConnectionToAudioNode } from './factories/add-passive-input-connection-to-audio-node';\nimport { createAddSilentConnection } from './factories/add-silent-connection';\nimport { createAddUnrenderedAudioWorkletNode } from './factories/add-unrendered-audio-worklet-node';\nimport { createAnalyserNodeConstructor } from './factories/analyser-node-constructor';\nimport { createAnalyserNodeRendererFactory } from './factories/analyser-node-renderer-factory';\nimport { createAudioBufferConstructor } from './factories/audio-buffer-constructor';\nimport { createAudioBufferSourceNodeConstructor } from './factories/audio-buffer-source-node-constructor';\nimport { createAudioBufferSourceNodeRendererFactory } from './factories/audio-buffer-source-node-renderer-factory';\nimport { createAudioContextConstructor } from './factories/audio-context-constructor';\nimport { createAudioDestinationNodeConstructor } from './factories/audio-destination-node-constructor';\nimport { createAudioDestinationNodeRenderer } from './factories/audio-destination-node-renderer-factory';\nimport { createAudioListenerFactory } from './factories/audio-listener-factory';\nimport { createAudioNodeConstructor } from './factories/audio-node-constructor';\nimport { createAudioParamFactory } from './factories/audio-param-factory';\nimport { createAudioParamRenderer } from './factories/audio-param-renderer';\nimport { createAudioWorkletNodeConstructor } from './factories/audio-worklet-node-constructor';\nimport { createAudioWorkletNodeRendererFactory } from './factories/audio-worklet-node-renderer-factory';\nimport { createBaseAudioContextConstructor } from './factories/base-audio-context-constructor';\nimport { createBiquadFilterNodeConstructor } from './factories/biquad-filter-node-constructor';\nimport { createBiquadFilterNodeRendererFactory } from './factories/biquad-filter-node-renderer-factory';\nimport { createCacheTestResult } from './factories/cache-test-result';\nimport { createChannelMergerNodeConstructor } from './factories/channel-merger-node-constructor';\nimport { createChannelMergerNodeRendererFactory } from './factories/channel-merger-node-renderer-factory';\nimport { createChannelSplitterNodeConstructor } from './factories/channel-splitter-node-constructor';\nimport { createChannelSplitterNodeRendererFactory } from './factories/channel-splitter-node-renderer-factory';\nimport { createConnectAudioParam } from './factories/connect-audio-param';\nimport { createConnectMultipleOutputs } from './factories/connect-multiple-outputs';\nimport { createConnectedNativeAudioBufferSourceNodeFactory } from './factories/connected-native-audio-buffer-source-node-factory';\nimport { createConstantSourceNodeConstructor } from './factories/constant-source-node-constructor';\nimport { createConstantSourceNodeRendererFactory } from './factories/constant-source-node-renderer-factory';\nimport { createConvertNumberToUnsignedLong } from './factories/convert-number-to-unsigned-long';\nimport { createConvolverNodeConstructor } from './factories/convolver-node-constructor';\nimport { createConvolverNodeRendererFactory } from './factories/convolver-node-renderer-factory';\nimport { createCreateNativeOfflineAudioContext } from './factories/create-native-offline-audio-context';\nimport { createDataCloneError } from './factories/data-clone-error';\nimport { createDecodeAudioData } from './factories/decode-audio-data';\nimport { createDecrementCycleCounter } from './factories/decrement-cycle-counter';\nimport { createDelayNodeConstructor } from './factories/delay-node-constructor';\nimport { createDelayNodeRendererFactory } from './factories/delay-node-renderer-factory';\nimport { createDeleteActiveInputConnectionToAudioNode } from './factories/delete-active-input-connection-to-audio-node';\nimport { createDeleteUnrenderedAudioWorkletNode } from './factories/delete-unrendered-audio-worklet-node';\nimport { createDetectCycles } from './factories/detect-cycles';\nimport { createDisconnectMultipleOutputs } from './factories/disconnect-multiple-outputs';\nimport { createDynamicsCompressorNodeConstructor } from './factories/dynamics-compressor-node-constructor';\nimport { createDynamicsCompressorNodeRendererFactory } from './factories/dynamics-compressor-node-renderer-factory';\nimport { createEncodingError } from './factories/encoding-error';\nimport { createEvaluateSource } from './factories/evaluate-source';\nimport { createEventTargetConstructor } from './factories/event-target-constructor';\nimport { createExposeCurrentFrameAndCurrentTime } from './factories/expose-current-frame-and-current-time';\nimport { createFetchSource } from './factories/fetch-source';\nimport { createGainNodeConstructor } from './factories/gain-node-constructor';\nimport { createGainNodeRendererFactory } from './factories/gain-node-renderer-factory';\nimport { createGetActiveAudioWorkletNodeInputs } from './factories/get-active-audio-worklet-node-inputs';\nimport { createGetAudioNodeRenderer } from './factories/get-audio-node-renderer';\nimport { createGetAudioNodeTailTime } from './factories/get-audio-node-tail-time';\nimport { createGetAudioParamRenderer } from './factories/get-audio-param-renderer';\nimport { createGetBackupOfflineAudioContext } from './factories/get-backup-offline-audio-context';\nimport { createGetNativeContext } from './factories/get-native-context';\nimport { createGetOrCreateBackupOfflineAudioContext } from './factories/get-or-create-backup-offline-audio-context';\nimport { createGetUnrenderedAudioWorkletNodes } from './factories/get-unrendered-audio-worklet-nodes';\nimport { createIIRFilterNodeConstructor } from './factories/iir-filter-node-constructor';\nimport { createIIRFilterNodeRendererFactory } from './factories/iir-filter-node-renderer-factory';\nimport { createIncrementCycleCounterFactory } from './factories/increment-cycle-counter-factory';\nimport { createIndexSizeError } from './factories/index-size-error';\nimport { createInvalidAccessError } from './factories/invalid-access-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsAnyAudioContext } from './factories/is-any-audio-context';\nimport { createIsAnyAudioNode } from './factories/is-any-audio-node';\nimport { createIsAnyAudioParam } from './factories/is-any-audio-param';\nimport { createIsAnyOfflineAudioContext } from './factories/is-any-offline-audio-context';\nimport { createIsNativeAudioContext } from './factories/is-native-audio-context';\nimport { createIsNativeAudioNode } from './factories/is-native-audio-node';\nimport { createIsNativeAudioParam } from './factories/is-native-audio-param';\nimport { createIsNativeContext } from './factories/is-native-context';\nimport { createIsNativeOfflineAudioContext } from './factories/is-native-offline-audio-context';\nimport { createIsSecureContext } from './factories/is-secure-context';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaElementAudioSourceNodeConstructor } from './factories/media-element-audio-source-node-constructor';\nimport { createMediaStreamAudioDestinationNodeConstructor } from './factories/media-stream-audio-destination-node-constructor';\nimport { createMediaStreamAudioSourceNodeConstructor } from './factories/media-stream-audio-source-node-constructor';\nimport { createMediaStreamTrackAudioSourceNodeConstructor } from './factories/media-stream-track-audio-source-node-constructor';\nimport { createMinimalAudioContextConstructor } from './factories/minimal-audio-context-constructor';\nimport { createMinimalBaseAudioContextConstructor } from './factories/minimal-base-audio-context-constructor';\nimport { createMinimalOfflineAudioContextConstructor } from './factories/minimal-offline-audio-context-constructor';\nimport { createMonitorConnections } from './factories/monitor-connections';\nimport { createNativeAnalyserNodeFactory } from './factories/native-analyser-node-factory';\nimport { createNativeAudioBufferConstructor } from './factories/native-audio-buffer-constructor';\nimport { createNativeAudioBufferSourceNodeFactory } from './factories/native-audio-buffer-source-node-factory';\nimport { createNativeAudioContextConstructor } from './factories/native-audio-context-constructor';\nimport { createNativeAudioDestinationNodeFactory } from './factories/native-audio-destination-node';\nimport { createNativeAudioWorkletNodeConstructor } from './factories/native-audio-worklet-node-constructor';\nimport { createNativeAudioWorkletNodeFactory } from './factories/native-audio-worklet-node-factory';\nimport { createNativeAudioWorkletNodeFakerFactory } from './factories/native-audio-worklet-node-faker-factory';\nimport { createNativeBiquadFilterNode } from './factories/native-biquad-filter-node';\nimport { createNativeChannelMergerNodeFactory } from './factories/native-channel-merger-node-factory';\nimport { createNativeChannelSplitterNode } from './factories/native-channel-splitter-node';\nimport { createNativeConstantSourceNodeFactory } from './factories/native-constant-source-node-factory';\nimport { createNativeConstantSourceNodeFakerFactory } from './factories/native-constant-source-node-faker-factory';\nimport { createNativeConvolverNodeFactory } from './factories/native-convolver-node-factory';\nimport { createNativeDelayNode } from './factories/native-delay-node';\nimport { createNativeDynamicsCompressorNodeFactory } from './factories/native-dynamics-compressor-node-factory';\nimport { createNativeGainNode } from './factories/native-gain-node';\nimport { createNativeIIRFilterNodeFactory } from './factories/native-iir-filter-node-factory';\nimport { createNativeIIRFilterNodeFakerFactory } from './factories/native-iir-filter-node-faker-factory';\nimport { createNativeMediaElementAudioSourceNode } from './factories/native-media-element-audio-source-node';\nimport { createNativeMediaStreamAudioDestinationNode } from './factories/native-media-stream-audio-destination-node';\nimport { createNativeMediaStreamAudioSourceNode } from './factories/native-media-stream-audio-source-node';\nimport { createNativeMediaStreamTrackAudioSourceNodeFactory } from './factories/native-media-stream-track-audio-source-node-factory';\nimport { createNativeOfflineAudioContextConstructor } from './factories/native-offline-audio-context-constructor';\nimport { createNativeOscillatorNodeFactory } from './factories/native-oscillator-node-factory';\nimport { createNativePannerNodeFactory } from './factories/native-panner-node-factory';\nimport { createNativePannerNodeFakerFactory } from './factories/native-panner-node-faker-factory';\nimport { createNativePeriodicWaveFactory } from './factories/native-periodic-wave-factory';\nimport { createNativeScriptProcessorNode } from './factories/native-script-processor-node';\nimport { createNativeStereoPannerNodeFactory } from './factories/native-stereo-panner-node-factory';\nimport { createNativeStereoPannerNodeFakerFactory } from './factories/native-stereo-panner-node-faker-factory';\nimport { createNativeWaveShaperNodeFactory } from './factories/native-wave-shaper-node-factory';\nimport { createNativeWaveShaperNodeFakerFactory } from './factories/native-wave-shaper-node-faker-factory';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createOfflineAudioContextConstructor } from './factories/offline-audio-context-constructor';\nimport { createOscillatorNodeConstructor } from './factories/oscillator-node-constructor';\nimport { createOscillatorNodeRendererFactory } from './factories/oscillator-node-renderer-factory';\nimport { createPannerNodeConstructor } from './factories/panner-node-constructor';\nimport { createPannerNodeRendererFactory } from './factories/panner-node-renderer-factory';\nimport { createPeriodicWaveConstructor } from './factories/periodic-wave-constructor';\nimport { createRenderAutomation } from './factories/render-automation';\nimport { createRenderInputsOfAudioNode } from './factories/render-inputs-of-audio-node';\nimport { createRenderInputsOfAudioParam } from './factories/render-inputs-of-audio-param';\nimport { createRenderNativeOfflineAudioContext } from './factories/render-native-offline-audio-context';\nimport { createSetActiveAudioWorkletNodeInputs } from './factories/set-active-audio-worklet-node-inputs';\nimport { createSetAudioNodeTailTime } from './factories/set-audio-node-tail-time';\nimport { createStartRendering } from './factories/start-rendering';\nimport { createStereoPannerNodeConstructor } from './factories/stereo-panner-node-constructor';\nimport { createStereoPannerNodeRendererFactory } from './factories/stereo-panner-node-renderer-factory';\nimport { createTestAudioBufferConstructorSupport } from './factories/test-audio-buffer-constructor-support';\nimport { createTestAudioBufferCopyChannelMethodsSubarraySupport } from './factories/test-audio-buffer-copy-channel-methods-subarray-support';\nimport { createTestAudioContextCloseMethodSupport } from './factories/test-audio-context-close-method-support';\nimport { createTestAudioContextDecodeAudioDataMethodTypeErrorSupport } from './factories/test-audio-context-decode-audio-data-method-type-error-support';\nimport { createTestAudioContextOptionsSupport } from './factories/test-audio-context-options-support';\nimport { createTestAudioNodeConnectMethodSupport } from './factories/test-audio-node-connect-method-support';\nimport { createTestAudioWorkletProcessorNoOutputsSupport } from './factories/test-audio-worklet-processor-no-outputs-support';\nimport { createTestAudioWorkletProcessorPostMessageSupport } from './factories/test-audio-worklet-processor-post-message-support';\nimport { createTestChannelMergerNodeChannelCountSupport } from './factories/test-channel-merger-node-channel-count-support';\nimport { createTestConstantSourceNodeAccurateSchedulingSupport } from './factories/test-constant-source-node-accurate-scheduling-support';\nimport { createTestConvolverNodeBufferReassignabilitySupport } from './factories/test-convolver-node-buffer-reassignability-support';\nimport { createTestConvolverNodeChannelCountSupport } from './factories/test-convolver-node-channel-count-support';\nimport { createTestIsSecureContextSupport } from './factories/test-is-secure-context-support';\nimport { createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport } from './factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support';\nimport { createTestOfflineAudioContextCurrentTimeSupport } from './factories/test-offline-audio-context-current-time-support';\nimport { createTestStereoPannerNodeDefaultValueSupport } from './factories/test-stereo-panner-node-default-value-support';\nimport { createUnknownError } from './factories/unknown-error';\nimport { createWaveShaperNodeConstructor } from './factories/wave-shaper-node-constructor';\nimport { createWaveShaperNodeRendererFactory } from './factories/wave-shaper-node-renderer-factory';\nimport { createWindow } from './factories/window';\nimport { createWrapAudioBufferCopyChannelMethods } from './factories/wrap-audio-buffer-copy-channel-methods';\nimport { createWrapAudioBufferCopyChannelMethodsOutOfBounds } from './factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds';\nimport { createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer } from './factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer';\nimport { createWrapChannelMergerNode } from './factories/wrap-channel-merger-node';\nimport {\n    AUDIO_NODE_CONNECTIONS_STORE,\n    AUDIO_NODE_STORE,\n    AUDIO_PARAM_CONNECTIONS_STORE,\n    AUDIO_PARAM_STORE,\n    CONTEXT_STORE,\n    CYCLE_COUNTERS\n} from './globals';\nimport { connectNativeAudioNodeToNativeAudioNode } from './helpers/connect-native-audio-node-to-native-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from './helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from './helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from './helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from './helpers/get-event-listeners-of-audio-node';\nimport { getFirstSample } from './helpers/get-first-sample';\nimport { getNativeAudioNode } from './helpers/get-native-audio-node';\nimport { getNativeAudioParam } from './helpers/get-native-audio-param';\nimport { getValueForKey } from './helpers/get-value-for-key';\nimport { insertElementInSet } from './helpers/insert-element-in-set';\nimport { isActiveAudioNode } from './helpers/is-active-audio-node';\nimport { isDCCurve } from './helpers/is-dc-curve';\nimport { isPartOfACycle } from './helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from './helpers/is-passive-audio-node';\nimport { overwriteAccessors } from './helpers/overwrite-accessors';\nimport { pickElementFromSet } from './helpers/pick-element-from-set';\nimport { sanitizeAudioWorkletNodeOptions } from './helpers/sanitize-audio-worklet-node-options';\nimport { sanitizeChannelSplitterOptions } from './helpers/sanitize-channel-splitter-options';\nimport { sanitizePeriodicWaveOptions } from './helpers/sanitize-periodic-wave-options';\nimport { setValueAtTimeUntilPossible } from './helpers/set-value-at-time-until-possible';\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from './helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport } from './helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support';\nimport { testAudioBufferSourceNodeStartMethodOffsetClampingSupport } from './helpers/test-audio-buffer-source-node-start-method-offset-clamping-support';\nimport { testAudioBufferSourceNodeStopMethodNullifiedBufferSupport } from './helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support';\nimport { testAudioScheduledSourceNodeStartMethodNegativeParametersSupport } from './helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support';\nimport { testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport } from './helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support';\nimport { testAudioScheduledSourceNodeStopMethodNegativeParametersSupport } from './helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support';\nimport { testAudioWorkletNodeOptionsClonability } from './helpers/test-audio-worklet-node-options-clonability';\nimport { testDomExceptionConstructorSupport } from './helpers/test-dom-exception-constructor-support';\nimport { testPromiseSupport } from './helpers/test-promise-support';\nimport { testTransferablesSupport } from './helpers/test-transferables-support';\nimport { wrapAudioBufferSourceNodeStartMethodOffsetClamping } from './helpers/wrap-audio-buffer-source-node-start-method-offset-clamping';\nimport { wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls } from './helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls';\nimport { wrapEventListener } from './helpers/wrap-event-listener';\nimport {\n    IAnalyserNode,\n    IAudioBuffer,\n    IAudioBufferSourceNode,\n    IAudioContext,\n    IAudioNode,\n    IAudioWorkletNode,\n    IBiquadFilterNode,\n    IConstantSourceNode,\n    IConvolverNode,\n    IDelayNode,\n    IDynamicsCompressorNode,\n    IGainNode,\n    IIIRFilterNode,\n    IMediaElementAudioSourceNode,\n    IMediaStreamAudioDestinationNode,\n    IMediaStreamAudioSourceNode,\n    IMediaStreamTrackAudioSourceNode,\n    IMinimalAudioContext,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IOfflineAudioContextConstructor,\n    IOscillatorNode,\n    IPannerNode,\n    IPeriodicWave,\n    IStereoPannerNode,\n    IWaveShaperNode\n} from './interfaces';\nimport {\n    TActiveAudioWorkletNodeInputsStore,\n    TAddAudioWorkletModuleFunction,\n    TAnalyserNodeConstructor,\n    TAudioBufferConstructor,\n    TAudioBufferSourceNodeConstructor,\n    TAudioBufferStore,\n    TAudioContextConstructor,\n    TAudioParamAudioNodeStore,\n    TAudioWorkletNodeConstructor,\n    TBackupOfflineAudioContextStore,\n    TBiquadFilterNodeConstructor,\n    TChannelMergerNodeConstructor,\n    TChannelSplitterNodeConstructor,\n    TConstantSourceNodeConstructor,\n    TContext,\n    TConvolverNodeConstructor,\n    TDecodeAudioDataFunction,\n    TDelayNodeConstructor,\n    TDynamicsCompressorNodeConstructor,\n    TGainNodeConstructor,\n    TIIRFilterNodeConstructor,\n    TMediaElementAudioSourceNodeConstructor,\n    TMediaStreamAudioDestinationNodeConstructor,\n    TMediaStreamAudioSourceNodeConstructor,\n    TMediaStreamTrackAudioSourceNodeConstructor,\n    TMinimalAudioContextConstructor,\n    TMinimalOfflineAudioContextConstructor,\n    TOscillatorNodeConstructor,\n    TPannerNodeConstructor,\n    TPeriodicWaveConstructor,\n    TStereoPannerNodeConstructor,\n    TUnrenderedAudioWorkletNodeStore,\n    TWaveShaperNodeConstructor\n} from './types';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nconst addActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode(insertElementInSet);\nconst addPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode(insertElementInSet);\nconst deleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);\nconst audioNodeTailTimeStore = new WeakMap();\nconst getAudioNodeTailTime = createGetAudioNodeTailTime(audioNodeTailTimeStore);\nconst cacheTestResult = createCacheTestResult(new Map(), new WeakMap());\nconst window = createWindow();\nconst createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError);\nconst getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);\nconst renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);\nconst createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst getNativeContext = createGetNativeContext(CONTEXT_STORE);\nconst nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window);\nconst isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\nconst audioParamAudioNodeStore: TAudioParamAudioNodeStore = new WeakMap();\nconst eventTargetConstructor = createEventTargetConstructor(wrapEventListener);\nconst nativeAudioContextConstructor = createNativeAudioContextConstructor(window);\nconst isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\nconst isNativeAudioNode = createIsNativeAudioNode(window);\nconst isNativeAudioParam = createIsNativeAudioParam(window);\nconst nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window);\nconst audioNodeConstructor = createAudioNodeConstructor(\n    createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE),\n    createAddConnectionToAudioNode(\n        addActiveInputConnectionToAudioNode,\n        addPassiveInputConnectionToAudioNode,\n        connectNativeAudioNodeToNativeAudioNode,\n        deleteActiveInputConnectionToAudioNode,\n        disconnectNativeAudioNodeFromNativeAudioNode,\n        getAudioNodeConnections,\n        getAudioNodeTailTime,\n        getEventListenersOfAudioNode,\n        getNativeAudioNode,\n        insertElementInSet,\n        isActiveAudioNode,\n        isPartOfACycle,\n        isPassiveAudioNode\n    ),\n    cacheTestResult,\n    createIncrementCycleCounterFactory(\n        CYCLE_COUNTERS,\n        disconnectNativeAudioNodeFromNativeAudioNode,\n        getAudioNodeConnections,\n        getNativeAudioNode,\n        getNativeAudioParam,\n        isActiveAudioNode\n    ),\n    createIndexSizeError,\n    createInvalidAccessError,\n    createNotSupportedError,\n    createDecrementCycleCounter(\n        connectNativeAudioNodeToNativeAudioNode,\n        CYCLE_COUNTERS,\n        getAudioNodeConnections,\n        getNativeAudioNode,\n        getNativeAudioParam,\n        getNativeContext,\n        isActiveAudioNode,\n        isNativeOfflineAudioContext\n    ),\n    createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey),\n    eventTargetConstructor,\n    getNativeContext,\n    isNativeAudioContext,\n    isNativeAudioNode,\n    isNativeAudioParam,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor\n);\nconst analyserNodeConstructor: TAnalyserNodeConstructor = createAnalyserNodeConstructor(\n    audioNodeConstructor,\n    createAnalyserNodeRenderer,\n    createIndexSizeError,\n    createNativeAnalyserNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\n\ntype analyserNodeConstructor<T extends TContext> = IAnalyserNode<T>;\n\nexport { analyserNodeConstructor as AnalyserNode };\n\nconst audioBufferStore: TAudioBufferStore = new WeakSet();\nconst nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window);\nconst convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\nconst wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\nconst wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\nconst audioBufferConstructor: TAudioBufferConstructor = createAudioBufferConstructor(\n    audioBufferStore,\n    cacheTestResult,\n    createNotSupportedError,\n    nativeAudioBufferConstructor,\n    nativeOfflineAudioContextConstructor,\n    createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor),\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n);\n\ntype audioBufferConstructor = IAudioBuffer;\n\nexport { audioBufferConstructor as AudioBuffer };\n\nconst addSilentConnection = createAddSilentConnection(createNativeGainNode);\nconst renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);\nconst connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);\nconst createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(\n    addSilentConnection,\n    cacheTestResult,\n    testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport,\n    testAudioBufferSourceNodeStartMethodOffsetClampingSupport,\n    testAudioBufferSourceNodeStopMethodNullifiedBufferSupport,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioBufferSourceNodeStartMethodOffsetClamping,\n    createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors),\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n);\nconst renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);\nconst createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(\n    connectAudioParam,\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst createAudioParam = createAudioParamFactory(\n    createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE),\n    audioParamAudioNodeStore,\n    AUDIO_PARAM_STORE,\n    createAudioParamRenderer,\n    createCancelAndHoldAutomationEvent,\n    createCancelScheduledValuesAutomationEvent,\n    createExponentialRampToValueAutomationEvent,\n    createLinearRampToValueAutomationEvent,\n    createSetTargetAutomationEvent,\n    createSetValueAutomationEvent,\n    createSetValueCurveAutomationEvent,\n    nativeAudioContextConstructor,\n    setValueAtTimeUntilPossible\n);\nconst audioBufferSourceNodeConstructor: TAudioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(\n    audioNodeConstructor,\n    createAudioBufferSourceNodeRenderer,\n    createAudioParam,\n    createInvalidStateError,\n    createNativeAudioBufferSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n);\n\ntype audioBufferSourceNodeConstructor<T extends TContext> = IAudioBufferSourceNode<T>;\n\nexport { audioBufferSourceNodeConstructor as AudioBufferSourceNode };\n\nconst audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(\n    audioNodeConstructor,\n    createAudioDestinationNodeRenderer,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors),\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    renderInputsOfAudioNode\n);\nconst createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(\n    connectAudioParam,\n    createNativeBiquadFilterNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst setAudioNodeTailTime = createSetAudioNodeTailTime(audioNodeTailTimeStore);\nconst biquadFilterNodeConstructor: TBiquadFilterNodeConstructor = createBiquadFilterNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createBiquadFilterNodeRenderer,\n    createInvalidAccessError,\n    createNativeBiquadFilterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);\nconst wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, monitorConnections);\nconst createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode);\nconst createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(\n    createNativeChannelMergerNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst channelMergerNodeConstructor: TChannelMergerNodeConstructor = createChannelMergerNodeConstructor(\n    audioNodeConstructor,\n    createChannelMergerNodeRenderer,\n    createNativeChannelMergerNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(\n    createNativeChannelSplitterNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst channelSplitterNodeConstructor: TChannelSplitterNodeConstructor = createChannelSplitterNodeConstructor(\n    audioNodeConstructor,\n    createChannelSplitterNodeRenderer,\n    createNativeChannelSplitterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    sanitizeChannelSplitterOptions\n);\nconst createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(\n    addSilentConnection,\n    createNativeAudioBufferSourceNode,\n    createNativeGainNode,\n    monitorConnections\n);\nconst createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(\n    addSilentConnection,\n    cacheTestResult,\n    createNativeConstantSourceNodeFaker,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport\n);\nconst createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(\n    connectAudioParam,\n    createNativeConstantSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst constantSourceNodeConstructor: TConstantSourceNodeConstructor = createConstantSourceNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createConstantSourceNodeRenderer,\n    createNativeConstantSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n);\nconst createNativeConvolverNode = createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors);\nconst createConvolverNodeRenderer = createConvolverNodeRendererFactory(\n    createNativeConvolverNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst convolverNodeConstructor: TConvolverNodeConstructor = createConvolverNodeConstructor(\n    audioNodeConstructor,\n    createConvolverNodeRenderer,\n    createNativeConvolverNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createDelayNodeRenderer = createDelayNodeRendererFactory(\n    connectAudioParam,\n    createNativeDelayNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst delayNodeConstructor: TDelayNodeConstructor = createDelayNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createDelayNodeRenderer,\n    createNativeDelayNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNotSupportedError);\nconst createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(\n    connectAudioParam,\n    createNativeDynamicsCompressorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst dynamicsCompressorNodeConstructor: TDynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createDynamicsCompressorNodeRenderer,\n    createNativeDynamicsCompressorNode,\n    createNotSupportedError,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createGainNodeRenderer = createGainNodeRendererFactory(\n    connectAudioParam,\n    createNativeGainNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst gainNodeConstructor: TGainNodeConstructor = createGainNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createGainNodeRenderer,\n    createNativeGainNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(\n    createInvalidAccessError,\n    createInvalidStateError,\n    createNativeScriptProcessorNode,\n    createNotSupportedError\n);\nconst renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(\n    cacheTestResult,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor)\n);\nconst createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n);\nconst createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker);\nconst iIRFilterNodeConstructor: TIIRFilterNodeConstructor = createIIRFilterNodeConstructor(\n    audioNodeConstructor,\n    createNativeIIRFilterNode,\n    createIIRFilterNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createAudioListener = createAudioListenerFactory(\n    createAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    getFirstSample,\n    isNativeOfflineAudioContext,\n    overwriteAccessors\n);\nconst unrenderedAudioWorkletNodeStore: TUnrenderedAudioWorkletNodeStore = new WeakMap();\nconst minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(\n    audioDestinationNodeConstructor,\n    createAudioListener,\n    eventTargetConstructor,\n    isNativeOfflineAudioContext,\n    unrenderedAudioWorkletNodeStore,\n    wrapEventListener\n);\nconst createNativeOscillatorNode = createNativeOscillatorNodeFactory(\n    addSilentConnection,\n    cacheTestResult,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n);\nconst createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(\n    connectAudioParam,\n    createNativeOscillatorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst oscillatorNodeConstructor: TOscillatorNodeConstructor = createOscillatorNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeOscillatorNode,\n    createOscillatorNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n);\nconst createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);\nconst createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeGainNode,\n    isDCCurve,\n    monitorConnections\n);\nconst createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeWaveShaperNodeFaker,\n    isDCCurve,\n    monitorConnections,\n    nativeAudioContextConstructor,\n    overwriteAccessors\n);\nconst createNativePannerNodeFaker = createNativePannerNodeFakerFactory(\n    connectNativeAudioNodeToNativeAudioNode,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getFirstSample,\n    monitorConnections\n);\nconst createNativePannerNode = createNativePannerNodeFactory(createNativePannerNodeFaker);\nconst createPannerNodeRenderer = createPannerNodeRendererFactory(\n    connectAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativePannerNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n);\nconst pannerNodeConstructor: TPannerNodeConstructor = createPannerNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createNativePannerNode,\n    createPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createNativePeriodicWave = createNativePeriodicWaveFactory(createIndexSizeError);\nconst periodicWaveConstructor: TPeriodicWaveConstructor = createPeriodicWaveConstructor(\n    createNativePeriodicWave,\n    getNativeContext,\n    new WeakSet(),\n    sanitizePeriodicWaveOptions\n);\nconst nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeGainNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    monitorConnections\n);\nconst createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(nativeStereoPannerNodeFakerFactory, createNotSupportedError);\nconst createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(\n    connectAudioParam,\n    createNativeStereoPannerNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst stereoPannerNodeConstructor: TStereoPannerNodeConstructor = createStereoPannerNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeStereoPannerNode,\n    createStereoPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(\n    createNativeWaveShaperNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst waveShaperNodeConstructor: TWaveShaperNodeConstructor = createWaveShaperNodeConstructor(\n    audioNodeConstructor,\n    createInvalidStateError,\n    createNativeWaveShaperNode,\n    createWaveShaperNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst isSecureContext = createIsSecureContext(window);\nconst exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window);\nconst backupOfflineAudioContextStore: TBackupOfflineAudioContextStore = new WeakMap();\nconst getOrCreateBackupOfflineAudioContext = createGetOrCreateBackupOfflineAudioContext(\n    backupOfflineAudioContextStore,\n    nativeOfflineAudioContextConstructor\n);\n\n// The addAudioWorkletModule() function is only available in a SecureContext.\nexport const addAudioWorkletModule: undefined | TAddAudioWorkletModuleFunction = isSecureContext\n    ? createAddAudioWorkletModule(\n          cacheTestResult,\n          createNotSupportedError,\n          createEvaluateSource(window),\n          exposeCurrentFrameAndCurrentTime,\n          createFetchSource(createAbortError),\n          getNativeContext,\n          getOrCreateBackupOfflineAudioContext,\n          isNativeOfflineAudioContext,\n          nativeAudioWorkletNodeConstructor,\n          new WeakMap(),\n          new WeakMap(),\n          createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor),\n          // @todo window is guaranteed to be defined because isSecureContext checks that as well.\n          <NonNullable<typeof window>>window\n      )\n    : undefined;\n\nconst isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);\n\nexport const decodeAudioData: TDecodeAudioDataFunction = createDecodeAudioData(\n    audioBufferStore,\n    cacheTestResult,\n    createDataCloneError,\n    createEncodingError,\n    new WeakSet(),\n    getNativeContext,\n    isNativeContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    testPromiseSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n);\n\nconst baseAudioContextConstructor = createBaseAudioContextConstructor(\n    addAudioWorkletModule,\n    analyserNodeConstructor,\n    audioBufferConstructor,\n    audioBufferSourceNodeConstructor,\n    biquadFilterNodeConstructor,\n    channelMergerNodeConstructor,\n    channelSplitterNodeConstructor,\n    constantSourceNodeConstructor,\n    convolverNodeConstructor,\n    decodeAudioData,\n    delayNodeConstructor,\n    dynamicsCompressorNodeConstructor,\n    gainNodeConstructor,\n    iIRFilterNodeConstructor,\n    minimalBaseAudioContextConstructor,\n    oscillatorNodeConstructor,\n    pannerNodeConstructor,\n    periodicWaveConstructor,\n    stereoPannerNodeConstructor,\n    waveShaperNodeConstructor\n);\nconst mediaElementAudioSourceNodeConstructor: TMediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(\n    audioNodeConstructor,\n    createNativeMediaElementAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst mediaStreamAudioDestinationNodeConstructor: TMediaStreamAudioDestinationNodeConstructor =\n    createMediaStreamAudioDestinationNodeConstructor(\n        audioNodeConstructor,\n        createNativeMediaStreamAudioDestinationNode,\n        getNativeContext,\n        isNativeOfflineAudioContext\n    );\nconst mediaStreamAudioSourceNodeConstructor: TMediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(\n    audioNodeConstructor,\n    createNativeMediaStreamAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(\n    createInvalidStateError,\n    isNativeOfflineAudioContext\n);\nconst mediaStreamTrackAudioSourceNodeConstructor: TMediaStreamTrackAudioSourceNodeConstructor =\n    createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);\nconst audioContextConstructor: TAudioContextConstructor = createAudioContextConstructor(\n    baseAudioContextConstructor,\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    mediaElementAudioSourceNodeConstructor,\n    mediaStreamAudioDestinationNodeConstructor,\n    mediaStreamAudioSourceNodeConstructor,\n    mediaStreamTrackAudioSourceNodeConstructor,\n    nativeAudioContextConstructor\n);\n\ntype audioContextConstructor = IAudioContext;\n\nexport { audioContextConstructor as AudioContext };\n\nconst getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);\nconst addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\nconst deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\nconst activeAudioWorkletNodeInputsStore: TActiveAudioWorkletNodeInputsStore = new WeakMap();\nconst getActiveAudioWorkletNodeInputs = createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey);\nconst createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(\n    connectMultipleOutputs,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getActiveAudioWorkletNodeInputs,\n    monitorConnections\n);\nconst createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(\n    createInvalidStateError,\n    createNativeAudioWorkletNodeFaker,\n    createNativeGainNode,\n    createNotSupportedError,\n    monitorConnections\n);\nconst createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(\n    connectAudioParam,\n    connectMultipleOutputs,\n    createNativeAudioBufferSourceNode,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    deleteUnrenderedAudioWorkletNode,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getNativeAudioNode,\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n);\nconst getBackupOfflineAudioContext = createGetBackupOfflineAudioContext(backupOfflineAudioContextStore);\nconst setActiveAudioWorkletNodeInputs = createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore);\n\n// The AudioWorkletNode constructor is only available in a SecureContext.\nconst audioWorkletNodeConstructor: undefined | TAudioWorkletNodeConstructor = isSecureContext\n    ? createAudioWorkletNodeConstructor(\n          addUnrenderedAudioWorkletNode,\n          audioNodeConstructor,\n          createAudioParam,\n          createAudioWorkletNodeRenderer,\n          createNativeAudioWorkletNode,\n          getAudioNodeConnections,\n          getBackupOfflineAudioContext,\n          getNativeContext,\n          isNativeOfflineAudioContext,\n          nativeAudioWorkletNodeConstructor,\n          sanitizeAudioWorkletNodeOptions,\n          setActiveAudioWorkletNodeInputs,\n          testAudioWorkletNodeOptionsClonability,\n          wrapEventListener\n      )\n    : undefined;\n\ntype audioWorkletNodeConstructor<T extends TContext> = undefined | IAudioWorkletNode<T>;\n\nexport { audioWorkletNodeConstructor as AudioWorkletNode };\n\ntype biquadFilterNodeConstructor<T extends TContext> = IBiquadFilterNode<T>;\n\nexport { biquadFilterNodeConstructor as BiquadFilterNode };\n\ntype channelMergerNodeConstructor<T extends TContext> = IAudioNode<T>;\n\nexport { channelMergerNodeConstructor as ChannelMergerNode };\n\ntype channelSplitterNodeConstructor<T extends TContext> = IAudioNode<T>;\n\nexport { channelSplitterNodeConstructor as ChannelSplitterNode };\n\ntype constantSourceNodeConstructor<T extends TContext> = IConstantSourceNode<T>;\n\nexport { convolverNodeConstructor as ConvolverNode };\n\ntype convolverNodeConstructor<T extends TContext> = IConvolverNode<T>;\n\nexport { constantSourceNodeConstructor as ConstantSourceNode };\n\ntype delayNodeConstructor<T extends TContext> = IDelayNode<T>;\n\nexport { delayNodeConstructor as DelayNode };\n\ntype dynamicsCompressorNodeConstructor<T extends TContext> = IDynamicsCompressorNode<T>;\n\nexport { dynamicsCompressorNodeConstructor as DynamicsCompressorNode };\n\ntype gainNodeConstructor<T extends TContext> = IGainNode<T>;\n\nexport { gainNodeConstructor as GainNode };\n\ntype iIRFilterNodeConstructor<T extends TContext> = IIIRFilterNode<T>;\n\nexport { iIRFilterNodeConstructor as IIRFilterNode };\n\ntype mediaElementAudioSourceNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaElementAudioSourceNode<T>;\n\nexport { mediaElementAudioSourceNodeConstructor as MediaElementAudioSourceNode };\n\ntype mediaStreamAudioDestinationNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaStreamAudioDestinationNode<T>;\n\nexport { mediaStreamAudioDestinationNodeConstructor as MediaStreamAudioDestinationNode };\n\ntype mediaStreamAudioSourceNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaStreamAudioSourceNode<T>;\n\nexport { mediaStreamAudioSourceNodeConstructor as MediaStreamAudioSourceNode };\n\ntype mediaStreamTrackAudioSourceNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaStreamTrackAudioSourceNode<T>;\n\nexport { mediaStreamTrackAudioSourceNodeConstructor as MediaStreamTrackAudioSourceNode };\n\nconst minimalAudioContextConstructor: TMinimalAudioContextConstructor = createMinimalAudioContextConstructor(\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    minimalBaseAudioContextConstructor,\n    nativeAudioContextConstructor\n);\n\ntype minimalAudioContextConstructor = IMinimalAudioContext;\n\nexport { minimalAudioContextConstructor as MinimalAudioContext };\n\nconst createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(\n    createNotSupportedError,\n    nativeOfflineAudioContextConstructor\n);\nconst startRendering = createStartRendering(\n    audioBufferStore,\n    cacheTestResult,\n    getAudioNodeRenderer,\n    getUnrenderedAudioWorkletNodes,\n    renderNativeOfflineAudioContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n);\nconst minimalOfflineAudioContextConstructor: TMinimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    minimalBaseAudioContextConstructor,\n    startRendering\n);\n\ntype minimalOfflineAudioContextConstructor = IMinimalOfflineAudioContext;\n\nexport { minimalOfflineAudioContextConstructor as MinimalOfflineAudioContext };\n\nconst offlineAudioContextConstructor: IOfflineAudioContextConstructor = createOfflineAudioContextConstructor(\n    baseAudioContextConstructor,\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    startRendering\n);\n\ntype offlineAudioContextConstructor = IOfflineAudioContext;\n\nexport { offlineAudioContextConstructor as OfflineAudioContext };\n\ntype oscillatorNodeConstructor<T extends TContext> = IOscillatorNode<T>;\n\nexport { oscillatorNodeConstructor as OscillatorNode };\n\ntype pannerNodeConstructor<T extends TContext> = IPannerNode<T>;\n\nexport { pannerNodeConstructor as PannerNode };\n\ntype periodicWaveConstructor = IPeriodicWave;\n\nexport { periodicWaveConstructor as PeriodicWave };\n\ntype stereoPannerNodeConstructor<T extends TContext> = IStereoPannerNode<T>;\n\nexport { stereoPannerNodeConstructor as StereoPannerNode };\n\ntype waveShaperNodeConstructor<T extends TContext> = IWaveShaperNode<T>;\n\nexport { waveShaperNodeConstructor as WaveShaperNode };\n\nexport const isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);\n\nexport const isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);\n\nexport const isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);\n\nexport const isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);\n\nexport const isSupported = () =>\n    createIsSupportedPromise(\n        cacheTestResult,\n        createTestAudioBufferCopyChannelMethodsSubarraySupport(nativeOfflineAudioContextConstructor),\n        createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor),\n        createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor),\n        createTestAudioContextOptionsSupport(nativeAudioContextConstructor),\n        createTestAudioNodeConnectMethodSupport(nativeOfflineAudioContextConstructor),\n        createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor),\n        createTestChannelMergerNodeChannelCountSupport(nativeOfflineAudioContextConstructor),\n        createTestConstantSourceNodeAccurateSchedulingSupport(nativeOfflineAudioContextConstructor),\n        createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor),\n        createTestConvolverNodeChannelCountSupport(nativeOfflineAudioContextConstructor),\n        testDomExceptionConstructorSupport,\n        createTestIsSecureContextSupport(window),\n        createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport(nativeAudioContextConstructor),\n        createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor),\n        testTransferablesSupport\n    );\n","import { TAddActiveInputConnectionToAudioNodeFactory } from '../types/add-active-input-connection-to-audio-node-factory';\n\nexport const createAddActiveInputConnectionToAudioNode: TAddActiveInputConnectionToAudioNodeFactory = (insertElementInSet) => {\n    return (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {\n        insertElementInSet(\n            activeInputs[input],\n            [source, output, eventListener],\n            (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output,\n            ignoreDuplicates\n        );\n    };\n};\n","import { TAddPassiveInputConnectionToAudioNodeFactory } from '../types';\n\nexport const createAddPassiveInputConnectionToAudioNode: TAddPassiveInputConnectionToAudioNodeFactory = (insertElementInSet) => {\n    return (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {\n        const passiveInputConnections = passiveInputs.get(source);\n\n        if (passiveInputConnections === undefined) {\n            passiveInputs.set(source, new Set([[output, input, eventListener]]));\n        } else {\n            insertElementInSet(\n                passiveInputConnections,\n                [output, input, eventListener],\n                (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input,\n                ignoreDuplicates\n            );\n        }\n    };\n};\n","import { TDeleteActiveInputConnectionToAudioNodeFactory } from '../types';\n\nexport const createDeleteActiveInputConnectionToAudioNode: TDeleteActiveInputConnectionToAudioNodeFactory = (pickElementFromSet) => {\n    return (activeInputs, source, output, input) => {\n        return pickElementFromSet(\n            activeInputs[input],\n            (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output\n        );\n    };\n};\n","import { TGetAudioNodeTailTimeFactory } from '../types';\n\nexport const createGetAudioNodeTailTime: TGetAudioNodeTailTimeFactory = (audioNodeTailTimeStore) => {\n    return (audioNode) => audioNodeTailTimeStore.get(audioNode) ?? 0;\n};\n","import { TWindow, TWindowFactory } from '../types';\n\nexport const createWindow: TWindowFactory = () => (typeof window === 'undefined' ? null : <TWindow>window);\n","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { testAnalyserNodeGetFloatTimeDomainDataMethodSupport } from '../helpers/test-analyser-node-get-float-time-domain-data-method-support';\nimport { wrapAnalyserNodeGetFloatTimeDomainDataMethod } from '../helpers/wrap-analyser-node-get-float-time-domain-data-method';\nimport { TNativeAnalyserNodeFactoryFactory } from '../types';\n\nexport const createNativeAnalyserNodeFactory: TNativeAnalyserNodeFactoryFactory = (cacheTestResult, createIndexSizeError) => {\n    return (nativeContext, options) => {\n        const nativeAnalyserNode = nativeContext.createAnalyser();\n\n        // Bug #37: Firefox does not create an AnalyserNode with the default properties.\n        assignNativeAudioNodeOptions(nativeAnalyserNode, options);\n\n        // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n        if (!(options.maxDecibels > options.minDecibels)) {\n            throw createIndexSizeError();\n        }\n\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'fftSize');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'maxDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'minDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'smoothingTimeConstant');\n\n        // Bug #36: Safari does not support getFloatTimeDomainData() yet.\n        if (\n            !cacheTestResult(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () =>\n                testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode)\n            )\n        ) {\n            wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);\n        }\n\n        return nativeAnalyserNode;\n    };\n};\n","import { TNativeAnalyserNode } from '../types';\n\nexport const wrapAnalyserNodeGetFloatTimeDomainDataMethod = (nativeAnalyserNode: TNativeAnalyserNode): void => {\n    nativeAnalyserNode.getFloatTimeDomainData = (array: Float32Array) => {\n        const byteTimeDomainData = new Uint8Array(array.length);\n\n        nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);\n\n        const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);\n\n        for (let i = 0; i < length; i += 1) {\n            array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;\n        }\n\n        return array;\n    };\n};\n","import { IAudioNode, IAudioNodeRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TGetAudioNodeRendererFactory } from '../types';\n\nexport const createGetAudioNodeRenderer: TGetAudioNodeRendererFactory = (getAudioNodeConnections) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        audioNode: IAudioNode<T>\n    ): IAudioNodeRenderer<T, IAudioNode<T>> => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n\n        if (audioNodeConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioNode in the audio graph.');\n        }\n\n        return <IAudioNodeRenderer<T, IAudioNode<T>>>audioNodeConnections.renderer;\n    };\n};\n","import { IAudioDestinationNode } from '../interfaces';\nimport { TRenderInputsOfAudioNodeFactory } from '../types';\n\nexport const createRenderInputsOfAudioNode: TRenderInputsOfAudioNodeFactory = (\n    getAudioNodeConnections,\n    getAudioNodeRenderer,\n    isPartOfACycle\n) => {\n    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n\n        await Promise.all(\n            audioNodeConnections.activeInputs\n                .map((connections, input) =>\n                    Array.from(connections).map(async ([source, output]) => {\n                        const audioNodeRenderer = getAudioNodeRenderer(source);\n                        const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n                        const destination = <IAudioDestinationNode<typeof audioNode.context>>audioNode.context.destination;\n\n                        if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n                            renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n                        }\n                    })\n                )\n                .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], [])\n        );\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAnalyserNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAnalyserNodeRendererFactoryFactory, TNativeAnalyserNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createAnalyserNodeRendererFactory: TAnalyserNodeRendererFactoryFactory = (\n    createNativeAnalyserNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAnalyserNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAnalyserNode>();\n\n        const createAnalyserNode = async (proxy: IAnalyserNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAnalyserNode = getNativeAudioNode<T, TNativeAnalyserNode>(proxy);\n\n            // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n\n            if (!nativeAnalyserNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAnalyserNode.channelCount,\n                    channelCountMode: nativeAnalyserNode.channelCountMode,\n                    channelInterpretation: nativeAnalyserNode.channelInterpretation,\n                    fftSize: nativeAnalyserNode.fftSize,\n                    maxDecibels: nativeAnalyserNode.maxDecibels,\n                    minDecibels: nativeAnalyserNode.minDecibels,\n                    smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n                };\n\n                nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode);\n\n            return nativeAnalyserNode;\n        };\n\n        return {\n            render(proxy: IAnalyserNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeAnalyserNode> {\n                const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAnalyserNode !== undefined) {\n                    return Promise.resolve(renderedNativeAnalyserNode);\n                }\n\n                return createAnalyserNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { TNativeOfflineAudioContextConstructorFactory } from '../types';\n\nexport const createNativeOfflineAudioContextConstructor: TNativeOfflineAudioContextConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    if (window.hasOwnProperty('OfflineAudioContext')) {\n        return window.OfflineAudioContext;\n    }\n\n    return window.hasOwnProperty('webkitOfflineAudioContext') ? (<any>window).webkitOfflineAudioContext : null;\n};\n","import { TIsNativeOfflineAudioContextFactory, TNativeOfflineAudioContext } from '../types';\n\nexport const createIsNativeOfflineAudioContext: TIsNativeOfflineAudioContextFactory = (nativeOfflineAudioContextConstructor) => {\n    return (anything): anything is TNativeOfflineAudioContext => {\n        return nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor;\n    };\n};\n","import { IEventTarget } from '../interfaces';\nimport { TEventHandler, TEventTargetConstructorFactory, TNativeEventTarget } from '../types';\n\nexport const createEventTargetConstructor: TEventTargetConstructorFactory = (wrapEventListener) => {\n    return class EventTarget<EventMap extends Record<string, Event>> implements IEventTarget<EventMap> {\n        private _listeners: WeakMap<EventListenerOrEventListenerObject, EventListenerOrEventListenerObject>;\n\n        constructor(private _nativeEventTarget: TNativeEventTarget) {\n            this._listeners = new WeakMap();\n        }\n\n        public addEventListener(\n            type: string,\n            listener: null | TEventHandler<this> | EventListenerOrEventListenerObject,\n            options?: boolean | AddEventListenerOptions\n        ): void {\n            if (listener !== null) {\n                let wrappedEventListener = this._listeners.get(listener);\n\n                if (wrappedEventListener === undefined) {\n                    wrappedEventListener = wrapEventListener(this, listener);\n\n                    if (typeof listener === 'function') {\n                        this._listeners.set(listener, wrappedEventListener);\n                    }\n                }\n\n                this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n            }\n        }\n\n        public dispatchEvent(event: Event): boolean {\n            return this._nativeEventTarget.dispatchEvent(event);\n        }\n\n        public removeEventListener(\n            type: string,\n            listener: null | TEventHandler<this> | EventListenerOrEventListenerObject,\n            options?: boolean | EventListenerOptions\n        ): void {\n            const wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);\n\n            this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);\n        }\n    };\n};\n","import { TNativeAudioContextConstructorFactory } from '../types';\n\nexport const createNativeAudioContextConstructor: TNativeAudioContextConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    if (window.hasOwnProperty('AudioContext')) {\n        return window.AudioContext;\n    }\n\n    return window.hasOwnProperty('webkitAudioContext') ? (<any>window).webkitAudioContext : null;\n};\n","import { TIsNativeAudioContextFactory, TNativeAudioContext } from '../types';\n\nexport const createIsNativeAudioContext: TIsNativeAudioContextFactory = (nativeAudioContextConstructor) => {\n    return (anything): anything is TNativeAudioContext => {\n        return nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor;\n    };\n};\n","import { TIsNativeAudioNodeFactory, TNativeAudioNode } from '../types';\n\nexport const createIsNativeAudioNode: TIsNativeAudioNodeFactory = (window) => {\n    return (anything): anything is TNativeAudioNode => {\n        return window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode;\n    };\n};\n","import { TIsNativeAudioParamFactory, TNativeAudioParam } from '../types';\n\nexport const createIsNativeAudioParam: TIsNativeAudioParamFactory = (window) => {\n    return (anything): anything is TNativeAudioParam => {\n        return window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam;\n    };\n};\n","import { TNativeAudioWorkletNodeConstructorFactory } from '../types';\n\nexport const createNativeAudioWorkletNodeConstructor: TNativeAudioWorkletNodeConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    return window.hasOwnProperty('AudioWorkletNode') ? window.AudioWorkletNode : null;\n};\n","import { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { IAudioNode } from '../interfaces';\nimport { TAddConnectionToAudioNodeFactory, TContext, TInternalStateEventListener } from '../types';\n\nexport const createAddConnectionToAudioNode: TAddConnectionToAudioNodeFactory = (\n    addActiveInputConnectionToAudioNode,\n    addPassiveInputConnectionToAudioNode,\n    connectNativeAudioNodeToNativeAudioNode,\n    deleteActiveInputConnectionToAudioNode,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getAudioNodeConnections,\n    getAudioNodeTailTime,\n    getEventListenersOfAudioNode,\n    getNativeAudioNode,\n    insertElementInSet,\n    isActiveAudioNode,\n    isPartOfACycle,\n    isPassiveAudioNode\n) => {\n    const tailTimeTimeoutIds = new WeakMap<IAudioNode<TContext>, number>();\n\n    return (source, destination, output, input, isOffline) => {\n        const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n        const { outputs } = getAudioNodeConnections(source);\n        const eventListeners = getEventListenersOfAudioNode(source);\n\n        const eventListener: TInternalStateEventListener = (isActive) => {\n            const nativeDestinationAudioNode = getNativeAudioNode(destination);\n            const nativeSourceAudioNode = getNativeAudioNode(source);\n\n            if (isActive) {\n                const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n\n                addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n\n                if (!isOffline && !isPartOfACycle(source)) {\n                    connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n\n                if (isPassiveAudioNode(destination)) {\n                    setInternalStateToActive(destination);\n                }\n            } else {\n                const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);\n\n                if (!isOffline && !isPartOfACycle(source)) {\n                    disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n\n                const tailTime = getAudioNodeTailTime(destination);\n\n                if (tailTime === 0) {\n                    if (isActiveAudioNode(destination)) {\n                        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                    }\n                } else {\n                    const tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);\n\n                    if (tailTimeTimeoutId !== undefined) {\n                        clearTimeout(tailTimeTimeoutId);\n                    }\n\n                    tailTimeTimeoutIds.set(\n                        destination,\n                        setTimeout(() => {\n                            if (isActiveAudioNode(destination)) {\n                                setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                            }\n                        }, tailTime * 1000)\n                    );\n                }\n            }\n        };\n\n        if (\n            insertElementInSet(\n                outputs,\n                [destination, output, input],\n                (outputConnection) =>\n                    outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input,\n                true\n            )\n        ) {\n            eventListeners.add(eventListener);\n\n            if (isActiveAudioNode(source)) {\n                addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n            } else {\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n            }\n\n            return true;\n        }\n\n        return false;\n    };\n};\n","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { TIncrementCycleCounterFactoryFactory } from '../types';\n\nexport const createIncrementCycleCounterFactory: TIncrementCycleCounterFactoryFactory = (\n    cycleCounters,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getAudioNodeConnections,\n    getNativeAudioNode,\n    getNativeAudioParam,\n    isActiveAudioNode\n) => {\n    return (isOffline) => {\n        return (audioNode, count) => {\n            const cycleCounter = cycleCounters.get(audioNode);\n\n            if (cycleCounter === undefined) {\n                if (!isOffline && isActiveAudioNode(audioNode)) {\n                    const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                    const { outputs } = getAudioNodeConnections(audioNode);\n\n                    for (const output of outputs) {\n                        if (isAudioNodeOutputConnection(output)) {\n                            const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n\n                            disconnectNativeAudioNodeFromNativeAudioNode(\n                                nativeSourceAudioNode,\n                                nativeDestinationAudioNode,\n                                output[1],\n                                output[2]\n                            );\n                        } else {\n                            const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n\n                            nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);\n                        }\n                    }\n                }\n\n                cycleCounters.set(audioNode, count);\n            } else {\n                cycleCounters.set(audioNode, cycleCounter + count);\n            }\n        };\n    };\n};\n","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { TDecrementCycleCounterFactory } from '../types';\n\nexport const createDecrementCycleCounter: TDecrementCycleCounterFactory = (\n    connectNativeAudioNodeToNativeAudioNode,\n    cycleCounters,\n    getAudioNodeConnections,\n    getNativeAudioNode,\n    getNativeAudioParam,\n    getNativeContext,\n    isActiveAudioNode,\n    isNativeOfflineAudioContext\n) => {\n    return (audioNode, count) => {\n        const cycleCounter = cycleCounters.get(audioNode);\n\n        if (cycleCounter === undefined) {\n            throw new Error('Missing the expected cycle count.');\n        }\n\n        const nativeContext = getNativeContext(audioNode.context);\n        const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n        if (cycleCounter === count) {\n            cycleCounters.delete(audioNode);\n\n            if (!isOffline && isActiveAudioNode(audioNode)) {\n                const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                const { outputs } = getAudioNodeConnections(audioNode);\n\n                for (const output of outputs) {\n                    if (isAudioNodeOutputConnection(output)) {\n                        const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n\n                        connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                    } else {\n                        const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n\n                        nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);\n                    }\n                }\n            }\n        } else {\n            cycleCounters.set(audioNode, cycleCounter - count);\n        }\n    };\n};\n","import { isAudioNode } from '../guards/audio-node';\nimport { isDelayNode } from '../guards/delay-node';\nimport { IAudioNode, IAudioParam } from '../interfaces';\nimport { TContext, TDetectCyclesFactory } from '../types';\n\nexport const createDetectCycles: TDetectCyclesFactory = (audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) => {\n    return function detectCycles<T extends TContext>(chain: IAudioNode<T>[], nextLink: IAudioNode<T> | IAudioParam): IAudioNode<T>[][] {\n        const audioNode = isAudioNode(nextLink) ? nextLink : <IAudioNode<T>>getValueForKey(audioParamAudioNodeStore, nextLink);\n\n        if (isDelayNode(audioNode)) {\n            return [];\n        }\n\n        if (chain[0] === audioNode) {\n            return [chain];\n        }\n\n        if (chain.includes(audioNode)) {\n            return [];\n        }\n\n        const { outputs } = getAudioNodeConnections(audioNode);\n\n        return Array.from(outputs)\n            .map((outputConnection) => detectCycles([...chain, audioNode], outputConnection[0]))\n            .reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);\n    };\n};\n","import { IAudioNode, IDelayNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isDelayNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IDelayNode<T> => {\n    return 'delayTime' in audioNode;\n};\n","import { TNativeAudioBufferConstructorFactory } from '../types';\n\nexport const createNativeAudioBufferConstructor: TNativeAudioBufferConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    if (window.hasOwnProperty('AudioBuffer')) {\n        return window.AudioBuffer;\n    }\n\n    return null;\n};\n","import { TNativeAudioBuffer, TWrapAudioBufferCopyChannelMethodsFactory } from '../types';\n\nexport const createWrapAudioBufferCopyChannelMethods: TWrapAudioBufferCopyChannelMethodsFactory = (\n    convertNumberToUnsignedLong,\n    createIndexSizeError\n) => {\n    return (audioBuffer: TNativeAudioBuffer): void => {\n        audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const destinationLength = destination.length;\n\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n                destination[i] = channelData[i + bufferOffset];\n            }\n        };\n\n        audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const sourceLength = source.length;\n\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n                channelData[i + bufferOffset] = source[i];\n            }\n        };\n    };\n};\n","import { TNativeAudioBuffer, TWrapAudioBufferCopyChannelMethodsOutOfBoundsFactory } from '../types';\n\nexport const createWrapAudioBufferCopyChannelMethodsOutOfBounds: TWrapAudioBufferCopyChannelMethodsOutOfBoundsFactory = (\n    convertNumberToUnsignedLong\n) => {\n    return (audioBuffer: TNativeAudioBuffer): void => {\n        audioBuffer.copyFromChannel = ((copyFromChannel) => {\n            return (destination: Float32Array, channelNumberAsNumber: number, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n                if (bufferOffset < audioBuffer.length) {\n                    return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyFromChannel);\n\n        audioBuffer.copyToChannel = ((copyToChannel) => {\n            return (source: Float32Array, channelNumberAsNumber: number, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n                if (bufferOffset < audioBuffer.length) {\n                    return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyToChannel);\n    };\n};\n","import { TTestAudioBufferConstructorSupportFactory } from '../types';\n\n// Bug #33: Safari exposes an AudioBuffer but it can't be used as a constructor.\nexport const createTestAudioBufferConstructorSupport: TTestAudioBufferConstructorSupportFactory = (nativeAudioBufferConstructor) => {\n    return () => {\n        if (nativeAudioBufferConstructor === null) {\n            return false;\n        }\n\n        try {\n            new nativeAudioBufferConstructor({ length: 1, sampleRate: 44100 }); // tslint:disable-line:no-unused-expression\n        } catch {\n            return false;\n        }\n\n        return true;\n    };\n};\n","import { TAddSilentConnectionFactory } from '../types';\n\nexport const createAddSilentConnection: TAddSilentConnectionFactory = (createNativeGainNode) => {\n    return (nativeContext, nativeAudioScheduledSourceNode) => {\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n\n        nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);\n\n        const disconnect = () => {\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnect);\n            nativeAudioScheduledSourceNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n\n        nativeAudioScheduledSourceNode.addEventListener('ended', disconnect);\n    };\n};\n","import { IAudioParam, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TNativeAudioParam, TNativeOfflineAudioContext, TRenderInputsOfAudioParamFactory } from '../types';\n\nexport const createRenderInputsOfAudioParam: TRenderInputsOfAudioParamFactory = (\n    getAudioNodeRenderer,\n    getAudioParamConnections,\n    isPartOfACycle\n) => {\n    return async <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        audioParam: IAudioParam,\n        nativeOfflineAudioContext: TNativeOfflineAudioContext,\n        nativeAudioParam: TNativeAudioParam\n    ): Promise<void> => {\n        const audioParamConnections = getAudioParamConnections<T>(audioParam);\n\n        await Promise.all(\n            Array.from(audioParamConnections.activeInputs).map(async ([source, output]) => {\n                const audioNodeRenderer = getAudioNodeRenderer(source);\n                const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n\n                if (!isPartOfACycle(source)) {\n                    renderedNativeAudioNode.connect(nativeAudioParam, output);\n                }\n            })\n        );\n    };\n};\n","import { TConnectAudioParamFactory } from '../types';\n\nexport const createConnectAudioParam: TConnectAudioParamFactory = (renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n    };\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioBufferSourceNodeStartMethodConsecutiveCalls } from '../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nimport { TNativeAudioBufferSourceNodeFactoryFactory } from '../types';\n\nexport const createNativeAudioBufferSourceNodeFactory: TNativeAudioBufferSourceNodeFactoryFactory = (\n    addSilentConnection,\n    cacheTestResult,\n    testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport,\n    testAudioBufferSourceNodeStartMethodOffsetClampingSupport,\n    testAudioBufferSourceNodeStopMethodNullifiedBufferSupport,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioBufferSourceNodeStartMethodOffsetClampling,\n    wrapAudioBufferSourceNodeStopMethodNullifiedBuffer,\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n) => {\n    return (nativeContext, options) => {\n        const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n        assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');\n\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');\n\n        // Bug #149: Safari does not yet support the detune AudioParam.\n\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');\n\n        // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n        if (\n            !cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () =>\n                testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext)\n            )\n        ) {\n            wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n        if (\n            !cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () =>\n                testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext)\n            )\n        ) {\n            wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.\n        if (\n            !cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, () =>\n                testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext)\n            )\n        ) {\n            wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n        }\n\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () =>\n                testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n        }\n\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeAudioBufferSourceNode);\n\n        return nativeAudioBufferSourceNode;\n    };\n};\n","import { createInvalidStateError } from '../factories/invalid-state-error';\nimport { TNativeAudioBufferSourceNode } from '../types';\n\nexport const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode): void => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        let isScheduled = false;\n\n        return (when = 0, offset = 0, duration?: number) => {\n            if (isScheduled) {\n                throw createInvalidStateError();\n            }\n\n            start.call(nativeAudioBufferSourceNode, when, offset, duration);\n\n            isScheduled = true;\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n","import { TNativeContext } from '../types';\n\nexport const testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n    nativeAudioBufferSourceNode.start();\n\n    try {\n        nativeAudioBufferSourceNode.start();\n    } catch {\n        return true;\n    }\n\n    return false;\n};\n","import { TNativeContext } from '../types';\n\nexport const testAudioBufferSourceNodeStartMethodOffsetClampingSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n\n    try {\n        nativeAudioBufferSourceNode.start(0, 1);\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n","import { TNativeContext } from '../types';\n\nexport const testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n    nativeAudioBufferSourceNode.start();\n\n    try {\n        nativeAudioBufferSourceNode.stop();\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n","import { TNativeAudioBufferSourceNode } from '../types';\n\nexport const wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode): void => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration?: number) => {\n            const buffer = nativeAudioBufferSourceNode.buffer;\n            // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n            const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset);\n\n            // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n            if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {\n                start.call(nativeAudioBufferSourceNode, when, 0, 0);\n            } else {\n                start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n            }\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n","import { TWrapAudioBufferSourceNodeStopMethodNullifiedBufferFactory } from '../types';\n\nexport const createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer: TWrapAudioBufferSourceNodeStopMethodNullifiedBufferFactory = (\n    overwriteAccessors\n) => {\n    return (nativeAudioBufferSourceNode, nativeContext) => {\n        const nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);\n\n        if (nativeAudioBufferSourceNode.buffer === null) {\n            nativeAudioBufferSourceNode.buffer = nullifiedBuffer;\n        }\n\n        overwriteAccessors(\n            nativeAudioBufferSourceNode,\n            'buffer',\n            (get) => () => {\n                const value = get.call(nativeAudioBufferSourceNode);\n\n                return value === nullifiedBuffer ? null : value;\n            },\n            (set) => (value) => {\n                return set.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);\n            }\n        );\n    };\n};\n","import { TRenderAutomationFactory } from '../types';\n\nexport const createRenderAutomation: TRenderAutomationFactory = (getAudioParamRenderer, renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n        const audioParamRenderer = getAudioParamRenderer(audioParam);\n\n        audioParamRenderer.replay(nativeAudioParam);\n\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n    };\n};\n","import { IMinimalOfflineAudioContext } from '../interfaces';\nimport { TGetAudioParamRendererFactory } from '../types';\n\nexport const createGetAudioParamRenderer: TGetAudioParamRendererFactory = (getAudioParamConnections) => {\n    return (audioParam) => {\n        const audioParamConnections = getAudioParamConnections<IMinimalOfflineAudioContext>(audioParam);\n\n        if (audioParamConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioParam in the audio graph.');\n        }\n\n        return audioParamConnections.renderer;\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAudioBufferSourceNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAudioBufferSourceNodeRendererFactoryFactory, TNativeAudioBufferSourceNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createAudioBufferSourceNodeRendererFactory: TAudioBufferSourceNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioBufferSourceNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioBufferSourceNode>();\n\n        let start: null | [number, number] | [number, number, number] = null;\n        let stop: null | number = null;\n\n        const createAudioBufferSourceNode = async (\n            proxy: IAudioBufferSourceNode<T>,\n            nativeOfflineAudioContext: TNativeOfflineAudioContext\n        ) => {\n            let nativeAudioBufferSourceNode = getNativeAudioNode<T, TNativeAudioBufferSourceNode>(proxy);\n\n            /*\n             * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeAudioBufferSourceNode.buffer,\n                    channelCount: nativeAudioBufferSourceNode.channelCount,\n                    channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n                    channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n                    // Bug #149: Safari does not yet support the detune AudioParam.\n                    loop: nativeAudioBufferSourceNode.loop,\n                    loopEnd: nativeAudioBufferSourceNode.loopEnd,\n                    loopStart: nativeAudioBufferSourceNode.loopStart,\n                    playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n                };\n\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);\n\n                if (start !== null) {\n                    nativeAudioBufferSourceNode.start(...start);\n                }\n\n                if (stop !== null) {\n                    nativeAudioBufferSourceNode.stop(stop);\n                }\n            }\n\n            renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await renderAutomation(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n            } else {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await connectAudioParam(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n\n            return nativeAudioBufferSourceNode;\n        };\n\n        return {\n            set start(value: [number, number] | [number, number, number]) {\n                start = value;\n            },\n            set stop(value: number) {\n                stop = value;\n            },\n            render(\n                proxy: IAudioBufferSourceNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioBufferSourceNode> {\n                const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioBufferSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioBufferSourceNode);\n                }\n\n                return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { AutomationEventList } from 'automation-events';\nimport { IAudioNode, IAudioParam, IAudioParamRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAudioParamFactoryFactory, TContext, TNativeAudioParam } from '../types';\n\nexport const createAudioParamFactory: TAudioParamFactoryFactory = (\n    addAudioParamConnections,\n    audioParamAudioNodeStore,\n    audioParamStore,\n    createAudioParamRenderer,\n    createCancelAndHoldAutomationEvent,\n    createCancelScheduledValuesAutomationEvent,\n    createExponentialRampToValueAutomationEvent,\n    createLinearRampToValueAutomationEvent,\n    createSetTargetAutomationEvent,\n    createSetValueAutomationEvent,\n    createSetValueCurveAutomationEvent,\n    nativeAudioContextConstructor,\n    setValueAtTimeUntilPossible\n) => {\n    return <T extends TContext>(\n        audioNode: IAudioNode<T>,\n        isAudioParamOfOfflineAudioContext: boolean,\n        nativeAudioParam: TNativeAudioParam,\n        maxValue: null | number = null,\n        minValue: null | number = null\n    ): IAudioParam => {\n        const automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);\n        const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n        const audioParam = {\n            get defaultValue(): number {\n                return nativeAudioParam.defaultValue;\n            },\n            get maxValue(): number {\n                return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n            },\n            get minValue(): number {\n                return minValue === null ? nativeAudioParam.minValue : minValue;\n            },\n            get value(): number {\n                return nativeAudioParam.value;\n            },\n            set value(value) {\n                nativeAudioParam.value = value;\n\n                // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n                audioParam.setValueAtTime(value, audioNode.context.currentTime);\n            },\n            cancelAndHoldAtTime(cancelTime: number): IAudioParam {\n                // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().\n                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n                } else {\n                    const previousLastEvent = Array.from(automationEventList).pop();\n\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n\n                    const currentLastEvent = Array.from(automationEventList).pop();\n\n                    nativeAudioParam.cancelScheduledValues(cancelTime);\n\n                    if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                        if (currentLastEvent.type === 'exponentialRampToValue') {\n                            nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        } else if (currentLastEvent.type === 'linearRampToValue') {\n                            nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        } else if (currentLastEvent.type === 'setValue') {\n                            nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                        } else if (currentLastEvent.type === 'setValueCurve') {\n                            nativeAudioParam.setValueCurveAtTime(\n                                currentLastEvent.values,\n                                currentLastEvent.startTime,\n                                currentLastEvent.duration\n                            );\n                        }\n                    }\n                }\n\n                return audioParam;\n            },\n            cancelScheduledValues(cancelTime: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n                nativeAudioParam.cancelScheduledValues(cancelTime);\n\n                return audioParam;\n            },\n            exponentialRampToValueAtTime(value: number, endTime: number): IAudioParam {\n                // Bug #45: Safari does not throw an error yet.\n                if (value === 0) {\n                    throw new RangeError();\n                }\n\n                // Bug #187: Safari does not throw an error yet.\n                if (!Number.isFinite(endTime) || endTime < 0) {\n                    throw new RangeError();\n                }\n\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n\n                return audioParam;\n            },\n            linearRampToValueAtTime(value: number, endTime: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.linearRampToValueAtTime(value, endTime);\n\n                return audioParam;\n            },\n            setTargetAtTime(target: number, startTime: number, timeConstant: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n\n                return audioParam;\n            },\n            setValueAtTime(value: number, startTime: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createSetValueAutomationEvent(value, startTime));\n                nativeAudioParam.setValueAtTime(value, startTime);\n\n                return audioParam;\n            },\n            setValueCurveAtTime(values: Iterable<number>, startTime: number, duration: number): IAudioParam {\n                // Bug 183: Safari only accepts a Float32Array.\n                const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n                /*\n                 * Bug #152: Safari does not correctly interpolate the values of the curve.\n                 * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the\n                 * existence of the webkitAudioContext is used as a workaround here.\n                 */\n                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                    const endTime = startTime + duration;\n                    const sampleRate = audioNode.context.sampleRate;\n                    const firstSample = Math.ceil(startTime * sampleRate);\n                    const lastSample = Math.floor(endTime * sampleRate);\n                    const numberOfInterpolatedValues = lastSample - firstSample;\n                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n\n                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n                        const theoreticIndex = ((convertedValues.length - 1) / duration) * ((firstSample + i) / sampleRate - startTime);\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n\n                        interpolatedValues[i] =\n                            lowerIndex === upperIndex\n                                ? convertedValues[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] +\n                                  (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n                    }\n\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n\n                    const timeOfLastSample = lastSample / sampleRate;\n\n                    if (timeOfLastSample < endTime) {\n                        setValueAtTimeUntilPossible(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n                    }\n\n                    setValueAtTimeUntilPossible(audioParam, convertedValues[convertedValues.length - 1], endTime);\n                } else {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n                }\n\n                return audioParam;\n            }\n        };\n\n        audioParamStore.set(audioParam, nativeAudioParam);\n        audioParamAudioNodeStore.set(audioParam, audioNode);\n\n        addAudioParamConnections(\n            audioParam,\n            <T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioParamRenderer : null>audioParamRenderer\n        );\n\n        return audioParam;\n    };\n};\n","import { TAudioParamRendererFactory, TNativeAudioParam } from '../types';\n\nexport const createAudioParamRenderer: TAudioParamRendererFactory = (automationEventList) => {\n    return {\n        replay(audioParam: TNativeAudioParam): void {\n            for (const automationEvent of automationEventList) {\n                if (automationEvent.type === 'exponentialRampToValue') {\n                    const { endTime, value } = automationEvent;\n\n                    audioParam.exponentialRampToValueAtTime(value, endTime);\n                } else if (automationEvent.type === 'linearRampToValue') {\n                    const { endTime, value } = automationEvent;\n\n                    audioParam.linearRampToValueAtTime(value, endTime);\n                } else if (automationEvent.type === 'setTarget') {\n                    const { startTime, target, timeConstant } = automationEvent;\n\n                    audioParam.setTargetAtTime(target, startTime, timeConstant);\n                } else if (automationEvent.type === 'setValue') {\n                    const { startTime, value } = automationEvent;\n\n                    audioParam.setValueAtTime(value, startTime);\n                } else if (automationEvent.type === 'setValueCurve') {\n                    const { duration, startTime, values } = automationEvent;\n\n                    audioParam.setValueCurveAtTime(values, startTime, duration);\n                } else {\n                    throw new Error(\"Can't apply an unknown automation.\");\n                }\n            }\n        }\n    };\n};\n","import { TSetValueAtTimeUntilPossibleFunction } from '../types';\n\nexport const setValueAtTimeUntilPossible: TSetValueAtTimeUntilPossibleFunction = (audioParam, value, startTime) => {\n    try {\n        audioParam.setValueAtTime(value, startTime);\n    } catch (err) {\n        if (err.code !== 9) {\n            throw err;\n        }\n\n        setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);\n    }\n};\n","import { IAudioDestinationNode } from '../interfaces';\nimport {\n    TAudioDestinationNodeConstructorFactory,\n    TAudioNodeRenderer,\n    TChannelCountMode,\n    TContext,\n    TNativeAudioDestinationNode\n} from '../types';\n\nexport const createAudioDestinationNodeConstructor: TAudioDestinationNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioDestinationNodeRenderer,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeAudioDestinationNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    renderInputsOfAudioNode\n) => {\n    return class AudioDestinationNode<T extends TContext> extends audioNodeConstructor<T> implements IAudioDestinationNode<T> {\n        private _isNodeOfNativeOfflineAudioContext: boolean;\n\n        private _nativeAudioDestinationNode: TNativeAudioDestinationNode;\n\n        constructor(context: T, channelCount: number) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n            const audioDestinationNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createAudioDestinationNodeRenderer(renderInputsOfAudioNode) : null)\n            );\n\n            super(context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);\n\n            this._isNodeOfNativeOfflineAudioContext = isOffline;\n            this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n        }\n\n        get channelCount(): number {\n            return this._nativeAudioDestinationNode.channelCount;\n        }\n\n        set channelCount(value) {\n            // Bug #52: Chrome, Edge & Safari do not throw an exception at all.\n            // Bug #54: Firefox does throw an IndexSizeError.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n\n            // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n            if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n                throw createIndexSizeError();\n            }\n\n            this._nativeAudioDestinationNode.channelCount = value;\n        }\n\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeAudioDestinationNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            // Bug #53: No browser does throw an exception yet.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n\n            this._nativeAudioDestinationNode.channelCountMode = value;\n        }\n\n        get maxChannelCount(): number {\n            return this._nativeAudioDestinationNode.maxChannelCount;\n        }\n    };\n};\n","import { IAudioDestinationNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport {\n    TAudioDestinationNodeRendererFactory,\n    TNativeAudioDestinationNode,\n    TNativeOfflineAudioContext,\n    TRenderInputsOfAudioNodeFunction\n} from '../types';\n\nexport const createAudioDestinationNodeRenderer: TAudioDestinationNodeRendererFactory = <\n    T extends IMinimalOfflineAudioContext | IOfflineAudioContext\n>(\n    renderInputsOfAudioNode: TRenderInputsOfAudioNodeFunction\n) => {\n    const renderedNativeAudioDestinationNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioDestinationNode>();\n\n    const createAudioDestinationNode = async (proxy: IAudioDestinationNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n\n        renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext, nativeAudioDestinationNode);\n\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);\n\n        return nativeAudioDestinationNode;\n    };\n\n    return {\n        render(\n            proxy: IAudioDestinationNode<T>,\n            nativeOfflineAudioContext: TNativeOfflineAudioContext\n        ): Promise<TNativeAudioDestinationNode> {\n            const renderedNativeAudioDestinationNode = renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);\n\n            if (renderedNativeAudioDestinationNode !== undefined) {\n                return Promise.resolve(renderedNativeAudioDestinationNode);\n            }\n\n            return createAudioDestinationNode(proxy, nativeOfflineAudioContext);\n        }\n    };\n};\n","import { TNativeAudioDestinationNode, TNativeAudioDestinationNodeFactoryFactory, TNativeGainNode } from '../types';\n\nexport const createNativeAudioDestinationNodeFactory: TNativeAudioDestinationNodeFactoryFactory = (\n    createNativeGainNode,\n    overwriteAccessors\n) => {\n    return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeContext.destination;\n\n        // Bug #132: Safari does not have the correct channelCount.\n        if (nativeAudioDestinationNode.channelCount !== channelCount) {\n            try {\n                nativeAudioDestinationNode.channelCount = channelCount;\n            } catch {\n                // Bug #169: Safari throws an error on each attempt to change the channelCount.\n            }\n        }\n\n        // Bug #83: Safari does not have the correct channelCountMode.\n        if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {\n            nativeAudioDestinationNode.channelCountMode = 'explicit';\n        }\n\n        // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n        if (nativeAudioDestinationNode.maxChannelCount === 0) {\n            Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {\n                value: channelCount\n            });\n        }\n\n        // Bug #168: No browser does yet have an AudioDestinationNode with an output.\n        const gainNode = createNativeGainNode(nativeContext, {\n            channelCount,\n            channelCountMode: nativeAudioDestinationNode.channelCountMode,\n            channelInterpretation: nativeAudioDestinationNode.channelInterpretation,\n            gain: 1\n        });\n\n        overwriteAccessors(\n            gainNode,\n            'channelCount',\n            (get) => () => get.call(gainNode),\n            (set) => (value) => {\n                set.call(gainNode, value);\n\n                try {\n                    nativeAudioDestinationNode.channelCount = value;\n                } catch (err) {\n                    // Bug #169: Safari throws an error on each attempt to change the channelCount.\n                    if (value > nativeAudioDestinationNode.maxChannelCount) {\n                        throw err;\n                    }\n                }\n            }\n        );\n\n        overwriteAccessors(\n            gainNode,\n            'channelCountMode',\n            (get) => () => get.call(gainNode),\n            (set) => (value) => {\n                set.call(gainNode, value);\n                nativeAudioDestinationNode.channelCountMode = value;\n            }\n        );\n\n        overwriteAccessors(\n            gainNode,\n            'channelInterpretation',\n            (get) => () => get.call(gainNode),\n            (set) => (value) => {\n                set.call(gainNode, value);\n                nativeAudioDestinationNode.channelInterpretation = value;\n            }\n        );\n\n        Object.defineProperty(gainNode, 'maxChannelCount', {\n            get: () => nativeAudioDestinationNode.maxChannelCount\n        });\n\n        // @todo This should be disconnected when the context is closed.\n        gainNode.connect(nativeAudioDestinationNode);\n\n        return <{ maxChannelCount: TNativeAudioDestinationNode['maxChannelCount'] } & TNativeGainNode>gainNode;\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IBiquadFilterNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TBiquadFilterNodeRendererFactoryFactory, TNativeBiquadFilterNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createBiquadFilterNodeRendererFactory: TBiquadFilterNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeBiquadFilterNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeBiquadFilterNodes = new WeakMap<TNativeOfflineAudioContext, TNativeBiquadFilterNode>();\n\n        const createBiquadFilterNode = async (proxy: IBiquadFilterNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeBiquadFilterNode = getNativeAudioNode<T, TNativeBiquadFilterNode>(proxy);\n\n            /*\n             * If the initially used nativeBiquadFilterNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);\n\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                const options = {\n                    Q: nativeBiquadFilterNode.Q.value,\n                    channelCount: nativeBiquadFilterNode.channelCount,\n                    channelCountMode: nativeBiquadFilterNode.channelCountMode,\n                    channelInterpretation: nativeBiquadFilterNode.channelInterpretation,\n                    detune: nativeBiquadFilterNode.detune.value,\n                    frequency: nativeBiquadFilterNode.frequency.value,\n                    gain: nativeBiquadFilterNode.gain.value,\n                    type: nativeBiquadFilterNode.type\n                };\n\n                nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);\n\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode);\n\n            return nativeBiquadFilterNode;\n        };\n\n        return {\n            render(proxy: IBiquadFilterNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeBiquadFilterNode> {\n                const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeBiquadFilterNode !== undefined) {\n                    return Promise.resolve(renderedNativeBiquadFilterNode);\n                }\n\n                return createBiquadFilterNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { TSetAudioNodeTailTimeFactory } from '../types';\n\nexport const createSetAudioNodeTailTime: TSetAudioNodeTailTimeFactory = (audioNodeTailTimeStore) => {\n    return (audioNode, tailTime) => audioNodeTailTimeStore.set(audioNode, tailTime);\n};\n","import { TMonitorConnectionsFactory, TNativeAudioNode, TNativeAudioParam } from '../types';\n\nexport const createMonitorConnections: TMonitorConnectionsFactory = (insertElementInSet, isNativeAudioNode) => {\n    return (nativeAudioNode, whenConnected, whenDisconnected) => {\n        const connections = new Set<[TNativeAudioNode, number, number] | [TNativeAudioParam, number]>();\n\n        nativeAudioNode.connect = <TNativeAudioNode['connect']>((connect) => {\n            // tslint:disable-next-line:invalid-void no-inferrable-types\n            return (destination: TNativeAudioNode | TNativeAudioParam, output = 0, input: number = 0): void | TNativeAudioNode => {\n                const wasDisconnected = connections.size === 0;\n\n                if (isNativeAudioNode(destination)) {\n                    // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                    (<(destination: TNativeAudioNode, output?: number, input?: number) => TNativeAudioNode>connect).call(\n                        nativeAudioNode,\n                        destination,\n                        output,\n                        input\n                    );\n\n                    insertElementInSet(\n                        connections,\n                        [destination, output, input],\n                        (connection) => connection[0] === destination && connection[1] === output && connection[2] === input,\n                        true\n                    );\n\n                    if (wasDisconnected) {\n                        whenConnected();\n                    }\n\n                    return destination;\n                }\n\n                connect.call(nativeAudioNode, destination, output);\n\n                insertElementInSet(\n                    connections,\n                    [destination, output],\n                    (connection) => connection[0] === destination && connection[1] === output,\n                    true\n                );\n\n                if (wasDisconnected) {\n                    whenConnected();\n                }\n\n                return;\n            };\n        })(nativeAudioNode.connect);\n\n        nativeAudioNode.disconnect = ((disconnect) => {\n            return (destinationOrOutput?: number | TNativeAudioNode | TNativeAudioParam, output?: number, input?: number): void => {\n                const wasConnected = connections.size > 0;\n\n                if (destinationOrOutput === undefined) {\n                    disconnect.apply(nativeAudioNode);\n\n                    connections.clear();\n                } else if (typeof destinationOrOutput === 'number') {\n                    // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n                    (<(output: number) => void>disconnect).call(nativeAudioNode, destinationOrOutput);\n\n                    for (const connection of connections) {\n                        if (connection[1] === destinationOrOutput) {\n                            connections.delete(connection);\n                        }\n                    }\n                } else {\n                    if (isNativeAudioNode(destinationOrOutput)) {\n                        // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                        (<(destination: TNativeAudioNode, output?: number, input?: number) => void>disconnect).call(\n                            nativeAudioNode,\n                            destinationOrOutput,\n                            output,\n                            input\n                        );\n                    } else {\n                        // @todo TypeScript cannot infer the overloaded signature with 2 arguments yet.\n                        (<(destination: TNativeAudioParam, output?: number) => void>disconnect).call(\n                            nativeAudioNode,\n                            destinationOrOutput,\n                            output\n                        );\n                    }\n\n                    for (const connection of connections) {\n                        if (\n                            connection[0] === destinationOrOutput &&\n                            (output === undefined || connection[1] === output) &&\n                            (input === undefined || connection[2] === input)\n                        ) {\n                            connections.delete(connection);\n                        }\n                    }\n                }\n\n                const isDisconnected = connections.size === 0;\n\n                if (wasConnected && isDisconnected) {\n                    whenDisconnected();\n                }\n            };\n        })(nativeAudioNode.disconnect);\n\n        return nativeAudioNode;\n    };\n};\n","import { TWrapChannelMergerNodeFactory } from '../types';\n\nexport const createWrapChannelMergerNode: TWrapChannelMergerNodeFactory = (createInvalidStateError, monitorConnections) => {\n    return (nativeContext, channelMergerNode) => {\n        // Bug #15: Safari does not return the default properties.\n        channelMergerNode.channelCount = 1;\n        channelMergerNode.channelCountMode = 'explicit';\n\n        // Bug #16: Safari does not throw an error when setting a different channelCount or channelCountMode.\n        Object.defineProperty(channelMergerNode, 'channelCount', {\n            get: () => 1,\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n\n        Object.defineProperty(channelMergerNode, 'channelCountMode', {\n            get: () => 'explicit',\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n\n        // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n        const audioBufferSourceNode = nativeContext.createBufferSource();\n\n        const whenConnected = () => {\n            const length = channelMergerNode.numberOfInputs;\n\n            for (let i = 0; i < length; i += 1) {\n                audioBufferSourceNode.connect(channelMergerNode, 0, i);\n            }\n        };\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);\n\n        monitorConnections(channelMergerNode, whenConnected, whenDisconnected);\n    };\n};\n","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeChannelMergerNodeFactoryFactory } from '../types';\n\nexport const createNativeChannelMergerNodeFactory: TNativeChannelMergerNodeFactoryFactory = (\n    nativeAudioContextConstructor,\n    wrapChannelMergerNode\n) => {\n    return (nativeContext, options) => {\n        const nativeChannelMergerNode = nativeContext.createChannelMerger(options.numberOfInputs);\n\n        /*\n         * Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here.\n         */\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n            wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n\n        assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n\n        return nativeChannelMergerNode;\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAudioNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TChannelMergerNodeRendererFactoryFactory, TNativeAudioNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createChannelMergerNodeRendererFactory: TChannelMergerNodeRendererFactoryFactory = (\n    createNativeChannelMergerNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioNode>();\n\n        const createAudioNode = async (proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioNode = getNativeAudioNode<T, TNativeAudioNode>(proxy);\n\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfInputs: nativeAudioNode.numberOfInputs\n                };\n\n                nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n\n            return nativeAudioNode;\n        };\n\n        return {\n            render(proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeAudioNode> {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAudioNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TChannelSplitterNodeRendererFactoryFactory, TNativeAudioNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createChannelSplitterNodeRendererFactory: TChannelSplitterNodeRendererFactoryFactory = (\n    createNativeChannelSplitterNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioNode>();\n\n        const createAudioNode = async (proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioNode = getNativeAudioNode<T, TNativeAudioNode>(proxy);\n\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfOutputs: nativeAudioNode.numberOfOutputs\n                };\n\n                nativeAudioNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n\n            return nativeAudioNode;\n        };\n\n        return {\n            render(proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeAudioNode> {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { TSanitizeChannelSplitterOptionsFunction } from '../types';\n\nexport const sanitizeChannelSplitterOptions: TSanitizeChannelSplitterOptionsFunction = (options) => {\n    return { ...options, channelCount: options.numberOfOutputs };\n};\n","import { interceptConnections } from '../helpers/intercept-connections';\nimport {\n    TNativeAudioBufferSourceNode,\n    TNativeAudioNode,\n    TNativeConstantSourceNode,\n    TNativeConstantSourceNodeFakerFactoryFactory\n} from '../types';\n\nexport const createNativeConstantSourceNodeFakerFactory: TNativeConstantSourceNodeFakerFactoryFactory = (\n    addSilentConnection,\n    createNativeAudioBufferSourceNode,\n    createNativeGainNode,\n    monitorConnections\n) => {\n    return (nativeContext, { offset, ...audioNodeOptions }) => {\n        const audioBuffer = nativeContext.createBuffer(1, 2, 44100);\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: offset });\n\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        const channelData = audioBuffer.getChannelData(0);\n\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n\n        const nativeConstantSourceNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                gainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeConstantSourceNode['channelCountMode'] {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeConstantSourceNode['channelInterpretation'] {\n                return gainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                gainNode.channelInterpretation = value;\n            },\n            get context(): TNativeConstantSourceNode['context'] {\n                return gainNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [];\n            },\n            get numberOfInputs(): number {\n                return audioBufferSourceNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return gainNode.numberOfOutputs;\n            },\n            get offset(): TNativeConstantSourceNode['offset'] {\n                return gainNode.gain;\n            },\n            get onended(): TNativeConstantSourceNode['onended'] {\n                return audioBufferSourceNode.onended;\n            },\n            set onended(value) {\n                audioBufferSourceNode.onended = <TNativeAudioBufferSourceNode['onended']>value;\n            },\n            addEventListener(...args: any[]): void {\n                return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return audioBufferSourceNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n            },\n            start(when = 0): void {\n                audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n            },\n            stop(when = 0): void {\n                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n            }\n        };\n\n        const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);\n\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, audioBufferSourceNode);\n\n        return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n    };\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nimport { TNativeConstantSourceNodeFactoryFactory } from '../types';\n\nexport const createNativeConstantSourceNodeFactory: TNativeConstantSourceNodeFactoryFactory = (\n    addSilentConnection,\n    cacheTestResult,\n    createNativeConstantSourceNodeFaker,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport\n) => {\n    return (nativeContext, options) => {\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeContext.createConstantSource === undefined) {\n            return createNativeConstantSourceNodeFaker(nativeContext, options);\n        }\n\n        const nativeConstantSourceNode = nativeContext.createConstantSource();\n\n        assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset');\n\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n        }\n\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n        }\n\n        // Bug #175: Safari will not fire an ended event if the ConstantSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeConstantSourceNode);\n\n        return nativeConstantSourceNode;\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IConstantSourceNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TConstantSourceNodeRendererFactoryFactory, TNativeConstantSourceNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createConstantSourceNodeRendererFactory: TConstantSourceNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeConstantSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeConstantSourceNodes = new WeakMap<TNativeOfflineAudioContext, TNativeConstantSourceNode>();\n\n        let start: null | number = null;\n        let stop: null | number = null;\n\n        const createConstantSourceNode = async (proxy: IConstantSourceNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeConstantSourceNode = getNativeAudioNode<T, TNativeConstantSourceNode>(proxy);\n\n            /*\n             * If the initially used nativeConstantSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);\n\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeConstantSourceNode.channelCount,\n                    channelCountMode: nativeConstantSourceNode.channelCountMode,\n                    channelInterpretation: nativeConstantSourceNode.channelInterpretation,\n                    offset: nativeConstantSourceNode.offset.value\n                };\n\n                nativeConstantSourceNode = createNativeConstantSourceNode(nativeOfflineAudioContext, options);\n\n                if (start !== null) {\n                    nativeConstantSourceNode.start(start);\n                }\n\n                if (stop !== null) {\n                    nativeConstantSourceNode.stop(stop);\n                }\n            }\n\n            renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);\n\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConstantSourceNode);\n\n            return nativeConstantSourceNode;\n        };\n\n        return {\n            set start(value: number) {\n                start = value;\n            },\n            set stop(value: number) {\n                stop = value;\n            },\n            render(\n                proxy: IConstantSourceNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeConstantSourceNode> {\n                const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeConstantSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeConstantSourceNode);\n                }\n\n                return createConstantSourceNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeConvolverNodeFactoryFactory } from '../types';\n\nexport const createNativeConvolverNodeFactory: TNativeConvolverNodeFactoryFactory = (createNotSupportedError, overwriteAccessors) => {\n    return (nativeContext, options) => {\n        const nativeConvolverNode = nativeContext.createConvolver();\n\n        assignNativeAudioNodeOptions(nativeConvolverNode, options);\n\n        // The normalize property needs to be set before setting the buffer.\n        if (options.disableNormalization === nativeConvolverNode.normalize) {\n            nativeConvolverNode.normalize = !options.disableNormalization;\n        }\n\n        assignNativeAudioNodeOption(nativeConvolverNode, options, 'buffer');\n\n        // Bug #113: Safari does allow to set the channelCount to a value larger than 2.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n\n        overwriteAccessors(\n            nativeConvolverNode,\n            'channelCount',\n            (get) => () => get.call(nativeConvolverNode),\n            (set) => (value) => {\n                if (value > 2) {\n                    throw createNotSupportedError();\n                }\n\n                return set.call(nativeConvolverNode, value);\n            }\n        );\n\n        // Bug #114: Safari allows to set the channelCountMode to 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        overwriteAccessors(\n            nativeConvolverNode,\n            'channelCountMode',\n            (get) => () => get.call(nativeConvolverNode),\n            (set) => (value) => {\n                if (value === 'max') {\n                    throw createNotSupportedError();\n                }\n\n                return set.call(nativeConvolverNode, value);\n            }\n        );\n\n        return nativeConvolverNode;\n    };\n};\n","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IConvolverNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TConvolverNodeRendererFactoryFactory, TNativeConvolverNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createConvolverNodeRendererFactory: TConvolverNodeRendererFactoryFactory = (\n    createNativeConvolverNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeConvolverNodes = new WeakMap<TNativeOfflineAudioContext, TNativeConvolverNode>();\n\n        const createConvolverNode = async (proxy: IConvolverNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeConvolverNode = getNativeAudioNode<T, TNativeConvolverNode>(proxy);\n\n            // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);\n\n            if (!nativeConvolverNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeConvolverNode.buffer,\n                    channelCount: nativeConvolverNode.channelCount,\n                    channelCountMode: nativeConvolverNode.channelCountMode,\n                    channelInterpretation: nativeConvolverNode.channelInterpretation,\n                    disableNormalization: !nativeConvolverNode.normalize\n                };\n\n                nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);\n\n            if (isNativeAudioNodeFaker(nativeConvolverNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode);\n            }\n\n            return nativeConvolverNode;\n        };\n\n        return {\n            render(proxy: IConvolverNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeConvolverNode> {\n                const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeConvolverNode !== undefined) {\n                    return Promise.resolve(renderedNativeConvolverNode);\n                }\n\n                return createConvolverNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IDelayNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TDelayNodeRendererFactoryFactory, TNativeDelayNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createDelayNodeRendererFactory: TDelayNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeDelayNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(maxDelayTime: number) => {\n        const renderedNativeDelayNodes = new WeakMap<TNativeOfflineAudioContext, TNativeDelayNode>();\n\n        const createDelayNode = async (proxy: IDelayNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeDelayNode = getNativeAudioNode<T, TNativeDelayNode>(proxy);\n\n            // If the initially used nativeDelayNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);\n\n            if (!nativeDelayNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeDelayNode.channelCount,\n                    channelCountMode: nativeDelayNode.channelCountMode,\n                    channelInterpretation: nativeDelayNode.channelInterpretation,\n                    delayTime: nativeDelayNode.delayTime.value,\n                    maxDelayTime\n                };\n\n                nativeDelayNode = createNativeDelayNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);\n\n            if (!nativeDelayNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDelayNode);\n\n            return nativeDelayNode;\n        };\n\n        return {\n            render(proxy: IDelayNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeDelayNode> {\n                const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeDelayNode !== undefined) {\n                    return Promise.resolve(renderedNativeDelayNode);\n                }\n\n                return createDelayNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeDynamicsCompressorNodeFactoryFactory } from '../types';\n\nexport const createNativeDynamicsCompressorNodeFactory: TNativeDynamicsCompressorNodeFactoryFactory = (createNotSupportedError) => {\n    return (nativeContext, options) => {\n        const nativeDynamicsCompressorNode = nativeContext.createDynamicsCompressor();\n\n        assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options);\n\n        // Bug #108: Safari allows a channelCount of three and above.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n\n        // Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'attack');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'knee');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'ratio');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'release');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'threshold');\n\n        return nativeDynamicsCompressorNode;\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IDynamicsCompressorNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TDynamicsCompressorNodeRendererFactoryFactory, TNativeDynamicsCompressorNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createDynamicsCompressorNodeRendererFactory: TDynamicsCompressorNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeDynamicsCompressorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeDynamicsCompressorNodes = new WeakMap<TNativeOfflineAudioContext, TNativeDynamicsCompressorNode>();\n\n        const createDynamicsCompressorNode = async (\n            proxy: IDynamicsCompressorNode<T>,\n            nativeOfflineAudioContext: TNativeOfflineAudioContext\n        ) => {\n            let nativeDynamicsCompressorNode = getNativeAudioNode<T, TNativeDynamicsCompressorNode>(proxy);\n\n            /*\n             * If the initially used nativeDynamicsCompressorNode was not constructed on the same OfflineAudioContext it needs to be\n             * created again.\n             */\n            const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);\n\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                const options = {\n                    attack: nativeDynamicsCompressorNode.attack.value,\n                    channelCount: nativeDynamicsCompressorNode.channelCount,\n                    channelCountMode: nativeDynamicsCompressorNode.channelCountMode,\n                    channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,\n                    knee: nativeDynamicsCompressorNode.knee.value,\n                    ratio: nativeDynamicsCompressorNode.ratio.value,\n                    release: nativeDynamicsCompressorNode.release.value,\n                    threshold: nativeDynamicsCompressorNode.threshold.value\n                };\n\n                nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                await renderAutomation(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                await renderAutomation(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                await renderAutomation(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                await renderAutomation(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n\n            return nativeDynamicsCompressorNode;\n        };\n\n        return {\n            render(\n                proxy: IDynamicsCompressorNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeDynamicsCompressorNode> {\n                const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeDynamicsCompressorNode !== undefined) {\n                    return Promise.resolve(renderedNativeDynamicsCompressorNode);\n                }\n\n                return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IGainNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TGainNodeRendererFactoryFactory, TNativeGainNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createGainNodeRendererFactory: TGainNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeGainNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeGainNodes = new WeakMap<TNativeOfflineAudioContext, TNativeGainNode>();\n\n        const createGainNode = async (proxy: IGainNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeGainNode = getNativeAudioNode<T, TNativeGainNode>(proxy);\n\n            // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);\n\n            if (!nativeGainNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeGainNode.channelCount,\n                    channelCountMode: nativeGainNode.channelCountMode,\n                    channelInterpretation: nativeGainNode.channelInterpretation,\n                    gain: nativeGainNode.gain.value\n                };\n\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);\n\n            if (!nativeGainNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode);\n\n            return nativeGainNode;\n        };\n\n        return {\n            render(proxy: IGainNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeGainNode> {\n                const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNode);\n                }\n\n                return createGainNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IOfflineAudioCompletionEvent } from '../interfaces';\nimport { TNativeAudioBuffer, TRenderNativeOfflineAudioContextFactory } from '../types';\n\nexport const createRenderNativeOfflineAudioContext: TRenderNativeOfflineAudioContextFactory = (\n    cacheTestResult,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    testOfflineAudioContextCurrentTimeSupport\n) => {\n    return (nativeOfflineAudioContext) => {\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n            // Bug #158: Chrome and Edge do not advance currentTime if it is not accessed while rendering the audio.\n            return Promise.resolve(\n                cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)\n            ).then((isOfflineAudioContextCurrentTimeSupported) => {\n                if (!isOfflineAudioContextCurrentTimeSupported) {\n                    const scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);\n\n                    nativeOfflineAudioContext.oncomplete = () => {\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        scriptProcessorNode.disconnect();\n                    };\n                    scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime; // tslint:disable-line:deprecation\n\n                    scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n                }\n\n                return nativeOfflineAudioContext.startRendering();\n            });\n        }\n\n        return new Promise<TNativeAudioBuffer>((resolve) => {\n            // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n            const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                gain: 0\n            });\n\n            nativeOfflineAudioContext.oncomplete = (event: IOfflineAudioCompletionEvent) => {\n                gainNode.disconnect();\n\n                resolve(event.renderedBuffer);\n            };\n\n            gainNode.connect(nativeOfflineAudioContext.destination);\n\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n","import { TTestOfflineAudioContextCurrentTimeSupportFactory } from '../types';\n\nexport const createTestOfflineAudioContextCurrentTimeSupport: TTestOfflineAudioContextCurrentTimeSupportFactory = (\n    createNativeGainNode,\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n\n        // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n        const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            nativeOfflineAudioContext.oncomplete = () => {\n                gainNode.disconnect();\n\n                resolve(nativeOfflineAudioContext.currentTime !== 0);\n            };\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeIIRFilterNodeFactoryFactory } from '../types';\n\nexport const createNativeIIRFilterNodeFactory: TNativeIIRFilterNodeFactoryFactory = (createNativeIIRFilterNodeFaker) => {\n    return (nativeContext, baseLatency, options) => {\n        // Bug #9: Safari does not support IIRFilterNodes.\n        if (nativeContext.createIIRFilter === undefined) {\n            return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);\n        }\n\n        // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n        const nativeIIRFilterNode = nativeContext.createIIRFilter(<number[]>options.feedforward, <number[]>options.feedback);\n\n        assignNativeAudioNodeOptions(nativeIIRFilterNode, options);\n\n        return nativeIIRFilterNode;\n    };\n};\n","import { createInvalidAccessError } from '../factories/invalid-access-error';\nimport { TNativeIIRFilterNode } from '../types';\n\nexport const wrapIIRFilterNodeGetFrequencyResponseMethod = (nativeIIRFilterNode: TNativeIIRFilterNode): void => {\n    nativeIIRFilterNode.getFrequencyResponse = ((getFrequencyResponse) => {\n        return (frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array) => {\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                throw createInvalidAccessError();\n            }\n\n            return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);\n        };\n    })(nativeIIRFilterNode.getFrequencyResponse);\n};\n","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam } from '../interfaces';\nimport { TAudioListenerFactoryFactory } from '../types';\n\nexport const createAudioListenerFactory: TAudioListenerFactoryFactory = (\n    createAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    getFirstSample,\n    isNativeOfflineAudioContext,\n    overwriteAccessors\n) => {\n    return (context, nativeContext) => {\n        const nativeListener = nativeContext.listener;\n\n        // Bug #117: Only Chrome & Edge support the new interface already.\n        const createFakeAudioParams = () => {\n            const buffer = new Float32Array(1);\n            const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: 9\n            });\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            let isScriptProcessorNodeCreated = false;\n            let lastOrientation: [number, number, number, number, number, number] = [0, 0, -1, 0, 1, 0];\n            let lastPosition: [number, number, number] = [0, 0, 0];\n\n            const createScriptProcessorNode = () => {\n                if (isScriptProcessorNodeCreated) {\n                    return;\n                }\n\n                isScriptProcessorNodeCreated = true;\n\n                const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);\n\n                // tslint:disable-next-line:deprecation\n                scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n                    const orientation: [number, number, number, number, number, number] = [\n                        getFirstSample(inputBuffer, buffer, 0),\n                        getFirstSample(inputBuffer, buffer, 1),\n                        getFirstSample(inputBuffer, buffer, 2),\n                        getFirstSample(inputBuffer, buffer, 3),\n                        getFirstSample(inputBuffer, buffer, 4),\n                        getFirstSample(inputBuffer, buffer, 5)\n                    ];\n\n                    if (orientation.some((value, index) => value !== lastOrientation[index])) {\n                        nativeListener.setOrientation(...orientation); // tslint:disable-line:deprecation\n\n                        lastOrientation = orientation;\n                    }\n\n                    const positon: [number, number, number] = [\n                        getFirstSample(inputBuffer, buffer, 6),\n                        getFirstSample(inputBuffer, buffer, 7),\n                        getFirstSample(inputBuffer, buffer, 8)\n                    ];\n\n                    if (positon.some((value, index) => value !== lastPosition[index])) {\n                        nativeListener.setPosition(...positon); // tslint:disable-line:deprecation\n\n                        lastPosition = positon;\n                    }\n                };\n\n                channelMergerNode.connect(scriptProcessorNode);\n            };\n            const createSetOrientation = (index: number) => (value: number) => {\n                if (value !== lastOrientation[index]) {\n                    lastOrientation[index] = value;\n\n                    nativeListener.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n                }\n            };\n            const createSetPosition = (index: number) => (value: number) => {\n                if (value !== lastPosition[index]) {\n                    lastPosition[index] = value;\n\n                    nativeListener.setPosition(...lastPosition); // tslint:disable-line:deprecation\n                }\n            };\n            const createFakeAudioParam = (input: number, initialValue: number, setValue: (value: number) => void) => {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: initialValue\n                });\n\n                constantSourceNode.connect(channelMergerNode, 0, input);\n\n                // @todo This should be stopped when the context is closed.\n                constantSourceNode.start();\n\n                Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n                    get(): number {\n                        return initialValue;\n                    }\n                });\n\n                /*\n                 * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and\n                 * minValue for GainNodes.\n                 */\n                const audioParam = createAudioParam(\n                    <any>{ context },\n                    isOffline,\n                    constantSourceNode.offset,\n                    MOST_POSITIVE_SINGLE_FLOAT,\n                    MOST_NEGATIVE_SINGLE_FLOAT\n                );\n\n                overwriteAccessors(\n                    audioParam,\n                    'value',\n                    (get) => () => get.call(audioParam),\n                    (set) => (value) => {\n                        try {\n                            set.call(audioParam, value);\n                        } catch (err) {\n                            if (err.code !== 9) {\n                                throw err;\n                            }\n                        }\n\n                        createScriptProcessorNode();\n\n                        if (isOffline) {\n                            // Bug #117: Using setOrientation() and setPosition() doesn't work with an OfflineAudioContext.\n                            setValue(value);\n                        }\n                    }\n                );\n\n                audioParam.cancelAndHoldAtTime = ((cancelAndHoldAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['cancelAndHoldAtTime']>) => {\n                        const value = cancelAndHoldAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.cancelAndHoldAtTime);\n                audioParam.cancelScheduledValues = ((cancelScheduledValues) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['cancelScheduledValues']>) => {\n                        const value = cancelScheduledValues.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.cancelScheduledValues);\n                audioParam.exponentialRampToValueAtTime = ((exponentialRampToValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['exponentialRampToValueAtTime']>) => {\n                        const value = exponentialRampToValueAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.exponentialRampToValueAtTime);\n                audioParam.linearRampToValueAtTime = ((linearRampToValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['linearRampToValueAtTime']>) => {\n                        const value = linearRampToValueAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.linearRampToValueAtTime);\n                audioParam.setTargetAtTime = ((setTargetAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['setTargetAtTime']>) => {\n                        const value = setTargetAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.setTargetAtTime);\n                audioParam.setValueAtTime = ((setValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['setValueAtTime']>) => {\n                        const value = setValueAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.setValueAtTime);\n                audioParam.setValueCurveAtTime = ((setValueCurveAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['setValueCurveAtTime']>) => {\n                        const value = setValueCurveAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.setValueCurveAtTime);\n\n                return audioParam;\n            };\n\n            return {\n                forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),\n                forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),\n                forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),\n                positionX: createFakeAudioParam(6, 0, createSetPosition(0)),\n                positionY: createFakeAudioParam(7, 0, createSetPosition(1)),\n                positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),\n                upX: createFakeAudioParam(3, 0, createSetOrientation(3)),\n                upY: createFakeAudioParam(4, 1, createSetOrientation(4)),\n                upZ: createFakeAudioParam(5, 0, createSetOrientation(5))\n            };\n        };\n\n        const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } =\n            nativeListener.forwardX === undefined ? createFakeAudioParams() : nativeListener;\n\n        return {\n            get forwardX(): IAudioParam {\n                return forwardX;\n            },\n            get forwardY(): IAudioParam {\n                return forwardY;\n            },\n            get forwardZ(): IAudioParam {\n                return forwardZ;\n            },\n            get positionX(): IAudioParam {\n                return positionX;\n            },\n            get positionY(): IAudioParam {\n                return positionY;\n            },\n            get positionZ(): IAudioParam {\n                return positionZ;\n            },\n            get upX(): IAudioParam {\n                return upX;\n            },\n            get upY(): IAudioParam {\n                return upY;\n            },\n            get upZ(): IAudioParam {\n                return upZ;\n            }\n        };\n    };\n};\n","import { CONTEXT_STORE } from '../globals';\nimport { IAudioDestinationNode, IAudioListener, IMinimalBaseAudioContext, IMinimalBaseAudioContextEventMap } from '../interfaces';\nimport { TAudioContextState, TContext, TEventHandler, TMinimalBaseAudioContextConstructorFactory, TNativeContext } from '../types';\n\nexport const createMinimalBaseAudioContextConstructor: TMinimalBaseAudioContextConstructorFactory = (\n    audioDestinationNodeConstructor,\n    createAudioListener,\n    eventTargetConstructor,\n    isNativeOfflineAudioContext,\n    unrenderedAudioWorkletNodeStore,\n    wrapEventListener\n) => {\n    return class MinimalBaseAudioContext<T extends TContext>\n        extends eventTargetConstructor<IMinimalBaseAudioContextEventMap>\n        implements IMinimalBaseAudioContext<T>\n    {\n        private _destination: IAudioDestinationNode<T>;\n\n        private _listener: IAudioListener;\n\n        private _onstatechange: null | TEventHandler<T>;\n\n        constructor(private _nativeContext: TNativeContext, numberOfChannels: number) {\n            super(_nativeContext);\n\n            CONTEXT_STORE.set(<T>(<unknown>this), _nativeContext);\n\n            if (isNativeOfflineAudioContext(_nativeContext)) {\n                unrenderedAudioWorkletNodeStore.set(_nativeContext, new Set());\n            }\n\n            this._destination = new audioDestinationNodeConstructor(<T>(<unknown>this), numberOfChannels);\n            this._listener = createAudioListener(<T>(<unknown>this), _nativeContext);\n            this._onstatechange = null;\n        }\n\n        get currentTime(): number {\n            return this._nativeContext.currentTime;\n        }\n\n        get destination(): IAudioDestinationNode<T> {\n            return this._destination;\n        }\n\n        get listener(): IAudioListener {\n            return this._listener;\n        }\n\n        get onstatechange(): null | TEventHandler<T> {\n            return this._onstatechange;\n        }\n\n        set onstatechange(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeContext.onstatechange = wrappedListener;\n\n            const nativeOnStateChange = this._nativeContext.onstatechange;\n\n            this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;\n        }\n\n        get sampleRate(): number {\n            return this._nativeContext.sampleRate;\n        }\n\n        get state(): TAudioContextState {\n            return this._nativeContext.state;\n        }\n    };\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nimport { TNativeOscillatorNodeFactoryFactory } from '../types';\n\nexport const createNativeOscillatorNodeFactory: TNativeOscillatorNodeFactoryFactory = (\n    addSilentConnection,\n    cacheTestResult,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n) => {\n    return (nativeContext, options) => {\n        const nativeOscillatorNode = nativeContext.createOscillator();\n\n        assignNativeAudioNodeOptions(nativeOscillatorNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'frequency');\n\n        if (options.periodicWave !== undefined) {\n            nativeOscillatorNode.setPeriodicWave(options.periodicWave);\n        } else {\n            assignNativeAudioNodeOption(nativeOscillatorNode, options, 'type');\n        }\n\n        // Bug #44: Only Chrome & Edge throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);\n        }\n\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () =>\n                testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode, nativeContext);\n        }\n\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);\n        }\n\n        // Bug #175: Safari will not fire an ended event if the OscillatorNode is unconnected.\n        addSilentConnection(nativeContext, nativeOscillatorNode);\n\n        return nativeOscillatorNode;\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, IOfflineAudioContext, IOscillatorNode, IPeriodicWave } from '../interfaces';\nimport { TNativeOfflineAudioContext, TNativeOscillatorNode, TOscillatorNodeRendererFactoryFactory } from '../types';\n\nexport const createOscillatorNodeRendererFactory: TOscillatorNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeOscillatorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeOscillatorNodes = new WeakMap<TNativeOfflineAudioContext, TNativeOscillatorNode>();\n\n        let periodicWave: null | IPeriodicWave = null;\n        let start: null | number = null;\n        let stop: null | number = null;\n\n        const createOscillatorNode = async (proxy: IOscillatorNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeOscillatorNode = getNativeAudioNode<T, TNativeOscillatorNode>(proxy);\n\n            // If the initially used nativeOscillatorNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);\n\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeOscillatorNode.channelCount,\n                    channelCountMode: nativeOscillatorNode.channelCountMode,\n                    channelInterpretation: nativeOscillatorNode.channelInterpretation,\n                    detune: nativeOscillatorNode.detune.value,\n                    frequency: nativeOscillatorNode.frequency.value,\n                    periodicWave: periodicWave === null ? undefined : periodicWave,\n                    type: nativeOscillatorNode.type\n                };\n\n                nativeOscillatorNode = createNativeOscillatorNode(nativeOfflineAudioContext, options);\n\n                if (start !== null) {\n                    nativeOscillatorNode.start(start);\n                }\n\n                if (stop !== null) {\n                    nativeOscillatorNode.stop(stop);\n                }\n            }\n\n            renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);\n\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeOscillatorNode);\n\n            return nativeOscillatorNode;\n        };\n\n        return {\n            set periodicWave(value: null | IPeriodicWave) {\n                periodicWave = value;\n            },\n            set start(value: number) {\n                start = value;\n            },\n            set stop(value: number) {\n                stop = value;\n            },\n            render(proxy: IOscillatorNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeOscillatorNode> {\n                const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeOscillatorNode !== undefined) {\n                    return Promise.resolve(renderedNativeOscillatorNode);\n                }\n\n                return createOscillatorNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { TConnectedNativeAudioBufferSourceNodeFactoryFactory } from '../types';\n\nexport const createConnectedNativeAudioBufferSourceNodeFactory: TConnectedNativeAudioBufferSourceNodeFactoryFactory = (\n    createNativeAudioBufferSourceNode\n) => {\n    return (nativeContext, nativeAudioNode) => {\n        const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 2, 44100);\n\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        nativeAudioBufferSourceNode.loop = true;\n\n        nativeAudioBufferSourceNode.connect(nativeAudioNode);\n        nativeAudioBufferSourceNode.start();\n\n        return () => {\n            nativeAudioBufferSourceNode.stop();\n            nativeAudioBufferSourceNode.disconnect(nativeAudioNode);\n        };\n    };\n};\n","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nimport { TNativeAudioNode, TNativeWaveShaperNode, TNativeWaveShaperNodeFakerFactoryFactory } from '../types';\n\nexport const createNativeWaveShaperNodeFakerFactory: TNativeWaveShaperNodeFakerFactoryFactory = (\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeGainNode,\n    isDCCurve,\n    monitorConnections\n) => {\n    return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {\n        const negativeWaveShaperNode = nativeContext.createWaveShaper();\n        const positiveWaveShaperNode = nativeContext.createWaveShaper();\n\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n\n        let disconnectNativeAudioBufferSourceNode: null | (() => void) = null;\n        let isConnected = false;\n        let unmodifiedCurve: null | TNativeWaveShaperNode['curve'] = null;\n\n        const nativeWaveShaperNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return negativeWaveShaperNode.channelCount;\n            },\n            set channelCount(value) {\n                inputGainNode.channelCount = value;\n                invertGainNode.channelCount = value;\n                negativeWaveShaperNode.channelCount = value;\n                outputGainNode.channelCount = value;\n                positiveWaveShaperNode.channelCount = value;\n                revertGainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeWaveShaperNode['channelCountMode'] {\n                return negativeWaveShaperNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                inputGainNode.channelCountMode = value;\n                invertGainNode.channelCountMode = value;\n                negativeWaveShaperNode.channelCountMode = value;\n                outputGainNode.channelCountMode = value;\n                positiveWaveShaperNode.channelCountMode = value;\n                revertGainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeWaveShaperNode['channelInterpretation'] {\n                return negativeWaveShaperNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                invertGainNode.channelInterpretation = value;\n                negativeWaveShaperNode.channelInterpretation = value;\n                outputGainNode.channelInterpretation = value;\n                positiveWaveShaperNode.channelInterpretation = value;\n                revertGainNode.channelInterpretation = value;\n            },\n            get context(): TNativeWaveShaperNode['context'] {\n                return negativeWaveShaperNode.context;\n            },\n            get curve(): TNativeWaveShaperNode['curve'] {\n                return unmodifiedCurve;\n            },\n            set curve(value) {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                if (value !== null && value.length < 2) {\n                    throw createInvalidStateError();\n                }\n\n                if (value === null) {\n                    negativeWaveShaperNode.curve = value;\n                    positiveWaveShaperNode.curve = value;\n                } else {\n                    const curveLength = value.length;\n\n                    const negativeCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    const positiveCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n\n                    negativeCurve[0] = value[0];\n                    positiveCurve[0] = -value[curveLength - 1];\n\n                    const length = Math.ceil((curveLength + 1) / 2);\n                    const centerIndex = (curveLength + 1) / 2 - 1;\n\n                    for (let i = 1; i < length; i += 1) {\n                        const theoreticIndex = (i / length) * centerIndex;\n\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n\n                        negativeCurve[i] =\n                            lowerIndex === upperIndex\n                                ? value[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] +\n                                  (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n                        positiveCurve[i] =\n                            lowerIndex === upperIndex\n                                ? -value[curveLength - 1 - lowerIndex]\n                                : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) -\n                                  (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n                    }\n\n                    negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n\n                    negativeWaveShaperNode.curve = negativeCurve;\n                    positiveWaveShaperNode.curve = positiveCurve;\n                }\n\n                unmodifiedCurve = value;\n\n                if (isConnected) {\n                    if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n                    } else if (disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get numberOfInputs(): number {\n                return negativeWaveShaperNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return negativeWaveShaperNode.numberOfOutputs;\n            },\n            get oversample(): TNativeWaveShaperNode['oversample'] {\n                return negativeWaveShaperNode.oversample;\n            },\n            set oversample(value) {\n                negativeWaveShaperNode.oversample = value;\n                positiveWaveShaperNode.oversample = value;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        if (curve !== null) {\n            // Only values of type Float32Array can be assigned to the curve property.\n            nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);\n        }\n\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n            nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n\n        const whenConnected = () => {\n            inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n\n            inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n\n            isConnected = true;\n\n            if (isDCCurve(unmodifiedCurve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n            }\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(negativeWaveShaperNode);\n            negativeWaveShaperNode.disconnect(outputGainNode);\n\n            inputGainNode.disconnect(invertGainNode);\n            invertGainNode.disconnect(positiveWaveShaperNode);\n            positiveWaveShaperNode.disconnect(revertGainNode);\n            revertGainNode.disconnect(outputGainNode);\n\n            isConnected = false;\n\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n\n        return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n    };\n};\n","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeWaveShaperNodeFactoryFactory } from '../types';\n\nexport const createNativeWaveShaperNodeFactory: TNativeWaveShaperNodeFactoryFactory = (\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeWaveShaperNodeFaker,\n    isDCCurve,\n    monitorConnections,\n    nativeAudioContextConstructor,\n    overwriteAccessors\n) => {\n    return (nativeContext, options) => {\n        const nativeWaveShaperNode = nativeContext.createWaveShaper();\n\n        /*\n         * Bug #119: Safari does not correctly map the values.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here. Testing for the automationRate property is necessary because this workaround\n         * isn't necessary anymore since v14.0.2 of Safari.\n         */\n        if (\n            nativeAudioContextConstructor !== null &&\n            nativeAudioContextConstructor.name === 'webkitAudioContext' &&\n            nativeContext.createGain().gain.automationRate === undefined\n        ) {\n            return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n\n        const curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve);\n\n        // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n            throw createInvalidStateError();\n        }\n\n        // Only values of type Float32Array can be assigned to the curve property.\n        assignNativeAudioNodeOption(nativeWaveShaperNode, { curve }, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n\n        let disconnectNativeAudioBufferSourceNode: null | (() => void) = null;\n        let isConnected = false;\n\n        overwriteAccessors(\n            nativeWaveShaperNode,\n            'curve',\n            (get) => () => get.call(nativeWaveShaperNode),\n            (set) => (value) => {\n                set.call(nativeWaveShaperNode, value);\n\n                if (isConnected) {\n                    if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(\n                            nativeContext,\n                            nativeWaveShaperNode\n                        );\n                    } else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n\n                return value;\n            }\n        );\n\n        const whenConnected = () => {\n            isConnected = true;\n\n            if (isDCCurve(nativeWaveShaperNode.curve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n            }\n        };\n        const whenDisconnected = () => {\n            isConnected = false;\n\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n\n        return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n    };\n};\n","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nimport { TNativeAudioNode, TNativePannerNode, TNativePannerNodeFakerFactoryFactory } from '../types';\n\nexport const createNativePannerNodeFakerFactory: TNativePannerNodeFakerFactoryFactory = (\n    connectNativeAudioNodeToNativeAudioNode,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getFirstSample,\n    monitorConnections\n) => {\n    return (\n        nativeContext,\n        {\n            coneInnerAngle,\n            coneOuterAngle,\n            coneOuterGain,\n            distanceModel,\n            maxDistance,\n            orientationX,\n            orientationY,\n            orientationZ,\n            panningModel,\n            positionX,\n            positionY,\n            positionZ,\n            refDistance,\n            rolloffFactor,\n            ...audioNodeOptions\n        }\n    ) => {\n        const pannerNode = nativeContext.createPanner();\n\n        // Bug #125: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n\n        // Bug #126: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);\n\n        const SINGLE_CHANNEL_OPTIONS = {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete'\n        } as const;\n\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...SINGLE_CHANNEL_OPTIONS,\n            channelInterpretation: 'speakers',\n            numberOfInputs: 6\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const orientationXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 1 });\n        const orientationYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const orientationZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 1);\n        const waveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_OPTIONS,\n            curve: new Float32Array([1, 1]),\n            oversample: 'none'\n        });\n\n        let lastOrientation: [number, number, number] = [orientationX, orientationY, orientationZ];\n        let lastPosition: [number, number, number] = [positionX, positionY, positionZ];\n\n        const buffer = new Float32Array(1);\n\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n            const orientation: [number, number, number] = [\n                getFirstSample(inputBuffer, buffer, 0),\n                getFirstSample(inputBuffer, buffer, 1),\n                getFirstSample(inputBuffer, buffer, 2)\n            ];\n\n            if (orientation.some((value, index) => value !== lastOrientation[index])) {\n                pannerNode.setOrientation(...orientation); // tslint:disable-line:deprecation\n\n                lastOrientation = orientation;\n            }\n\n            const positon: [number, number, number] = [\n                getFirstSample(inputBuffer, buffer, 3),\n                getFirstSample(inputBuffer, buffer, 4),\n                getFirstSample(inputBuffer, buffer, 5)\n            ];\n\n            if (positon.some((value, index) => value !== lastPosition[index])) {\n                pannerNode.setPosition(...positon); // tslint:disable-line:deprecation\n\n                lastPosition = positon;\n            }\n        };\n\n        Object.defineProperty(orientationYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(orientationZGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionXGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionZGainNode.gain, 'defaultValue', { get: () => 0 });\n\n        const nativePannerNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return pannerNode.channelCount;\n            },\n            set channelCount(value) {\n                // Bug #125: Safari does not throw an error yet.\n                if (value > 2) {\n                    throw createNotSupportedError();\n                }\n\n                inputGainNode.channelCount = value;\n                pannerNode.channelCount = value;\n            },\n            get channelCountMode(): TNativePannerNode['channelCountMode'] {\n                return pannerNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                // Bug #126: Safari does not throw an error yet.\n                if (value === 'max') {\n                    throw createNotSupportedError();\n                }\n\n                inputGainNode.channelCountMode = value;\n                pannerNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativePannerNode['channelInterpretation'] {\n                return pannerNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                pannerNode.channelInterpretation = value;\n            },\n            get coneInnerAngle(): TNativePannerNode['coneInnerAngle'] {\n                return pannerNode.coneInnerAngle;\n            },\n            set coneInnerAngle(value) {\n                pannerNode.coneInnerAngle = value;\n            },\n            get coneOuterAngle(): TNativePannerNode['coneOuterAngle'] {\n                return pannerNode.coneOuterAngle;\n            },\n            set coneOuterAngle(value) {\n                pannerNode.coneOuterAngle = value;\n            },\n            get coneOuterGain(): TNativePannerNode['coneOuterGain'] {\n                return pannerNode.coneOuterGain;\n            },\n            set coneOuterGain(value) {\n                // Bug #127: Safari does not throw an InvalidStateError yet.\n                if (value < 0 || value > 1) {\n                    throw createInvalidStateError();\n                }\n\n                pannerNode.coneOuterGain = value;\n            },\n            get context(): TNativePannerNode['context'] {\n                return pannerNode.context;\n            },\n            get distanceModel(): TNativePannerNode['distanceModel'] {\n                return pannerNode.distanceModel;\n            },\n            set distanceModel(value) {\n                pannerNode.distanceModel = value;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get maxDistance(): TNativePannerNode['maxDistance'] {\n                return pannerNode.maxDistance;\n            },\n            set maxDistance(value) {\n                // Bug #128: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n\n                pannerNode.maxDistance = value;\n            },\n            get numberOfInputs(): number {\n                return pannerNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return pannerNode.numberOfOutputs;\n            },\n            get orientationX(): TNativePannerNode['orientationX'] {\n                return orientationXGainNode.gain;\n            },\n            get orientationY(): TNativePannerNode['orientationY'] {\n                return orientationYGainNode.gain;\n            },\n            get orientationZ(): TNativePannerNode['orientationZ'] {\n                return orientationZGainNode.gain;\n            },\n            get panningModel(): TNativePannerNode['panningModel'] {\n                return pannerNode.panningModel;\n            },\n            set panningModel(value) {\n                pannerNode.panningModel = value;\n            },\n            get positionX(): TNativePannerNode['positionX'] {\n                return positionXGainNode.gain;\n            },\n            get positionY(): TNativePannerNode['positionY'] {\n                return positionYGainNode.gain;\n            },\n            get positionZ(): TNativePannerNode['positionZ'] {\n                return positionZGainNode.gain;\n            },\n            get refDistance(): TNativePannerNode['refDistance'] {\n                return pannerNode.refDistance;\n            },\n            set refDistance(value) {\n                // Bug #129: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n\n                pannerNode.refDistance = value;\n            },\n            get rolloffFactor(): TNativePannerNode['rolloffFactor'] {\n                return pannerNode.rolloffFactor;\n            },\n            set rolloffFactor(value) {\n                // Bug #130: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n\n                pannerNode.rolloffFactor = value;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {\n            nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;\n        }\n\n        if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {\n            nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;\n        }\n\n        if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {\n            nativePannerNodeFaker.coneOuterGain = coneOuterGain;\n        }\n\n        if (distanceModel !== nativePannerNodeFaker.distanceModel) {\n            nativePannerNodeFaker.distanceModel = distanceModel;\n        }\n\n        if (maxDistance !== nativePannerNodeFaker.maxDistance) {\n            nativePannerNodeFaker.maxDistance = maxDistance;\n        }\n\n        if (orientationX !== nativePannerNodeFaker.orientationX.value) {\n            nativePannerNodeFaker.orientationX.value = orientationX;\n        }\n\n        if (orientationY !== nativePannerNodeFaker.orientationY.value) {\n            nativePannerNodeFaker.orientationY.value = orientationY;\n        }\n\n        if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {\n            nativePannerNodeFaker.orientationZ.value = orientationZ;\n        }\n\n        if (panningModel !== nativePannerNodeFaker.panningModel) {\n            nativePannerNodeFaker.panningModel = panningModel;\n        }\n\n        if (positionX !== nativePannerNodeFaker.positionX.value) {\n            nativePannerNodeFaker.positionX.value = positionX;\n        }\n\n        if (positionY !== nativePannerNodeFaker.positionY.value) {\n            nativePannerNodeFaker.positionY.value = positionY;\n        }\n\n        if (positionZ !== nativePannerNodeFaker.positionZ.value) {\n            nativePannerNodeFaker.positionZ.value = positionZ;\n        }\n\n        if (refDistance !== nativePannerNodeFaker.refDistance) {\n            nativePannerNodeFaker.refDistance = refDistance;\n        }\n\n        if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {\n            nativePannerNodeFaker.rolloffFactor = rolloffFactor;\n        }\n\n        if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {\n            pannerNode.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n        }\n\n        if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {\n            pannerNode.setPosition(...lastPosition); // tslint:disable-line:deprecation\n        }\n\n        const whenConnected = () => {\n            inputGainNode.connect(pannerNode);\n\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n\n            waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);\n            waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);\n            waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);\n            waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);\n            waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);\n            waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);\n\n            channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(pannerNode);\n\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            disconnectNativeAudioNodeFromNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n\n            waveShaperNode.disconnect(orientationXGainNode);\n            orientationXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationYGainNode);\n            orientationYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationZGainNode);\n            orientationZGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionXGainNode);\n            positionXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionYGainNode);\n            positionYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionZGainNode);\n            positionZGainNode.disconnect(channelMergerNode);\n\n            channelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.disconnect(nativeContext.destination);\n        };\n\n        return monitorConnections(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);\n    };\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativePannerNodeFactoryFactory } from '../types';\n\nexport const createNativePannerNodeFactory: TNativePannerNodeFactoryFactory = (createNativePannerNodeFaker) => {\n    return (nativeContext, options) => {\n        const nativePannerNode = nativeContext.createPanner();\n\n        // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n        if (nativePannerNode.orientationX === undefined) {\n            return createNativePannerNodeFaker(nativeContext, options);\n        }\n\n        assignNativeAudioNodeOptions(nativePannerNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationZ');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionZ');\n\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneInnerAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterGain');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'distanceModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'maxDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'panningModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'refDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'rolloffFactor');\n\n        return nativePannerNode;\n    };\n};\n","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, INativePannerNodeFaker, IOfflineAudioContext, IPannerNode } from '../interfaces';\nimport {\n    TNativeAudioBuffer,\n    TNativeGainNode,\n    TNativeOfflineAudioContext,\n    TNativePannerNode,\n    TPannerNodeRendererFactoryFactory\n} from '../types';\n\nexport const createPannerNodeRendererFactory: TPannerNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativePannerNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeGainNode | TNativePannerNode>();\n\n        let renderedBufferPromise: null | Promise<TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IPannerNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeGainNode: null | TNativeGainNode = null;\n            let nativePannerNode = getNativeAudioNode<T, TNativePannerNode>(proxy);\n\n            const commonAudioNodeOptions = {\n                channelCount: nativePannerNode.channelCount,\n                channelCountMode: nativePannerNode.channelCountMode,\n                channelInterpretation: nativePannerNode.channelInterpretation\n            };\n            const commonNativePannerNodeOptions = {\n                ...commonAudioNodeOptions,\n                coneInnerAngle: nativePannerNode.coneInnerAngle,\n                coneOuterAngle: nativePannerNode.coneOuterAngle,\n                coneOuterGain: nativePannerNode.coneOuterGain,\n                distanceModel: nativePannerNode.distanceModel,\n                maxDistance: nativePannerNode.maxDistance,\n                panningModel: nativePannerNode.panningModel,\n                refDistance: nativePannerNode.refDistance,\n                rolloffFactor: nativePannerNode.rolloffFactor\n            };\n\n            // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext);\n\n            // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n            if ('bufferSize' in nativePannerNode) {\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n            } else if (!nativePannerNodeIsOwnedByContext) {\n                const options = {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: nativePannerNode.orientationX.value,\n                    orientationY: nativePannerNode.orientationY.value,\n                    orientationZ: nativePannerNode.orientationZ.value,\n                    positionX: nativePannerNode.positionX.value,\n                    positionY: nativePannerNode.positionY.value,\n                    positionZ: nativePannerNode.positionZ.value\n                };\n\n                nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);\n\n            if (nativeGainNode !== null) {\n                if (renderedBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                        6,\n                        // Bug #17: Safari does not yet expose the length.\n                        proxy.context.length,\n                        nativeOfflineAudioContext.sampleRate\n                    );\n                    const nativeChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: 6\n                    });\n                    nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);\n\n                    renderedBufferPromise = (async () => {\n                        const nativeConstantSourceNodes = await Promise.all(\n                            [\n                                proxy.orientationX,\n                                proxy.orientationY,\n                                proxy.orientationZ,\n                                proxy.positionX,\n                                proxy.positionY,\n                                proxy.positionZ\n                            ].map(async (audioParam, index) => {\n                                const nativeConstantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                    channelCount: 1,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    offset: index === 0 ? 1 : 0\n                                });\n\n                                await renderAutomation(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset);\n\n                                return nativeConstantSourceNode;\n                            })\n                        );\n\n                        for (let i = 0; i < 6; i += 1) {\n                            nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);\n                            nativeConstantSourceNodes[i].start(0);\n                        }\n\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    })();\n                }\n\n                const renderedBuffer = await renderedBufferPromise;\n                const inputGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, inputGainNode);\n\n                const channelDatas: Float32Array[] = [];\n\n                for (let i = 0; i < renderedBuffer.numberOfChannels; i += 1) {\n                    channelDatas.push(renderedBuffer.getChannelData(i));\n                }\n\n                let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];\n                let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];\n                let gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n                let partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: lastOrientation[0],\n                    orientationY: lastOrientation[1],\n                    orientationZ: lastOrientation[2],\n                    positionX: lastPosition[0],\n                    positionY: lastPosition[1],\n                    positionZ: lastPosition[2]\n                });\n\n                inputGainNode.connect(gateGainNode).connect((<INativePannerNodeFaker>partialPannerNode).inputs[0]);\n                partialPannerNode.connect(nativeGainNode);\n\n                for (let i = 128; i < renderedBuffer.length; i += 128) {\n                    const orientation: [number, number, number] = [channelDatas[0][i], channelDatas[1][i], channelDatas[2][i]];\n                    const positon: [number, number, number] = [channelDatas[3][i], channelDatas[4][i], channelDatas[5][i]];\n\n                    if (\n                        orientation.some((value, index) => value !== lastOrientation[index]) ||\n                        positon.some((value, index) => value !== lastPosition[index])\n                    ) {\n                        lastOrientation = orientation;\n                        lastPosition = positon;\n\n                        const currentTime = i / nativeOfflineAudioContext.sampleRate;\n\n                        gateGainNode.gain.setValueAtTime(0, currentTime);\n\n                        gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 0 });\n                        partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                            ...commonNativePannerNodeOptions,\n                            orientationX: lastOrientation[0],\n                            orientationY: lastOrientation[1],\n                            orientationZ: lastOrientation[2],\n                            positionX: lastPosition[0],\n                            positionY: lastPosition[1],\n                            positionZ: lastPosition[2]\n                        });\n\n                        gateGainNode.gain.setValueAtTime(1, currentTime);\n\n                        inputGainNode.connect(gateGainNode).connect((<INativePannerNodeFaker>partialPannerNode).inputs[0]);\n                        partialPannerNode.connect(nativeGainNode);\n                    }\n                }\n\n                return nativeGainNode;\n            }\n\n            if (!nativePannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n            }\n\n            if (isNativeAudioNodeFaker(nativePannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode);\n            }\n\n            return nativePannerNode;\n        };\n\n        return {\n            render(\n                proxy: IPannerNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeGainNode | TNativePannerNode> {\n                const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeGainNodeOrNativePannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { TNativePeriodicWaveFactoryFactory } from '../types';\n\nexport const createNativePeriodicWaveFactory: TNativePeriodicWaveFactoryFactory = (createIndexSizeError) => {\n    return (nativeContext, { disableNormalization, imag, real }) => {\n        // Bug #180: Safari does not allow to use ordinary arrays.\n        const convertedImag = imag instanceof Float32Array ? imag : new Float32Array(imag);\n        const convertedReal = real instanceof Float32Array ? real : new Float32Array(real);\n\n        const nativePeriodicWave = nativeContext.createPeriodicWave(convertedReal, convertedImag, { disableNormalization });\n\n        // Bug #181: Safari does not throw an IndexSizeError so far if the given arrays have less than two values.\n        if (Array.from(imag).length < 2) {\n            throw createIndexSizeError();\n        }\n\n        return nativePeriodicWave;\n    };\n};\n","import { TSanitizePeriodicWaveOptionsFunction } from '../types';\n\nexport const sanitizePeriodicWaveOptions: TSanitizePeriodicWaveOptionsFunction = (options) => {\n    const { imag, real } = options;\n\n    if (imag === undefined) {\n        if (real === undefined) {\n            return { ...options, imag: [0, 0], real: [0, 0] };\n        }\n\n        return { ...options, imag: Array.from(real, () => 0), real };\n    }\n\n    if (real === undefined) {\n        return { ...options, imag, real: Array.from(imag, () => 0) };\n    }\n\n    return { ...options, imag, real };\n};\n","import { interceptConnections } from '../helpers/intercept-connections';\nimport { INativeWaveShaperNodeFaker } from '../interfaces';\nimport {\n    TNativeAudioNode,\n    TNativeChannelMergerNode,\n    TNativeContext,\n    TNativeGainNode,\n    TNativeStereoPannerNode,\n    TNativeStereoPannerNodeFakerFactoryFactory\n} from '../types';\n\nexport const createNativeStereoPannerNodeFakerFactory: TNativeStereoPannerNodeFakerFactoryFactory = (\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeGainNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    monitorConnections\n) => {\n    // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n    const CURVE_SIZE = 16385;\n    const DC_CURVE = new Float32Array([1, 1]);\n    const HALF_PI = Math.PI / 2;\n    const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete' } as const;\n    const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: 'none' } as const;\n\n    const buildInternalGraphForMono = (\n        nativeContext: TNativeContext,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            const x = (i / (CURVE_SIZE - 1)) * HALF_PI;\n\n            leftWaveShaperCurve[i] = Math.cos(x);\n            rightWaveShaperCurve[i] = Math.sin(x);\n        }\n\n        const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve })\n        );\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE })\n        );\n        const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve })\n        );\n\n        return {\n            connectGraph(): void {\n                inputGainNode.connect(leftGainNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.connect(rightGainNode);\n\n                panWaveShaperNode.connect(panGainNode);\n\n                panGainNode.connect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n\n                leftWaveShaperNode.connect(leftGainNode.gain);\n                rightWaveShaperNode.connect(rightGainNode.gain);\n\n                leftGainNode.connect(channelMergerNode, 0, 0);\n                rightGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph(): void {\n                inputGainNode.disconnect(leftGainNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.disconnect(rightGainNode);\n\n                panWaveShaperNode.disconnect(panGainNode);\n\n                panGainNode.disconnect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n\n                leftWaveShaperNode.disconnect(leftGainNode.gain);\n                rightWaveShaperNode.disconnect(rightGainNode.gain);\n\n                leftGainNode.disconnect(channelMergerNode, 0, 0);\n                rightGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n\n    const buildInternalGraphForStereo = (\n        nativeContext: TNativeContext,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n\n        const centerIndex = Math.floor(CURVE_SIZE / 2);\n\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            if (i > centerIndex) {\n                const x = ((i - centerIndex) / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n\n                leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n                rightInputForLeftOutputWaveShaperCurve[i] = 0;\n                rightInputForRightOutputWaveShaperCurve[i] = 1;\n            } else {\n                const x = (i / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n\n                leftInputForLeftOutputWaveShaperCurve[i] = 1;\n                leftInputForRightOutputWaveShaperCurve[i] = 0;\n                rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n            }\n        }\n\n        const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: 2,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: 2\n        });\n        const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForLeftOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForLeftOutputWaveShaperCurve\n        });\n        const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForRightOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForRightOutputWaveShaperCurve\n        });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE })\n        );\n        const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForLeftOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForLeftOutputWaveShaperCurve\n        });\n        const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForRightOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForRightOutputWaveShaperCurve\n        });\n\n        return {\n            connectGraph(): void {\n                inputGainNode.connect(channelSplitterNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n\n                channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n\n                panWaveShaperNode.connect(panGainNode);\n\n                panGainNode.connect(\n                    leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForLeftOutputWaveShaperNode\n                        : leftInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    leftInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForRightOutputWaveShaperNode\n                        : leftInputForRightOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForLeftOutputWaveShaperNode\n                        : rightInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    rightInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForRightOutputWaveShaperNode\n                        : rightInputForRightOutputWaveShaperNode.inputs[0]\n                );\n\n                leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n\n                leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n\n                leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph(): void {\n                inputGainNode.disconnect(channelSplitterNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n\n                channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n\n                panWaveShaperNode.disconnect(panGainNode);\n\n                panGainNode.disconnect(\n                    leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForLeftOutputWaveShaperNode\n                        : leftInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    leftInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForRightOutputWaveShaperNode\n                        : leftInputForRightOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForLeftOutputWaveShaperNode\n                        : rightInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    rightInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForRightOutputWaveShaperNode\n                        : rightInputForRightOutputWaveShaperNode.inputs[0]\n                );\n\n                leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n\n                leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n\n                leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n\n    const buildInternalGraph = (\n        nativeContext: TNativeContext,\n        channelCount: number,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        if (channelCount === 1) {\n            return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n\n        if (channelCount === 2) {\n            return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n\n        throw createNotSupportedError();\n    };\n\n    return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {\n        if (channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...audioNodeOptions,\n            channelCount: 1,\n            channelCountMode,\n            numberOfInputs: 2\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });\n        const panGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: pan\n        });\n\n        let { connectGraph, disconnectGraph } = buildInternalGraph(\n            nativeContext,\n            channelCount,\n            inputGainNode,\n            panGainNode,\n            channelMergerNode\n        );\n\n        Object.defineProperty(panGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(panGainNode.gain, 'maxValue', { get: () => 1 });\n        Object.defineProperty(panGainNode.gain, 'minValue', { get: () => -1 });\n\n        const nativeStereoPannerNodeFakerFactory = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return inputGainNode.channelCount;\n            },\n            set channelCount(value) {\n                if (inputGainNode.channelCount !== value) {\n                    if (isConnected) {\n                        disconnectGraph();\n                    }\n\n                    ({ connectGraph, disconnectGraph } = buildInternalGraph(\n                        nativeContext,\n                        value,\n                        inputGainNode,\n                        panGainNode,\n                        channelMergerNode\n                    ));\n\n                    if (isConnected) {\n                        connectGraph();\n                    }\n                }\n\n                inputGainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeStereoPannerNode['channelCountMode'] {\n                return inputGainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                if (value === 'clamped-max' || value === 'max') {\n                    throw createNotSupportedError();\n                }\n\n                inputGainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeStereoPannerNode['channelInterpretation'] {\n                return inputGainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n            },\n            get context(): TNativeStereoPannerNode['context'] {\n                return inputGainNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get numberOfInputs(): number {\n                return inputGainNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return inputGainNode.numberOfOutputs;\n            },\n            get pan(): TNativeStereoPannerNode['pan'] {\n                return panGainNode.gain;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        let isConnected = false;\n\n        const whenConnected = () => {\n            connectGraph();\n\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            disconnectGraph();\n\n            isConnected = false;\n        };\n\n        return monitorConnections(\n            interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode),\n            whenConnected,\n            whenDisconnected\n        );\n    };\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeStereoPannerNodeFactoryFactory } from '../types';\n\nexport const createNativeStereoPannerNodeFactory: TNativeStereoPannerNodeFactoryFactory = (\n    createNativeStereoPannerNodeFaker,\n    createNotSupportedError\n) => {\n    return (nativeContext, options) => {\n        const channelCountMode = options.channelCountMode;\n\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        if (channelCountMode === 'clamped-max') {\n            throw createNotSupportedError();\n        }\n\n        // Bug #105: Safari does not support the StereoPannerNode.\n        if (nativeContext.createStereoPanner === undefined) {\n            return createNativeStereoPannerNodeFaker(nativeContext, options);\n        }\n\n        const nativeStereoPannerNode = nativeContext.createStereoPanner();\n\n        assignNativeAudioNodeOptions(nativeStereoPannerNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, 'pan');\n\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        Object.defineProperty(nativeStereoPannerNode, 'channelCountMode', {\n            get: () => channelCountMode,\n            set: (value) => {\n                if (value !== channelCountMode) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n\n        return nativeStereoPannerNode;\n    };\n};\n","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, IOfflineAudioContext, IStereoPannerNode } from '../interfaces';\nimport { TNativeOfflineAudioContext, TNativeStereoPannerNode, TStereoPannerNodeRendererFactoryFactory } from '../types';\n\nexport const createStereoPannerNodeRendererFactory: TStereoPannerNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeStereoPannerNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeStereoPannerNodes = new WeakMap<TNativeOfflineAudioContext, TNativeStereoPannerNode>();\n\n        const createStereoPannerNode = async (proxy: IStereoPannerNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeStereoPannerNode = getNativeAudioNode<T, TNativeStereoPannerNode>(proxy);\n\n            /*\n             * If the initially used nativeStereoPannerNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);\n\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeStereoPannerNode.channelCount,\n                    channelCountMode: nativeStereoPannerNode.channelCountMode,\n                    channelInterpretation: nativeStereoPannerNode.channelInterpretation,\n                    pan: nativeStereoPannerNode.pan.value\n                };\n\n                nativeStereoPannerNode = createNativeStereoPannerNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);\n\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n            }\n\n            if (isNativeAudioNodeFaker(nativeStereoPannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode);\n            }\n\n            return nativeStereoPannerNode;\n        };\n\n        return {\n            render(proxy: IStereoPannerNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeStereoPannerNode> {\n                const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeStereoPannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeStereoPannerNode);\n                }\n\n                return createStereoPannerNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, IOfflineAudioContext, IWaveShaperNode } from '../interfaces';\nimport { TNativeOfflineAudioContext, TNativeWaveShaperNode, TWaveShaperNodeRendererFactoryFactory } from '../types';\n\nexport const createWaveShaperNodeRendererFactory: TWaveShaperNodeRendererFactoryFactory = (\n    createNativeWaveShaperNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeWaveShaperNodes = new WeakMap<TNativeOfflineAudioContext, TNativeWaveShaperNode>();\n\n        const createWaveShaperNode = async (proxy: IWaveShaperNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeWaveShaperNode = getNativeAudioNode<T, TNativeWaveShaperNode>(proxy);\n\n            // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n\n            if (!nativeWaveShaperNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeWaveShaperNode.channelCount,\n                    channelCountMode: nativeWaveShaperNode.channelCountMode,\n                    channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n                    curve: nativeWaveShaperNode.curve,\n                    oversample: nativeWaveShaperNode.oversample\n                };\n\n                nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n\n            if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);\n            }\n\n            return nativeWaveShaperNode;\n        };\n\n        return {\n            render(proxy: IWaveShaperNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeWaveShaperNode> {\n                const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeWaveShaperNode !== undefined) {\n                    return Promise.resolve(renderedNativeWaveShaperNode);\n                }\n\n                return createWaveShaperNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { TIsSecureContextFactory } from '../types';\n\nexport const createIsSecureContext: TIsSecureContextFactory = (window) => window !== null && window.isSecureContext;\n","import { TExposeCurrentFrameAndCurrentTimeFactory } from '../types';\n\nexport const createExposeCurrentFrameAndCurrentTime: TExposeCurrentFrameAndCurrentTimeFactory = (window) => {\n    return (currentTime, sampleRate, fn) => {\n        Object.defineProperties(window, {\n            currentFrame: {\n                configurable: true,\n                get(): number {\n                    return Math.round(currentTime * sampleRate);\n                }\n            },\n            currentTime: {\n                configurable: true,\n                get(): number {\n                    return currentTime;\n                }\n            }\n        });\n\n        try {\n            return fn();\n        } finally {\n            if (window !== null) {\n                delete (<any>window).currentFrame;\n                delete (<any>window).currentTime;\n            }\n        }\n    };\n};\n","import { TGetOrCreateBackupOfflineAudioContextFactory } from '../types';\n\nexport const createGetOrCreateBackupOfflineAudioContext: TGetOrCreateBackupOfflineAudioContextFactory = (\n    backupOfflineAudioContextStore,\n    nativeOfflineAudioContextConstructor\n) => {\n    return (nativeContext) => {\n        let backupOfflineAudioContext = backupOfflineAudioContextStore.get(nativeContext);\n\n        if (backupOfflineAudioContext !== undefined) {\n            return backupOfflineAudioContext;\n        }\n\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        backupOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n\n        backupOfflineAudioContextStore.set(nativeContext, backupOfflineAudioContext);\n\n        return backupOfflineAudioContext;\n    };\n};\n","import { TEvaluateSourceFactory } from '../types';\n\nexport const createEvaluateSource: TEvaluateSourceFactory = (window) => {\n    return (source) =>\n        new Promise((resolve, reject) => {\n            if (window === null) {\n                // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                reject(new SyntaxError());\n\n                return;\n            }\n\n            const head = window.document.head;\n\n            if (head === null) {\n                // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                reject(new SyntaxError());\n            } else {\n                const script = window.document.createElement('script');\n                // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.\n                const blob = new Blob([source], { type: 'application/javascript' });\n                const url = URL.createObjectURL(blob);\n\n                const originalOnErrorHandler = window.onerror;\n\n                const removeErrorEventListenerAndRevokeUrl = () => {\n                    window.onerror = originalOnErrorHandler;\n\n                    URL.revokeObjectURL(url);\n                };\n\n                window.onerror = (message, src, lineno, colno, error) => {\n                    // @todo Edge thinks the source is the one of the html document.\n                    if (src === url || (src === window.location.href && lineno === 1 && colno === 1)) {\n                        removeErrorEventListenerAndRevokeUrl();\n                        reject(error);\n\n                        return false;\n                    }\n\n                    if (originalOnErrorHandler !== null) {\n                        return originalOnErrorHandler(message, src, lineno, colno, error);\n                    }\n                };\n\n                script.onerror = () => {\n                    removeErrorEventListenerAndRevokeUrl();\n                    // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                    reject(new SyntaxError());\n                };\n                script.onload = () => {\n                    removeErrorEventListenerAndRevokeUrl();\n                    resolve();\n                };\n                script.src = url;\n                script.type = 'module';\n\n                head.appendChild(script);\n            }\n        });\n};\n","import { TFetchSourceFactory } from '../types';\n\nexport const createFetchSource: TFetchSourceFactory = (createAbortError) => {\n    return async (url) => {\n        try {\n            const response = await fetch(url);\n\n            if (response.ok) {\n                return [await response.text(), response.url];\n            }\n        } catch {\n            // Ignore errors.\n        } // tslint:disable-line:no-empty\n\n        throw createAbortError();\n    };\n};\n","import { TAbortErrorFactory } from '../types';\n\nexport const createAbortError: TAbortErrorFactory = () => new DOMException('', 'AbortError');\n","import { TTestAudioWorkletProcessorPostMessageSupportFactory } from '../types';\n\n// Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\nexport const createTestAudioWorkletProcessorPostMessageSupport: TTestAudioWorkletProcessorPostMessageSupportFactory = (\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor\n) => {\n    return async () => {\n        // Bug #61: If there is no native AudioWorkletNode it gets faked and therefore it is no problem if the it doesn't exist.\n        if (nativeAudioWorkletNodeConstructor === null) {\n            return true;\n        }\n\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const blob = new Blob(\n            ['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor(\"a\",A)'],\n            {\n                type: 'application/javascript; charset=utf-8'\n            }\n        );\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 44100);\n        const url = URL.createObjectURL(blob);\n\n        let isEmittingMessageEvents = false;\n        let isEmittingProcessorErrorEvents = false;\n\n        try {\n            await offlineAudioContext.audioWorklet.addModule(url);\n\n            const audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', { numberOfOutputs: 0 });\n            const oscillator = offlineAudioContext.createOscillator();\n\n            audioWorkletNode.port.onmessage = () => (isEmittingMessageEvents = true);\n            audioWorkletNode.onprocessorerror = () => (isEmittingProcessorErrorEvents = true);\n\n            oscillator.connect(audioWorkletNode);\n            oscillator.start(0);\n\n            await offlineAudioContext.startRendering();\n        } catch {\n            // Ignore errors.\n        } finally {\n            URL.revokeObjectURL(url);\n        }\n\n        return isEmittingMessageEvents && !isEmittingProcessorErrorEvents;\n    };\n};\n","import { TIsNativeContextFactory, TNativeAudioContext } from '../types';\n\nexport const createIsNativeContext: TIsNativeContextFactory = (isNativeAudioContext, isNativeOfflineAudioContext) => {\n    return (anything): anything is TNativeAudioContext => {\n        return isNativeAudioContext(anything) || isNativeOfflineAudioContext(anything);\n    };\n};\n","import { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { TDecodeAudioDataFactory } from '../types';\n\nexport const createDecodeAudioData: TDecodeAudioDataFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    createDataCloneError,\n    createEncodingError,\n    detachedArrayBuffers,\n    getNativeContext,\n    isNativeContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    testPromiseSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    return (anyContext, audioData) => {\n        const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext);\n\n        // Bug #43: Only Chrome and Edge do throw a DataCloneError.\n        if (detachedArrayBuffers.has(audioData)) {\n            const err = createDataCloneError();\n\n            return Promise.reject(err);\n        }\n\n        // The audioData parameter maybe of a type which can't be added to a WeakSet.\n        try {\n            detachedArrayBuffers.add(audioData);\n        } catch {\n            // Ignore errors.\n        }\n\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {\n            return nativeContext.decodeAudioData(audioData).then((audioBuffer) => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                detachArrayBuffer(audioData).catch(() => {\n                    // Ignore errors.\n                });\n\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n                if (\n                    !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                        testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                    )\n                ) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n\n                audioBufferStore.add(audioBuffer);\n\n                return audioBuffer;\n            });\n        }\n\n        // Bug #21: Safari does not return a Promise yet.\n        return new Promise((resolve, reject) => {\n            const complete = async () => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                try {\n                    await detachArrayBuffer(audioData);\n                } catch {\n                    // Ignore errors.\n                }\n            };\n\n            const fail = (err: DOMException | Error) => {\n                reject(err);\n                complete();\n            };\n\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                // Bug #1: Safari requires a successCallback.\n                nativeContext.decodeAudioData(\n                    audioData,\n                    (audioBuffer) => {\n                        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                        // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                        if (typeof audioBuffer.copyFromChannel !== 'function') {\n                            wrapAudioBufferCopyChannelMethods(audioBuffer);\n                            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                        }\n\n                        audioBufferStore.add(audioBuffer);\n\n                        complete().then(() => resolve(audioBuffer));\n                    },\n                    (err: DOMException | Error) => {\n                        // Bug #4: Safari returns null instead of an error.\n                        if (err === null) {\n                            fail(createEncodingError());\n                        } else {\n                            fail(err);\n                        }\n                    }\n                );\n            } catch (err) {\n                fail(err);\n            }\n        });\n    };\n};\n","import { TDataCloneErrorFactory } from '../types';\n\nexport const createDataCloneError: TDataCloneErrorFactory = () => new DOMException('', 'DataCloneError');\n","import { TEncodingErrorFactory } from '../types';\n\nexport const createEncodingError: TEncodingErrorFactory = () => new DOMException('', 'EncodingError');\n","import {\n    IAnalyserNode,\n    IAudioBuffer,\n    IAudioBufferSourceNode,\n    IAudioNode,\n    IAudioWorklet,\n    IBaseAudioContext,\n    IBiquadFilterNode,\n    IConstantSourceNode,\n    IConvolverNode,\n    IDelayNode,\n    IDynamicsCompressorNode,\n    IGainNode,\n    IIIRFilterNode,\n    IOscillatorNode,\n    IPannerNode,\n    IPeriodicWave,\n    IPeriodicWaveConstraints,\n    IStereoPannerNode,\n    IWaveShaperNode,\n    IWorkletOptions\n} from '../interfaces';\nimport { TBaseAudioContextConstructorFactory, TContext, TDecodeErrorCallback, TDecodeSuccessCallback, TNativeContext } from '../types';\n\nexport const createBaseAudioContextConstructor: TBaseAudioContextConstructorFactory = (\n    addAudioWorkletModule,\n    analyserNodeConstructor,\n    audioBufferConstructor,\n    audioBufferSourceNodeConstructor,\n    biquadFilterNodeConstructor,\n    channelMergerNodeConstructor,\n    channelSplitterNodeConstructor,\n    constantSourceNodeConstructor,\n    convolverNodeConstructor,\n    decodeAudioData,\n    delayNodeConstructor,\n    dynamicsCompressorNodeConstructor,\n    gainNodeConstructor,\n    iIRFilterNodeConstructor,\n    minimalBaseAudioContextConstructor,\n    oscillatorNodeConstructor,\n    pannerNodeConstructor,\n    periodicWaveConstructor,\n    stereoPannerNodeConstructor,\n    waveShaperNodeConstructor\n) => {\n    return class BaseAudioContext<T extends TContext> extends minimalBaseAudioContextConstructor<T> implements IBaseAudioContext<T> {\n        private _audioWorklet: undefined | IAudioWorklet;\n\n        constructor(private _nativeContext: TNativeContext, numberOfChannels: number) {\n            super(_nativeContext, numberOfChannels);\n\n            this._audioWorklet =\n                addAudioWorkletModule === undefined\n                    ? undefined\n                    : {\n                          addModule: (moduleURL: string, options?: IWorkletOptions) => {\n                              return addAudioWorkletModule(<T>(<unknown>this), moduleURL, options);\n                          }\n                      };\n        }\n\n        get audioWorklet(): undefined | IAudioWorklet {\n            return this._audioWorklet;\n        }\n\n        public createAnalyser(): IAnalyserNode<T> {\n            return new analyserNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createBiquadFilter(): IBiquadFilterNode<T> {\n            return new biquadFilterNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createBuffer(numberOfChannels: number, length: number, sampleRate: number): IAudioBuffer {\n            return new audioBufferConstructor({ length, numberOfChannels, sampleRate });\n        }\n\n        public createBufferSource(): IAudioBufferSourceNode<T> {\n            return new audioBufferSourceNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createChannelMerger(numberOfInputs = 6): IAudioNode<T> {\n            return new channelMergerNodeConstructor(<T>(<unknown>this), { numberOfInputs });\n        }\n\n        public createChannelSplitter(numberOfOutputs = 6): IAudioNode<T> {\n            return new channelSplitterNodeConstructor(<T>(<unknown>this), { numberOfOutputs });\n        }\n\n        public createConstantSource(): IConstantSourceNode<T> {\n            return new constantSourceNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createConvolver(): IConvolverNode<T> {\n            return new convolverNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createDelay(maxDelayTime = 1): IDelayNode<T> {\n            return new delayNodeConstructor(<T>(<unknown>this), { maxDelayTime });\n        }\n\n        public createDynamicsCompressor(): IDynamicsCompressorNode<T> {\n            return new dynamicsCompressorNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createGain(): IGainNode<T> {\n            return new gainNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createIIRFilter(feedforward: Iterable<number>, feedback: Iterable<number>): IIIRFilterNode<T> {\n            return new iIRFilterNodeConstructor(<T>(<unknown>this), { feedback, feedforward });\n        }\n\n        public createOscillator(): IOscillatorNode<T> {\n            return new oscillatorNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createPanner(): IPannerNode<T> {\n            return new pannerNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createPeriodicWave(\n            real: Iterable<number>,\n            imag: Iterable<number>,\n            constraints: Partial<IPeriodicWaveConstraints> = { disableNormalization: false }\n        ): IPeriodicWave {\n            return new periodicWaveConstructor(<T>(<unknown>this), { ...constraints, imag, real });\n        }\n\n        public createStereoPanner(): IStereoPannerNode<T> {\n            return new stereoPannerNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createWaveShaper(): IWaveShaperNode<T> {\n            return new waveShaperNodeConstructor(<T>(<unknown>this));\n        }\n\n        public decodeAudioData(\n            audioData: ArrayBuffer,\n            successCallback?: TDecodeSuccessCallback,\n            errorCallback?: TDecodeErrorCallback\n        ): Promise<IAudioBuffer> {\n            return decodeAudioData(this._nativeContext, audioData).then(\n                (audioBuffer) => {\n                    if (typeof successCallback === 'function') {\n                        successCallback(audioBuffer);\n                    }\n\n                    return audioBuffer;\n                },\n                (err) => {\n                    if (typeof errorCallback === 'function') {\n                        errorCallback(err);\n                    }\n\n                    throw err;\n                }\n            );\n        }\n    };\n};\n","import { IAudioContext, IMediaElementAudioSourceNode, IMediaElementAudioSourceOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaElementAudioSourceNodeConstructorFactory, TNativeMediaElementAudioSourceNode } from '../types';\n\nexport const createMediaElementAudioSourceNodeConstructor: TMediaElementAudioSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaElementAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class MediaElementAudioSourceNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaElementAudioSourceNode<T> {\n        private _nativeMediaElementAudioSourceNode: TNativeMediaElementAudioSourceNode;\n\n        constructor(context: T, options: IMediaElementAudioSourceOptions) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode(nativeContext, options);\n\n            // Bug #171: Safari allows to create a MediaElementAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw TypeError();\n            }\n\n            super(context, true, nativeMediaElementAudioSourceNode, <TAudioNodeRenderer<T>>null);\n\n            this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;\n        }\n\n        get mediaElement(): HTMLMediaElement {\n            return this._nativeMediaElementAudioSourceNode.mediaElement;\n        }\n    };\n};\n","import { TNativeMediaElementAudioSourceNodeFactory } from '../types';\n\nexport const createNativeMediaElementAudioSourceNode: TNativeMediaElementAudioSourceNodeFactory = (nativeAudioContext, options) => {\n    return nativeAudioContext.createMediaElementSource(options.mediaElement);\n};\n","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeMediaStreamAudioDestinationNodeFactory } from '../types';\n\nexport const createNativeMediaStreamAudioDestinationNode: TNativeMediaStreamAudioDestinationNodeFactory = (nativeAudioContext, options) => {\n    const nativeMediaStreamAudioDestinationNode = nativeAudioContext.createMediaStreamDestination();\n\n    assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options);\n\n    // Bug #174: Safari does expose a wrong numberOfOutputs.\n    if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {\n        Object.defineProperty(nativeMediaStreamAudioDestinationNode, 'numberOfOutputs', { get: () => 0 });\n    }\n\n    return nativeMediaStreamAudioDestinationNode;\n};\n","import { IAudioContext, IMediaStreamAudioSourceNode, IMediaStreamAudioSourceOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaStreamAudioSourceNodeConstructorFactory, TNativeMediaStreamAudioSourceNode } from '../types';\n\nexport const createMediaStreamAudioSourceNodeConstructor: TMediaStreamAudioSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaStreamAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class MediaStreamAudioSourceNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaStreamAudioSourceNode<T> {\n        private _nativeMediaStreamAudioSourceNode: TNativeMediaStreamAudioSourceNode;\n\n        constructor(context: T, options: IMediaStreamAudioSourceOptions) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options);\n\n            // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n\n            super(context, true, nativeMediaStreamAudioSourceNode, <TAudioNodeRenderer<T>>null);\n\n            this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n        }\n\n        get mediaStream(): MediaStream {\n            return this._nativeMediaStreamAudioSourceNode.mediaStream;\n        }\n    };\n};\n","import { TNativeMediaStreamAudioSourceNodeFactory } from '../types';\n\nexport const createNativeMediaStreamAudioSourceNode: TNativeMediaStreamAudioSourceNodeFactory = (nativeAudioContext, { mediaStream }) => {\n    const audioStreamTracks = mediaStream.getAudioTracks();\n    /*\n     * Bug #151: Safari does not use the audio track as input anymore if it gets removed from the mediaStream after construction.\n     * Bug #159: Safari picks the first audio track if the MediaStream has more than one audio track.\n     */\n    audioStreamTracks.sort((a, b) => (a.id < b.id ? -1 : a.id > b.id ? 1 : 0));\n\n    const filteredAudioStreamTracks = audioStreamTracks.slice(0, 1);\n\n    const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n\n    /*\n     * Bug #151 & #159: The given mediaStream gets reconstructed before it gets passed to the native node which is why the accessor needs\n     * to be overwritten as it would otherwise expose the reconstructed version.\n     */\n    Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', { value: mediaStream });\n\n    return nativeMediaStreamAudioSourceNode;\n};\n","import { TNativeMediaStreamTrackAudioSourceNodeFactoryFactory } from '../types';\n\nexport const createNativeMediaStreamTrackAudioSourceNodeFactory: TNativeMediaStreamTrackAudioSourceNodeFactoryFactory = (\n    createInvalidStateError,\n    isNativeOfflineAudioContext\n) => {\n    return (nativeAudioContext, { mediaStreamTrack }) => {\n        // Bug #121: Only Firefox does yet support the MediaStreamTrackAudioSourceNode.\n        if (typeof nativeAudioContext.createMediaStreamTrackSource === 'function') {\n            return nativeAudioContext.createMediaStreamTrackSource(mediaStreamTrack);\n        }\n\n        const mediaStream = new MediaStream([mediaStreamTrack]);\n        const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(mediaStream);\n\n        // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n        if (mediaStreamTrack.kind !== 'audio') {\n            throw createInvalidStateError();\n        }\n\n        // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n        if (isNativeOfflineAudioContext(nativeAudioContext)) {\n            throw new TypeError();\n        }\n\n        return nativeMediaStreamAudioSourceNode;\n    };\n};\n","import { IAudioContext, IMediaStreamTrackAudioSourceNode, IMediaStreamTrackAudioSourceOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaStreamTrackAudioSourceNodeConstructorFactory } from '../types';\n\nexport const createMediaStreamTrackAudioSourceNodeConstructor: TMediaStreamTrackAudioSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaStreamTrackAudioSourceNode,\n    getNativeContext\n) => {\n    return class MediaStreamTrackAudioSourceNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaStreamTrackAudioSourceNode<T> {\n        constructor(context: T, options: IMediaStreamTrackAudioSourceOptions) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode(nativeContext, options);\n\n            super(context, true, nativeMediaStreamTrackAudioSourceNode, <TAudioNodeRenderer<T>>null);\n        }\n    };\n};\n","import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nimport {\n    IAudioContext,\n    IAudioContextOptions,\n    IMediaElementAudioSourceNode,\n    IMediaStreamAudioDestinationNode,\n    IMediaStreamAudioSourceNode,\n    IMediaStreamTrackAudioSourceNode\n} from '../interfaces';\nimport { TAudioContextConstructorFactory, TAudioContextState, TNativeAudioContext, TNativeGainNode, TNativeOscillatorNode } from '../types';\n\nexport const createAudioContextConstructor: TAudioContextConstructorFactory = (\n    baseAudioContextConstructor,\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    mediaElementAudioSourceNodeConstructor,\n    mediaStreamAudioDestinationNodeConstructor,\n    mediaStreamAudioSourceNodeConstructor,\n    mediaStreamTrackAudioSourceNodeConstructor,\n    nativeAudioContextConstructor\n) => {\n    return class AudioContext extends baseAudioContextConstructor<IAudioContext> implements IAudioContext {\n        private _baseLatency: number;\n\n        private _nativeAudioContext: TNativeAudioContext;\n\n        private _nativeGainNode: null | TNativeGainNode;\n\n        private _nativeOscillatorNode: null | TNativeOscillatorNode;\n\n        private _state: null | 'suspended';\n\n        constructor(options: IAudioContextOptions = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n\n            let nativeAudioContext: TNativeAudioContext;\n\n            try {\n                nativeAudioContext = new nativeAudioContextConstructor(options);\n            } catch (err) {\n                // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.\n                if (err.code === 12 && err.message === 'sampleRate is not in range') {\n                    throw createNotSupportedError();\n                }\n\n                throw err;\n            }\n\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n\n            // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(\n                    `The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`\n                );\n            }\n\n            // Bug #150 Safari does not support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n\n            super(nativeAudioContext, 2);\n\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency =\n                typeof nativeAudioContext.baseLatency === 'number'\n                    ? nativeAudioContext.baseLatency\n                    : latencyHint === 'balanced'\n                    ? 512 / sampleRate\n                    : latencyHint === 'interactive' || latencyHint === undefined\n                    ? 256 / sampleRate\n                    : latencyHint === 'playback'\n                    ? 1024 / sampleRate\n                    : /*\n                       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                       * ScriptProcessorNode.\n                       */\n                      (Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate;\n            this._nativeAudioContext = nativeAudioContext;\n\n            // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n            if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                this._nativeGainNode = nativeAudioContext.createGain();\n                this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n\n                this._nativeGainNode.gain.value = 1e-37;\n\n                this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);\n                this._nativeOscillatorNode.start();\n            } else {\n                this._nativeGainNode = null;\n                this._nativeOscillatorNode = null;\n            }\n\n            this._state = null;\n\n            /*\n             * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes\n             * to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n\n        get baseLatency(): number {\n            return this._baseLatency;\n        }\n\n        get state(): TAudioContextState {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n        }\n\n        public close(): Promise<void> {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext.close().then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n\n            return this._nativeAudioContext.close().then(() => {\n                if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {\n                    this._nativeOscillatorNode.stop();\n\n                    this._nativeGainNode.disconnect();\n                    this._nativeOscillatorNode.disconnect();\n                }\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        public createMediaElementSource(mediaElement: HTMLMediaElement): IMediaElementAudioSourceNode<this> {\n            return new mediaElementAudioSourceNodeConstructor(this, { mediaElement });\n        }\n\n        public createMediaStreamDestination(): IMediaStreamAudioDestinationNode<this> {\n            return new mediaStreamAudioDestinationNodeConstructor(this);\n        }\n\n        public createMediaStreamSource(mediaStream: MediaStream): IMediaStreamAudioSourceNode<this> {\n            return new mediaStreamAudioSourceNodeConstructor(this, { mediaStream });\n        }\n\n        public createMediaStreamTrackSource(mediaStreamTrack: MediaStreamTrack): IMediaStreamTrackAudioSourceNode<this> {\n            return new mediaStreamTrackAudioSourceNodeConstructor(this, { mediaStreamTrack });\n        }\n\n        public resume(): Promise<void> {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        } else {\n                            this.resume().then(resolve, reject);\n                        }\n                    };\n\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n\n            return this._nativeAudioContext.resume().catch((err) => {\n                // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n\n        public suspend(): Promise<void> {\n            return this._nativeAudioContext.suspend().catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n    };\n};\n","import { TGetUnrenderedAudioWorkletNodesFactory } from '../types';\n\nexport const createGetUnrenderedAudioWorkletNodes: TGetUnrenderedAudioWorkletNodesFactory = (unrenderedAudioWorkletNodeStore) => {\n    return (nativeContext) => {\n        const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore.get(nativeContext);\n\n        if (unrenderedAudioWorkletNodes === undefined) {\n            throw new Error('The context has no set of AudioWorkletNodes.');\n        }\n\n        return unrenderedAudioWorkletNodes;\n    };\n};\n","import { TAddUnrenderedAudioWorkletNodeFactory } from '../types';\n\nexport const createAddUnrenderedAudioWorkletNode: TAddUnrenderedAudioWorkletNodeFactory = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).add(audioWorkletNode);\n    };\n};\n","import { isNativeAudioNode } from '../guards/native-audio-node';\nimport { TConnectMultipleOutputsFactory } from '../types';\n\nexport const createConnectMultipleOutputs: TConnectMultipleOutputsFactory = (createIndexSizeError) => {\n    return (outputAudioNodes, destination, output = 0, input = 0) => {\n        const outputAudioNode = outputAudioNodes[output];\n\n        if (outputAudioNode === undefined) {\n            throw createIndexSizeError();\n        }\n\n        if (isNativeAudioNode(destination)) {\n            return outputAudioNode.connect(destination, 0, input);\n        }\n\n        return outputAudioNode.connect(destination, 0);\n    };\n};\n","import { TDeleteUnrenderedAudioWorkletNodeFactory } from '../types';\n\nexport const createDeleteUnrenderedAudioWorkletNode: TDeleteUnrenderedAudioWorkletNodeFactory = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).delete(audioWorkletNode);\n    };\n};\n","import { TActiveInputConnection, TContext, TGetActiveAudioWorkletNodeInputsFactory, TNativeAudioWorkletNode } from '../types';\n\nexport const createGetActiveAudioWorkletNodeInputs: TGetActiveAudioWorkletNodeInputsFactory = (\n    activeAudioWorkletNodeInputsStore,\n    getValueForKey\n) => {\n    return <T extends TContext>(nativeAudioWorkletNode: TNativeAudioWorkletNode) =>\n        <Set<TActiveInputConnection<T>>[]>getValueForKey(activeAudioWorkletNodeInputsStore, nativeAudioWorkletNode);\n};\n","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { IAudioWorkletProcessor } from '../interfaces';\nimport { ReadOnlyMap } from '../read-only-map';\nimport {\n    TNativeAudioNode,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode,\n    TNativeAudioWorkletNodeFakerFactoryFactory,\n    TNativeChannelMergerNode,\n    TNativeChannelSplitterNode,\n    TNativeConstantSourceNode,\n    TNativeGainNode\n} from '../types';\n\nexport const createNativeAudioWorkletNodeFakerFactory: TNativeAudioWorkletNodeFakerFactoryFactory = (\n    connectMultipleOutputs,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getActiveAudioWorkletNodeInputs,\n    monitorConnections\n) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n\n        const outputChannelCount = Array.isArray(options.outputChannelCount)\n            ? options.outputChannelCount\n            : Array.from(options.outputChannelCount);\n\n        // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n        if (outputChannelCount.some((channelCount) => channelCount < 1)) {\n            throw createNotSupportedError();\n        }\n\n        if (outputChannelCount.length !== options.numberOfOutputs) {\n            throw createIndexSizeError();\n        }\n\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters =\n            processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n\n        const messageChannel = new MessageChannel();\n        const gainNodes: TNativeGainNode[] = [];\n        const inputChannelSplitterNodes: TNativeChannelSplitterNode[] = [];\n\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(\n                createNativeGainNode(nativeContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                })\n            );\n            inputChannelSplitterNodes.push(\n                createNativeChannelSplitterNode(nativeContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: options.channelCount\n                })\n            );\n        }\n\n        const constantSourceNodes: TNativeConstantSourceNode[] = [];\n\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset:\n                        options.parameterData[name] !== undefined\n                            ? options.parameterData[name]\n                            : defaultValue === undefined\n                            ? 0\n                            : defaultValue\n                });\n\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined ? 0 : defaultValue)\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue)\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue)\n                    }\n                });\n\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(\n            nativeContext,\n            bufferSize,\n            numberOfInputChannels + numberOfParameters,\n            // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n            Math.max(1, numberOfOutputChannels)\n        );\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes: TNativeChannelMergerNode[] = [];\n\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(\n                createNativeChannelMergerNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'speakers',\n                    numberOfInputs: outputChannelCount[i]\n                })\n            );\n        }\n\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n            }\n        }\n\n        const parameterMap = new ReadOnlyMap(\n            processorConstructor.parameterDescriptors === undefined\n                ? []\n                : processorConstructor.parameterDescriptors.map(({ name }, index) => {\n                      const constantSourceNode = constantSourceNodes[index];\n\n                      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                      constantSourceNode.start(0);\n\n                      return <[string, TNativeAudioParam]>[name, constantSourceNode.offset];\n                  })\n        );\n\n        inputChannelMergerNode.connect(scriptProcessorNode);\n\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror: TNativeAudioWorkletNode['onprocessorerror'] = null;\n\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize(): number {\n                return bufferSize;\n            },\n            get channelCount(): number {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode(): TNativeAudioWorkletNode['channelCountMode'] {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation(): TNativeAudioWorkletNode['channelInterpretation'] {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n\n                channelInterpretation = value;\n            },\n            get context(): TNativeAudioWorkletNode['context'] {\n                return scriptProcessorNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return gainNodes;\n            },\n            get numberOfInputs(): number {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror(): TNativeAudioWorkletNode['onprocessorerror'] {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n\n                onprocessorerror = typeof value === 'function' ? value : null;\n\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters(): TNativeAudioWorkletNode['parameters'] {\n                return parameterMap;\n            },\n            get port(): TNativeAudioWorkletNode['port'] {\n                return messageChannel.port2;\n            },\n            addEventListener(...args: any[]): void {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: <TNativeAudioNode['connect']>connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: <TNativeAudioNode['disconnect']>disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args: any[]): boolean {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        const patchedEventListeners: Map<EventListenerOrEventListenerObject, NonNullable<MessagePort['onmessage']>> = new Map();\n\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args: [string, EventListenerOrEventListenerObject, (boolean | AddEventListenerOptions)?]): void => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener =\n                        typeof args[1] === 'function'\n                            ? args[1]\n                            : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                            ? args[1].handleEvent\n                            : null;\n\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                        if (patchedEventListener !== undefined) {\n                            args[1] = <EventListenerOrEventListenerObject>patchedEventListener;\n                        } else {\n                            args[1] = (event: Event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () =>\n                                    unpatchedEventListener(event)\n                                );\n                            };\n\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args: any[]): void => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n\n                        args[1] = patchedEventListener;\n                    }\n                }\n\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n\n        let onmessage: MessagePort['onmessage'] = null;\n\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n\n                onmessage = typeof value === 'function' ? value : null;\n\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n\n        processorConstructor.prototype.port = messageChannel.port1;\n\n        let audioWorkletProcessor: null | IAudioWorkletProcessor = null;\n\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(\n            nativeContext,\n            nativeAudioWorkletNodeFaker,\n            processorConstructor,\n            options\n        );\n\n        audioWorkletProcessorPromise.then((dWrkltPrcssr) => (audioWorkletProcessor = dWrkltPrcssr));\n\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n        const parameters: { [name: string]: Float32Array } =\n            processorConstructor.parameterDescriptors === undefined\n                ? []\n                : processorConstructor.parameterDescriptors.reduce(\n                      (prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }),\n                      {}\n                  );\n\n        let isActive = true;\n\n        const disconnectOutputsGraph = () => {\n            if (options.numberOfOutputs > 0) {\n                scriptProcessorNode.disconnect(outputChannelSplitterNode);\n            }\n\n            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                    outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n\n                outputChannelSplitterNodeOutput += outputChannelCount[i];\n            }\n        };\n\n        const activeInputIndexes = new Map<number, number>();\n\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }: AudioProcessingEvent) => {\n            if (audioWorkletProcessor !== null) {\n                const activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);\n\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n\n                    try {\n                        const potentiallyEmptyInputs = inputs.map((input, index) => {\n                            const activeInput = activeInputs[index];\n\n                            if (activeInput.size > 0) {\n                                activeInputIndexes.set(index, bufferSize / 128);\n\n                                return input;\n                            }\n\n                            const count = activeInputIndexes.get(index);\n\n                            if (count === undefined) {\n                                return [];\n                            }\n\n                            if (input.every((channelData) => channelData.every((sample) => sample === 0))) {\n                                if (count === 1) {\n                                    activeInputIndexes.delete(index);\n                                } else {\n                                    activeInputIndexes.set(index, count - 1);\n                                }\n                            }\n\n                            return input;\n                        });\n\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(\n                            nativeContext.currentTime + i / nativeContext.sampleRate,\n                            nativeContext.sampleRate,\n                            () => (<IAudioWorkletProcessor>audioWorkletProcessor).process(potentiallyEmptyInputs, outputs, parameters)\n                        );\n\n                        isActive = activeSourceFlag;\n\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n\n                            outputChannelSplitterNodeOutput += outputChannelCount[j];\n                        }\n                    } catch (error) {\n                        isActive = false;\n\n                        nativeAudioWorkletNodeFaker.dispatchEvent(\n                            new ErrorEvent('processorerror', {\n                                colno: error.colno,\n                                filename: error.filename,\n                                lineno: error.lineno,\n                                message: error.message\n                            })\n                        );\n                    }\n\n                    if (!isActive) {\n                        for (let j = 0; j < options.numberOfInputs; j += 1) {\n                            gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n\n                            for (let k = 0; k < options.channelCount; k += 1) {\n                                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n                            }\n                        }\n\n                        if (processorConstructor.parameterDescriptors !== undefined) {\n                            const length = processorConstructor.parameterDescriptors.length;\n\n                            for (let j = 0; j < length; j += 1) {\n                                const constantSourceNode = constantSourceNodes[j];\n\n                                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                                constantSourceNode.stop();\n                            }\n                        }\n\n                        inputChannelMergerNode.disconnect(scriptProcessorNode);\n\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n\n                        if (isConnected) {\n                            disconnectOutputsGraph();\n                        } else {\n                            disconnectFakeGraph();\n                        }\n\n                        break;\n                    }\n                }\n            }\n        };\n\n        let isConnected = false;\n\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n\n        const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n        const disconnectFakeGraph = () => {\n            scriptProcessorNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        const whenConnected = () => {\n            if (isActive) {\n                disconnectFakeGraph();\n\n                if (options.numberOfOutputs > 0) {\n                    scriptProcessorNode.connect(outputChannelSplitterNode);\n                }\n\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n            }\n\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            if (isActive) {\n                connectFakeGraph();\n                disconnectOutputsGraph();\n            }\n\n            isConnected = false;\n        };\n\n        connectFakeGraph();\n\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n    };\n};\n","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { IAudioWorkletNodeOptions, IAudioWorkletProcessor, IAudioWorkletProcessorConstructor } from '../interfaces';\nimport { TNativeAudioWorkletNode, TNativeContext } from '../types';\nimport { createAudioWorkletProcessorPromise } from './create-audio-worklet-processor-promise';\n\nexport const createAudioWorkletProcessor = (\n    nativeContext: TNativeContext,\n    nativeAudioWorkletNode: TNativeAudioWorkletNode,\n    processorConstructor: IAudioWorkletProcessorConstructor,\n    audioWorkletNodeOptions: IAudioWorkletNodeOptions\n): Promise<IAudioWorkletProcessor> => {\n    let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n\n    if (nodeToProcessorMap === undefined) {\n        nodeToProcessorMap = new WeakMap();\n\n        NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n    }\n\n    const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n\n    nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n\n    return audioWorkletProcessorPromise;\n};\n","import { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nimport { TNativeAudioWorkletNode, TNativeAudioWorkletNodeFactoryFactory, TNativeAudioWorkletNodeOptions } from '../types';\n\nexport const createNativeAudioWorkletNodeFactory: TNativeAudioWorkletNodeFactoryFactory = (\n    createInvalidStateError,\n    createNativeAudioWorkletNodeFaker,\n    createNativeGainNode,\n    createNotSupportedError,\n    monitorConnections\n) => {\n    return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) => {\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            try {\n                const nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(\n                    nativeContext,\n                    name,\n                    <TNativeAudioWorkletNodeOptions>options\n                );\n                const patchedEventListeners: Map<\n                    EventListenerOrEventListenerObject,\n                    NonNullable<TNativeAudioWorkletNode['onprocessorerror']>\n                > = new Map();\n\n                let onprocessorerror: TNativeAudioWorkletNode['onprocessorerror'] = null;\n\n                Object.defineProperties(nativeAudioWorkletNode, {\n                    /*\n                     * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n                     * browsers have no native implementation to achieve a consistent behavior.\n                     */\n                    channelCount: {\n                        get: () => options.channelCount,\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    channelCountMode: {\n                        get: () => 'explicit',\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.\n                    onprocessorerror: {\n                        get: () => onprocessorerror,\n                        set: (value) => {\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n                            }\n\n                            onprocessorerror = typeof value === 'function' ? value : null;\n\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n                            }\n                        }\n                    }\n                });\n\n                nativeAudioWorkletNode.addEventListener = ((addEventListener) => {\n                    return (...args: [string, EventListenerOrEventListenerObject, (boolean | AddEventListenerOptions)?]): void => {\n                        if (args[0] === 'processorerror') {\n                            const unpatchedEventListener =\n                                typeof args[1] === 'function'\n                                    ? args[1]\n                                    : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                                    ? args[1].handleEvent\n                                    : null;\n\n                            if (unpatchedEventListener !== null) {\n                                const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                                if (patchedEventListener !== undefined) {\n                                    args[1] = patchedEventListener;\n                                } else {\n                                    args[1] = (event: Event) => {\n                                        // Bug #178: Chrome and Edge do fire an event of type error.\n                                        if (event.type === 'error') {\n                                            Object.defineProperties(event, {\n                                                type: { value: 'processorerror' }\n                                            });\n\n                                            unpatchedEventListener(event);\n                                        } else {\n                                            unpatchedEventListener(new ErrorEvent(args[0], { ...event }));\n                                        }\n                                    };\n\n                                    patchedEventListeners.set(unpatchedEventListener, args[1]);\n                                }\n                            }\n                        }\n\n                        // Bug #178: Chrome and Edge do fire an event of type error.\n                        addEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n\n                        return addEventListener.call(nativeAudioWorkletNode, ...args);\n                    };\n                })(nativeAudioWorkletNode.addEventListener);\n\n                nativeAudioWorkletNode.removeEventListener = ((removeEventListener) => {\n                    return (...args: any[]): void => {\n                        if (args[0] === 'processorerror') {\n                            const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                            if (patchedEventListener !== undefined) {\n                                patchedEventListeners.delete(args[1]);\n\n                                args[1] = patchedEventListener;\n                            }\n                        }\n\n                        // Bug #178: Chrome and Edge do fire an event of type error.\n                        removeEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n\n                        return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.removeEventListener);\n\n                /*\n                 * Bug #86: Chrome and Edge do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but\n                 * has an output.\n                 */\n                if (options.numberOfOutputs !== 0) {\n                    const nativeGainNode = createNativeGainNode(nativeContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'discrete',\n                        gain: 0\n                    });\n\n                    nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);\n\n                    const whenConnected = () => nativeGainNode.disconnect();\n                    const whenDisconnected = () => nativeGainNode.connect(nativeContext.destination);\n\n                    // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.\n                    return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n                }\n\n                return nativeAudioWorkletNode;\n            } catch (err) {\n                // Bug #60: Chrome & Edge throw an InvalidStateError instead of a NotSupportedError.\n                if (err.code === 11) {\n                    throw createNotSupportedError();\n                }\n\n                throw err;\n            }\n        }\n\n        // Bug #61: Only Chrome & Edge have an implementation of the AudioWorkletNode yet.\n        if (processorConstructor === undefined) {\n            throw createNotSupportedError();\n        }\n\n        testClonabilityOfAudioWorkletNodeOptions(options);\n\n        return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n    };\n};\n","import { IAudioWorkletNodeOptions } from '../interfaces';\n\nexport const testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions: IAudioWorkletNodeOptions): void => {\n    const { port1 } = new MessageChannel();\n\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    } finally {\n        port1.close();\n    }\n};\n","import { TGetBackupOfflineAudioContextFactory } from '../types';\n\nexport const createGetBackupOfflineAudioContext: TGetBackupOfflineAudioContextFactory = (backupOfflineAudioContextStore) => {\n    return (nativeContext) => {\n        return backupOfflineAudioContextStore.get(nativeContext);\n    };\n};\n","import { TSetActiveAudioWorkletNodeInputsFactory } from '../types';\n\nexport const createSetActiveAudioWorkletNodeInputs: TSetActiveAudioWorkletNodeInputsFactory = (activeAudioWorkletNodeInputsStore) => {\n    return (nativeAudioWorkletNode, activeInputs) => {\n        activeAudioWorkletNodeInputsStore.set(nativeAudioWorkletNode, activeInputs);\n    };\n};\n","import { TSanitizeAudioWorkletNodeOptionsFunction } from '../types';\n\nexport const sanitizeAudioWorkletNodeOptions: TSanitizeAudioWorkletNodeOptionsFunction = (options) => {\n    return {\n        ...options,\n        outputChannelCount:\n            options.outputChannelCount !== undefined\n                ? options.outputChannelCount\n                : options.numberOfInputs === 1 && options.numberOfOutputs === 1\n                ? /*\n                   * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n                   * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n                   * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n                   */\n                  [options.channelCount]\n                : Array.from({ length: options.numberOfOutputs }, () => 1)\n    };\n};\n","import { TTestAudioWorkletNodeOptionsClonabilityFunction } from '../types';\n\nexport const testAudioWorkletNodeOptionsClonability: TTestAudioWorkletNodeOptionsClonabilityFunction = (audioWorkletNodeOptions) => {\n    const { port1, port2 } = new MessageChannel();\n\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    } finally {\n        port1.close();\n        port2.close();\n    }\n};\n","import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nimport { IAudioContextOptions, IMinimalAudioContext } from '../interfaces';\nimport {\n    TAudioContextState,\n    TMinimalAudioContextConstructorFactory,\n    TNativeAudioContext,\n    TNativeGainNode,\n    TNativeOscillatorNode\n} from '../types';\n\nexport const createMinimalAudioContextConstructor: TMinimalAudioContextConstructorFactory = (\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    minimalBaseAudioContextConstructor,\n    nativeAudioContextConstructor\n) => {\n    return class MinimalAudioContext extends minimalBaseAudioContextConstructor<IMinimalAudioContext> implements IMinimalAudioContext {\n        private _baseLatency: number;\n\n        private _nativeAudioContext: TNativeAudioContext;\n\n        private _nativeGainNode: null | TNativeGainNode;\n\n        private _nativeOscillatorNode: null | TNativeOscillatorNode;\n\n        private _state: null | 'suspended';\n\n        constructor(options: IAudioContextOptions = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n\n            let nativeAudioContext: TNativeAudioContext;\n\n            try {\n                nativeAudioContext = new nativeAudioContextConstructor(options);\n            } catch (err) {\n                // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.\n                if (err.code === 12 && err.message === 'sampleRate is not in range') {\n                    throw createNotSupportedError();\n                }\n\n                throw err;\n            }\n\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n\n            // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(\n                    `The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`\n                );\n            }\n\n            // Bug #150 Safari does not support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n\n            super(nativeAudioContext, 2);\n\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency =\n                typeof nativeAudioContext.baseLatency === 'number'\n                    ? nativeAudioContext.baseLatency\n                    : latencyHint === 'balanced'\n                    ? 512 / sampleRate\n                    : latencyHint === 'interactive' || latencyHint === undefined\n                    ? 256 / sampleRate\n                    : latencyHint === 'playback'\n                    ? 1024 / sampleRate\n                    : /*\n                       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                       * ScriptProcessorNode.\n                       */\n                      (Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate;\n            this._nativeAudioContext = nativeAudioContext;\n\n            // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n            if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                this._nativeGainNode = nativeAudioContext.createGain();\n                this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n\n                this._nativeGainNode.gain.value = 1e-37;\n\n                this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);\n                this._nativeOscillatorNode.start();\n            } else {\n                this._nativeGainNode = null;\n                this._nativeOscillatorNode = null;\n            }\n\n            this._state = null;\n\n            /*\n             * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes\n             * to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n\n        get baseLatency(): number {\n            return this._baseLatency;\n        }\n\n        get state(): TAudioContextState {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n        }\n\n        public close(): Promise<void> {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext.close().then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n\n            return this._nativeAudioContext.close().then(() => {\n                if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {\n                    this._nativeOscillatorNode.stop();\n\n                    this._nativeGainNode.disconnect();\n                    this._nativeOscillatorNode.disconnect();\n                }\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        public resume(): Promise<void> {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        } else {\n                            this.resume().then(resolve, reject);\n                        }\n                    };\n\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n\n            return this._nativeAudioContext.resume().catch((err) => {\n                // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n\n        public suspend(): Promise<void> {\n            return this._nativeAudioContext.suspend().catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n    };\n};\n","import { TCreateNativeOfflineAudioContextFactory } from '../types';\n\nexport const createCreateNativeOfflineAudioContext: TCreateNativeOfflineAudioContextFactory = (\n    createNotSupportedError,\n    nativeOfflineAudioContextConstructor\n) => {\n    return (numberOfChannels, length, sampleRate) => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n\n        try {\n            return new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);\n        } catch (err) {\n            // Bug #143, #144 & #146: Safari throws a SyntaxError when numberOfChannels, length or sampleRate are invalid.\n            if (err.name === 'SyntaxError') {\n                throw createNotSupportedError();\n            }\n\n            throw err;\n        }\n    };\n};\n","import { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { TStartRenderingFactory } from '../types';\n\nexport const createStartRendering: TStartRenderingFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    getAudioNodeRenderer,\n    getUnrenderedAudioWorkletNodes,\n    renderNativeOfflineAudioContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    return (destination, nativeOfflineAudioContext) =>\n        getAudioNodeRenderer(destination)\n            .render(destination, nativeOfflineAudioContext)\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the\n             * destination.\n             */\n            .then(() =>\n                Promise.all(\n                    Array.from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext)).map((audioWorkletNode) =>\n                        getAudioNodeRenderer(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext)\n                    )\n                )\n            )\n            .then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext))\n            .then((audioBuffer) => {\n                // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                if (typeof audioBuffer.copyFromChannel !== 'function') {\n                    wrapAudioBufferCopyChannelMethods(audioBuffer);\n                    wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                    // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n                } else if (\n                    !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                        testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                    )\n                ) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n\n                audioBufferStore.add(audioBuffer);\n\n                return audioBuffer;\n            });\n};\n","import { encode, instantiate } from 'media-encoder-host';\nimport { addRecorderAudioWorkletModule, createRecorderAudioWorkletNode } from 'recorder-audio-worklet';\nimport {\n    AudioBuffer,\n    AudioBufferSourceNode,\n    AudioWorkletNode,\n    ConstantSourceNode,\n    IAudioBuffer,\n    IMinimalAudioContext,\n    MediaStreamAudioSourceNode,\n    MinimalAudioContext,\n    addAudioWorkletModule\n} from 'standardized-audio-context';\nimport { IAudioNodesAndEncoderId } from '../interfaces';\nimport { TRecordingState, TWebAudioMediaRecorderFactoryFactory } from '../types';\n\nconst ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.';\n\n// @todo This should live in a separate file.\nconst createPromisedAudioNodesEncoderIdAndPort = async (\n    audioBuffer: IAudioBuffer,\n    audioContext: IMinimalAudioContext,\n    channelCount: number,\n    mediaStream: MediaStream,\n    mimeType: string\n) => {\n    const { encoderId, port } = await instantiate(mimeType, audioContext.sampleRate);\n\n    if (AudioWorkletNode === undefined) {\n        throw new Error(ERROR_MESSAGE);\n    }\n\n    const audioBufferSourceNode = new AudioBufferSourceNode(audioContext, { buffer: audioBuffer });\n    const mediaStreamAudioSourceNode = new MediaStreamAudioSourceNode(audioContext, { mediaStream });\n    const recorderAudioWorkletNode = createRecorderAudioWorkletNode(AudioWorkletNode, audioContext, { channelCount });\n\n    return { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode };\n};\n\nexport const createWebAudioMediaRecorderFactory: TWebAudioMediaRecorderFactoryFactory = (\n    createBlobEvent,\n    createInvalidModificationError,\n    createInvalidStateError,\n    createNotSupportedError\n) => {\n    return (eventTarget, mediaStream, mimeType) => {\n        const sampleRate = mediaStream.getAudioTracks()[0]?.getSettings().sampleRate;\n        const audioContext = new MinimalAudioContext({ latencyHint: 'playback', sampleRate });\n        const length = Math.max(1024, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\n        const audioBuffer = new AudioBuffer({ length, sampleRate: audioContext.sampleRate });\n        const bufferedArrayBuffers: ArrayBuffer[] = [];\n        const promisedAudioWorkletModule = addRecorderAudioWorkletModule((url: string) => {\n            if (addAudioWorkletModule === undefined) {\n                throw new Error(ERROR_MESSAGE);\n            }\n\n            return addAudioWorkletModule(audioContext, url);\n        });\n\n        let abortRecording: null | (() => void) = null;\n        let intervalId: null | number = null;\n        let promisedAudioNodesAndEncoderId: null | Promise<IAudioNodesAndEncoderId> = null;\n        let promisedPartialRecording: null | Promise<void> = null;\n        let isAudioContextRunning = true;\n\n        const dispatchDataAvailableEvent = (arrayBuffers: ArrayBuffer[]): void => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n\n        const requestNextPartialRecording = async (encoderId: number, timeslice: number): Promise<void> => {\n            const arrayBuffers = await encode(encoderId, timeslice);\n\n            if (promisedAudioNodesAndEncoderId === null) {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            } else {\n                dispatchDataAvailableEvent(arrayBuffers);\n\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            }\n        };\n\n        const resume = (): Promise<void> => {\n            isAudioContextRunning = true;\n\n            return audioContext.resume();\n        };\n\n        const stop = (): void => {\n            if (promisedAudioNodesAndEncoderId === null) {\n                return;\n            }\n\n            if (abortRecording !== null) {\n                mediaStream.removeEventListener('addtrack', abortRecording);\n                mediaStream.removeEventListener('removetrack', abortRecording);\n            }\n\n            if (intervalId !== null) {\n                clearTimeout(intervalId);\n            }\n\n            promisedAudioNodesAndEncoderId.then(\n                async ({ constantSourceNode, encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode }) => {\n                    if (promisedPartialRecording !== null) {\n                        promisedPartialRecording.catch(() => {\n                            /* @todo Only catch the errors caused by a duplicate call to encode. */\n                        });\n                        promisedPartialRecording = null;\n                    }\n\n                    await recorderAudioWorkletNode.stop();\n\n                    mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n                    constantSourceNode.stop();\n\n                    const arrayBuffers = await encode(encoderId, null);\n\n                    if (promisedAudioNodesAndEncoderId === null) {\n                        await suspend();\n                    }\n\n                    dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n\n                    bufferedArrayBuffers.length = 0;\n\n                    eventTarget.dispatchEvent(new Event('stop'));\n                }\n            );\n\n            promisedAudioNodesAndEncoderId = null;\n        };\n\n        const suspend = (): Promise<void> => {\n            isAudioContextRunning = false;\n\n            return audioContext.suspend();\n        };\n\n        suspend();\n\n        return {\n            get mimeType(): string {\n                return mimeType;\n            },\n\n            get state(): TRecordingState {\n                return promisedAudioNodesAndEncoderId === null ? 'inactive' : isAudioContextRunning ? 'recording' : 'paused';\n            },\n\n            pause(): void {\n                if (promisedAudioNodesAndEncoderId === null) {\n                    throw createInvalidStateError();\n                }\n\n                if (isAudioContextRunning) {\n                    suspend();\n                    eventTarget.dispatchEvent(new Event('pause'));\n                }\n            },\n\n            resume(): void {\n                if (promisedAudioNodesAndEncoderId === null) {\n                    throw createInvalidStateError();\n                }\n\n                if (!isAudioContextRunning) {\n                    resume();\n                    eventTarget.dispatchEvent(new Event('resume'));\n                }\n            },\n\n            start(timeslice?: number): void {\n                if (promisedAudioNodesAndEncoderId !== null) {\n                    throw createInvalidStateError();\n                }\n\n                if (mediaStream.getVideoTracks().length > 0) {\n                    throw createNotSupportedError();\n                }\n\n                eventTarget.dispatchEvent(new Event('start'));\n\n                const audioTracks = mediaStream.getAudioTracks();\n                // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n                const channelCount =\n                    audioTracks.length === 0\n                        ? 2\n                        : (<MediaTrackSettings & { channelCount?: number }>audioTracks[0].getSettings()).channelCount ?? 2;\n\n                promisedAudioNodesAndEncoderId = Promise.all([\n                    resume(),\n                    promisedAudioWorkletModule.then(() =>\n                        createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType)\n                    )\n                ]).then(async ([, { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode }]) => {\n                    mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n\n                    await new Promise((resolve) => {\n                        audioBufferSourceNode.onended = resolve;\n                        audioBufferSourceNode.connect(recorderAudioWorkletNode);\n                        audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\n                    });\n\n                    audioBufferSourceNode.disconnect(recorderAudioWorkletNode);\n\n                    // Bug #17: Safari does throttle the processing on hidden tabs if there is no active audio output.\n                    const constantSourceNode = new ConstantSourceNode(audioContext, { offset: 0 });\n\n                    constantSourceNode.onended = () => constantSourceNode.disconnect();\n                    constantSourceNode.connect(audioContext.destination);\n                    constantSourceNode.start();\n\n                    await recorderAudioWorkletNode.record(port);\n\n                    if (timeslice !== undefined) {\n                        promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                    }\n\n                    return { constantSourceNode, encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode };\n                });\n\n                const tracks = mediaStream.getTracks();\n\n                abortRecording = () => {\n                    stop();\n                    eventTarget.dispatchEvent(new ErrorEvent('error', { error: createInvalidModificationError() }));\n                };\n\n                mediaStream.addEventListener('addtrack', abortRecording);\n                mediaStream.addEventListener('removetrack', abortRecording);\n\n                intervalId = setInterval(() => {\n                    const currentTracks = mediaStream.getTracks();\n\n                    if (\n                        (currentTracks.length !== tracks.length || currentTracks.some((track, index) => track !== tracks[index])) &&\n                        abortRecording !== null\n                    ) {\n                        abortRecording();\n                    }\n                }, 1000);\n            },\n\n            stop\n        };\n    };\n};\n","import { IAudioContext, IMinimalAudioContext } from '../interfaces';\nimport { TIsAnyAudioContextFactory, TNativeAudioContext } from '../types';\n\nexport const createIsAnyAudioContext: TIsAnyAudioContextFactory = (contextStore, isNativeAudioContext) => {\n    return (anything): anything is IAudioContext | IMinimalAudioContext | TNativeAudioContext => {\n        const nativeContext = contextStore.get(<any>anything);\n\n        return isNativeAudioContext(nativeContext) || isNativeAudioContext(anything);\n    };\n};\n","import { IAudioNode } from '../interfaces';\nimport { TIsAnyAudioNodeFactory, TNativeAudioNode } from '../types';\n\nexport const createIsAnyAudioNode: TIsAnyAudioNodeFactory = (audioNodeStore, isNativeAudioNode) => {\n    return (anything): anything is IAudioNode<any> | TNativeAudioNode => audioNodeStore.has(<any>anything) || isNativeAudioNode(anything);\n};\n","import { IAudioParam } from '../interfaces';\nimport { TIsAnyAudioParamFactory, TNativeAudioParam } from '../types';\n\nexport const createIsAnyAudioParam: TIsAnyAudioParamFactory = (audioParamStore, isNativeAudioParam) => {\n    return (anything): anything is IAudioParam | TNativeAudioParam => audioParamStore.has(<any>anything) || isNativeAudioParam(anything);\n};\n","import { IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TIsAnyOfflineAudioContextFactory, TNativeOfflineAudioContext } from '../types';\n\nexport const createIsAnyOfflineAudioContext: TIsAnyOfflineAudioContextFactory = (contextStore, isNativeOfflineAudioContext) => {\n    return (anything): anything is IMinimalOfflineAudioContext | IOfflineAudioContext | TNativeOfflineAudioContext => {\n        const nativeContext = contextStore.get(<any>anything);\n\n        return isNativeOfflineAudioContext(nativeContext) || isNativeOfflineAudioContext(anything);\n    };\n};\n","import { register as rgstr } from 'media-encoder-host';\nimport { createBlobEventFactory } from './factories/blob-event-factory';\nimport { createDecodeWebMChunk } from './factories/decode-web-m-chunk';\nimport { createEventTargetConstructor } from './factories/event-target-constructor';\nimport { createEventTargetFactory } from './factories/event-target-factory';\nimport { createInvalidModificationError } from './factories/invalid-modification-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaRecorderConstructor } from './factories/media-recorder-constructor';\nimport { createNativeBlobEventConstructor } from './factories/native-blob-event-constructor';\nimport { createNativeMediaRecorderFactory } from './factories/native-media-recorder';\nimport { createNativeMediaRecorderConstructor } from './factories/native-media-recorder-constructor';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createReadElementContent } from './factories/read-element-content';\nimport { createReadElementType } from './factories/read-element-type';\nimport { createReadVariableSizeInteger } from './factories/read-variable-size-integer';\nimport { createWebAudioMediaRecorderFactory } from './factories/web-audio-media-recorder';\nimport { createWebmPcmMediaRecorderFactory } from './factories/webm-pcm-media-recorder';\nimport { createWindow } from './factories/window';\nimport { readVariableSizeIntegerLength } from './functions/read-variable-size-integer-length';\nimport { wrapEventListener } from './functions/wrap-event-listener';\nimport { IMediaRecorderConstructor } from './interfaces';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nconst encoderRegexes: RegExp[] = [];\n\nconst window = createWindow();\nconst nativeBlobEventConstructor = createNativeBlobEventConstructor(window);\nconst createBlobEvent = createBlobEventFactory(nativeBlobEventConstructor);\nconst createWebAudioMediaRecorder = createWebAudioMediaRecorderFactory(\n    createBlobEvent,\n    createInvalidModificationError,\n    createInvalidStateError,\n    createNotSupportedError\n);\nconst readVariableSizeInteger = createReadVariableSizeInteger(readVariableSizeIntegerLength);\nconst readElementContent = createReadElementContent(readVariableSizeInteger);\nconst readElementType = createReadElementType(readVariableSizeInteger);\nconst decodeWebMChunk = createDecodeWebMChunk(readElementContent, readElementType);\nconst createWebmPcmMediaRecorder = createWebmPcmMediaRecorderFactory(\n    createBlobEvent,\n    createInvalidModificationError,\n    createNotSupportedError,\n    decodeWebMChunk,\n    readVariableSizeInteger\n);\nconst createEventTarget = createEventTargetFactory(window);\nconst nativeMediaRecorderConstructor = createNativeMediaRecorderConstructor(window);\n\nconst createNativeMediaRecorder = createNativeMediaRecorderFactory(createInvalidModificationError, createNotSupportedError);\nconst mediaRecorderConstructor: IMediaRecorderConstructor = createMediaRecorderConstructor(\n    createNativeMediaRecorder,\n    createNotSupportedError,\n    createWebAudioMediaRecorder,\n    createWebmPcmMediaRecorder,\n    encoderRegexes,\n    createEventTargetConstructor(createEventTarget, wrapEventListener),\n    nativeMediaRecorderConstructor\n);\n\nexport { mediaRecorderConstructor as MediaRecorder };\n\nexport const isSupported = () => createIsSupportedPromise(window);\n\nexport const register = async (port: MessagePort): Promise<void> => {\n    encoderRegexes.push(await rgstr(port));\n};\n","import { TWindow, TWindowFactory } from '../types';\n\nexport const createWindow: TWindowFactory = () => (typeof window === 'undefined' ? null : <TWindow>window);\n","import { IBlobEvent } from '../interfaces';\nimport { TBlobEventFactoryFactory } from '../types';\n\nexport const createBlobEventFactory: TBlobEventFactoryFactory = (nativeBlobEventConstructor) => {\n    return (type, blobEventInit) => {\n        // Bug #14: Safari does not yet support the BlobEvent.\n        if (nativeBlobEventConstructor === null) {\n            const { data, ...eventInit } = blobEventInit;\n            const fakeBlobEvent = <IBlobEvent>new Event(type, eventInit);\n\n            (<Omit<IBlobEvent, 'data'> & { -readonly [P in 'data']: IBlobEvent[P] }>fakeBlobEvent).data = data;\n\n            return fakeBlobEvent;\n        }\n\n        return new nativeBlobEventConstructor(type, blobEventInit);\n    };\n};\n","import { TNativeBlobEventConstructorFactory } from '../types';\n\nexport const createNativeBlobEventConstructor: TNativeBlobEventConstructorFactory = (window) => {\n    if (window !== null && window.BlobEvent !== undefined) {\n        return window.BlobEvent;\n    }\n\n    return null;\n};\n","import { TInvalidStateErrorFactory } from '../types';\n\nexport const createInvalidStateError: TInvalidStateErrorFactory = () => {\n    try {\n        return new DOMException('', 'InvalidStateError');\n    } catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 11;\n        err.name = 'InvalidStateError';\n\n        return err;\n    }\n};\n","import { TReadVariableSizeIntegerFactory } from '../types';\n\nexport const createReadVariableSizeInteger: TReadVariableSizeIntegerFactory = (readVariableSizeIntegerLength) => {\n    return (dataView, offset) => {\n        const length = readVariableSizeIntegerLength(dataView, offset);\n\n        if (length === null) {\n            return length;\n        }\n\n        const firstDataByteOffset = offset + Math.floor((length - 1) / 8);\n\n        if (firstDataByteOffset + length > dataView.byteLength) {\n            return null;\n        }\n\n        const firstDataByte = dataView.getUint8(firstDataByteOffset);\n\n        let value = firstDataByte & ((1 << (8 - (length % 8))) - 1); // tslint:disable-line:no-bitwise\n\n        for (let i = 1; i < length; i += 1) {\n            value = (value << 8) + dataView.getUint8(firstDataByteOffset + i); // tslint:disable-line:no-bitwise\n        }\n\n        return { length, value };\n    };\n};\n","import { TReadVariableSizeIntegerLengthFunction } from '../types';\n\nexport const readVariableSizeIntegerLength: TReadVariableSizeIntegerLengthFunction = (dataView, offset) => {\n    if (offset >= dataView.byteLength) {\n        return null;\n    }\n\n    const byte = dataView.getUint8(offset);\n\n    if (byte > 127) {\n        return 1;\n    }\n\n    if (byte > 63) {\n        return 2;\n    }\n\n    if (byte > 31) {\n        return 3;\n    }\n\n    if (byte > 15) {\n        return 4;\n    }\n\n    if (byte > 7) {\n        return 5;\n    }\n\n    if (byte > 3) {\n        return 6;\n    }\n\n    if (byte > 1) {\n        return 7;\n    }\n\n    if (byte > 0) {\n        return 8;\n    }\n\n    const length = readVariableSizeIntegerLength(dataView, offset + 1);\n\n    return length === null ? null : length + 8;\n};\n","import { TReadElementContentFactory } from '../types';\n\nexport const createReadElementContent: TReadElementContentFactory = (readVariableSizeInteger) => {\n    return (dataView, offset, type, channelCount = 2) => {\n        const lengthAndValue = readVariableSizeInteger(dataView, offset);\n\n        if (lengthAndValue === null) {\n            return lengthAndValue;\n        }\n\n        const { length, value } = lengthAndValue;\n\n        if (type === 'master') {\n            return { content: null, length };\n        }\n\n        if (offset + length + value > dataView.byteLength) {\n            return null;\n        }\n\n        if (type === 'binary') {\n            const numberOfSamples = (value / Float32Array.BYTES_PER_ELEMENT - 1) / channelCount;\n            const content = Array.from({ length: channelCount }, () => new Float32Array(numberOfSamples));\n\n            for (let i = 0; i < numberOfSamples; i += 1) {\n                const elementOffset = i * channelCount + 1;\n\n                for (let j = 0; j < channelCount; j += 1) {\n                    content[j][i] = dataView.getFloat32(offset + length + (elementOffset + j) * Float32Array.BYTES_PER_ELEMENT, true);\n                }\n            }\n\n            return { content, length: length + value };\n        }\n\n        return { content: null, length: length + value };\n    };\n};\n","import { TReadElementTypeFactory } from '../types';\n\nexport const createReadElementType: TReadElementTypeFactory = (readVariableSizeInteger) => {\n    return (dataView, offset) => {\n        const lengthAndValue = readVariableSizeInteger(dataView, offset);\n\n        if (lengthAndValue === null) {\n            return lengthAndValue;\n        }\n\n        const { length, value } = lengthAndValue;\n\n        if (value === 35) {\n            return { length, type: 'binary' };\n        }\n\n        if (\n            value === 46 ||\n            value === 97 ||\n            value === 88713574 ||\n            value === 106212971 ||\n            value === 139690087 ||\n            value === 172351395 ||\n            value === 256095861\n        ) {\n            return { length, type: 'master' };\n        }\n\n        return { length, type: 'unknown' };\n    };\n};\n","import { TDecodeWebMChunkFactory } from '../types';\n\nexport const createDecodeWebMChunk: TDecodeWebMChunkFactory = (readElementContent, readElementType) => {\n    return (dataView, elementType, channelCount) => {\n        const contents: (readonly Float32Array[])[] = [];\n\n        let currentElementType = elementType;\n        let offset = 0;\n\n        while (offset < dataView.byteLength) {\n            if (currentElementType === null) {\n                const lengthAndType = readElementType(dataView, offset);\n\n                if (lengthAndType === null) {\n                    break;\n                }\n\n                const { length, type } = lengthAndType;\n\n                currentElementType = type;\n                offset += length;\n            } else {\n                const contentAndLength = readElementContent(dataView, offset, currentElementType, channelCount);\n\n                if (contentAndLength === null) {\n                    break;\n                }\n\n                const { content, length } = contentAndLength;\n\n                currentElementType = null;\n                offset += length;\n\n                if (content !== null) {\n                    contents.push(content);\n                }\n            }\n        }\n\n        return { contents, currentElementType, offset };\n    };\n};\n","import { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nimport { TPromisedDataViewElementTypeEncoderIdAndPort, TRecordingState, TWebmPcmMediaRecorderFactoryFactory } from '../types';\n\nexport const createWebmPcmMediaRecorderFactory: TWebmPcmMediaRecorderFactoryFactory = (\n    createBlobEvent,\n    createInvalidModificationError,\n    createNotSupportedError,\n    decodeWebMChunk,\n    readVariableSizeInteger\n) => {\n    return (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) => {\n        const audioTracks = mediaStream.getAudioTracks();\n        const bufferedArrayBuffers: ArrayBuffer[] = [];\n        // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n        const channelCount =\n            audioTracks.length === 0\n                ? undefined\n                : (<MediaTrackSettings & { channelCount?: number }>audioTracks[0].getSettings()).channelCount;\n        const nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, { mimeType: 'audio/webm;codecs=pcm' });\n        const sampleRate = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().sampleRate;\n\n        let promisedPartialRecording: null | Promise<void> = null;\n        let stopRecording = () => {}; // tslint:disable-line:no-empty\n\n        const dispatchDataAvailableEvent = (arrayBuffers: ArrayBuffer[]): void => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n\n        const requestNextPartialRecording = async (encoderId: number, timeslice: number): Promise<void> => {\n            const arrayBuffers = await encode(encoderId, timeslice);\n\n            if (nativeMediaRecorder.state === 'inactive') {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            } else {\n                dispatchDataAvailableEvent(arrayBuffers);\n\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            }\n        };\n\n        const stop = (): void => {\n            if (nativeMediaRecorder.state === 'inactive') {\n                return;\n            }\n\n            if (promisedPartialRecording !== null) {\n                promisedPartialRecording.catch(() => {\n                    /* @todo Only catch the errors caused by a duplicate call to encode. */\n                });\n                promisedPartialRecording = null;\n            }\n\n            stopRecording();\n            stopRecording = () => {}; // tslint:disable-line:no-empty\n\n            nativeMediaRecorder.stop();\n        };\n\n        nativeMediaRecorder.addEventListener('error', () => {\n            stop();\n            // Bug #3 & #4: Chrome throws an error event without any error.\n            eventTarget.dispatchEvent(new ErrorEvent('error', { error: createInvalidModificationError() }));\n        });\n        nativeMediaRecorder.addEventListener('start', () => eventTarget.dispatchEvent(new Event('start')));\n\n        return {\n            get mimeType(): string {\n                return mimeType;\n            },\n\n            get state(): TRecordingState {\n                return nativeMediaRecorder.state;\n            },\n\n            pause(): void {\n                return nativeMediaRecorder.pause();\n            },\n\n            resume(): void {\n                return nativeMediaRecorder.resume();\n            },\n\n            start(timeslice?: number): void {\n                /*\n                 * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n                 * codec.\n                 */\n                if (mediaStream.getVideoTracks().length > 0) {\n                    throw createNotSupportedError();\n                }\n\n                if (nativeMediaRecorder.state === 'inactive') {\n                    if (sampleRate === undefined) {\n                        throw new Error('The sampleRate is not defined.');\n                    }\n\n                    let isRecording = false;\n                    let isStopped = false;\n                    // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n                    let pendingInvocations = 0;\n                    let promisedDataViewElementTypeEncoderIdAndPort: TPromisedDataViewElementTypeEncoderIdAndPort = instantiate(\n                        mimeType,\n                        sampleRate\n                    );\n\n                    stopRecording = () => {\n                        isStopped = true;\n                    };\n\n                    const removeEventListener = on(\n                        nativeMediaRecorder,\n                        'dataavailable'\n                    )(({ data }) => {\n                        pendingInvocations += 1;\n\n                        promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then(\n                            async ({ dataView = null, elementType = null, encoderId, port }) => {\n                                const arrayBuffer = await data.arrayBuffer();\n\n                                pendingInvocations -= 1;\n\n                                const currentDataView =\n                                    dataView === null\n                                        ? new MultiBufferDataView([arrayBuffer])\n                                        : new MultiBufferDataView([...dataView.buffers, arrayBuffer], dataView.byteOffset);\n\n                                if (!isRecording && nativeMediaRecorder.state === 'recording' && !isStopped) {\n                                    const lengthAndValue = readVariableSizeInteger(currentDataView, 0);\n\n                                    if (lengthAndValue === null) {\n                                        return { dataView: currentDataView, elementType, encoderId, port };\n                                    }\n\n                                    const { value } = lengthAndValue;\n\n                                    if (value !== 172351395) {\n                                        return { dataView, elementType, encoderId, port };\n                                    }\n\n                                    isRecording = true;\n                                }\n\n                                const { currentElementType, offset, contents } = decodeWebMChunk(\n                                    currentDataView,\n                                    elementType,\n                                    channelCount\n                                );\n                                const remainingDataView =\n                                    offset < currentDataView.byteLength\n                                        ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset)\n                                        : null;\n\n                                contents.forEach((content) =>\n                                    port.postMessage(\n                                        content,\n                                        content.map(({ buffer }) => buffer)\n                                    )\n                                );\n\n                                if (pendingInvocations === 0 && (nativeMediaRecorder.state === 'inactive' || isStopped)) {\n                                    encode(encoderId, null).then((arrayBuffers) => {\n                                        dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n\n                                        bufferedArrayBuffers.length = 0;\n\n                                        eventTarget.dispatchEvent(new Event('stop'));\n                                    });\n\n                                    port.postMessage([]);\n                                    port.close();\n\n                                    removeEventListener();\n                                }\n\n                                return { dataView: remainingDataView, elementType: currentElementType, encoderId, port };\n                            }\n                        );\n                    });\n\n                    if (timeslice !== undefined) {\n                        promisedDataViewElementTypeEncoderIdAndPort.then(\n                            ({ encoderId }) => (promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice))\n                        );\n                    }\n                }\n\n                nativeMediaRecorder.start(100);\n            },\n\n            stop\n        };\n    };\n};\n","import { TEventTargetFactoryFactory } from '../types';\n\nexport const createEventTargetFactory: TEventTargetFactoryFactory = (window) => {\n    return () => {\n        if (window === null) {\n            throw new Error('A native EventTarget could not be created.');\n        }\n\n        return window.document.createElement('p');\n    };\n};\n","import { TNativeMediaRecorderConstructorFactory } from '../types';\n\nexport const createNativeMediaRecorderConstructor: TNativeMediaRecorderConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    return window.MediaRecorder === undefined ? null : window.MediaRecorder;\n};\n","import { IBlobEvent, IMediaRecorder } from '../interfaces';\nimport { TEventHandler, TNativeMediaRecorderFactoryFactory } from '../types';\n\nexport const createNativeMediaRecorderFactory: TNativeMediaRecorderFactoryFactory = (\n    createInvalidModificationError,\n    createNotSupportedError\n) => {\n    return (nativeMediaRecorderConstructor, stream, mediaRecorderOptions) => {\n        const bufferedBlobs: Blob[] = [];\n        const dataAvailableListeners = new WeakMap<EventListener, (this: IMediaRecorder, event: IBlobEvent) => void>();\n        const errorListeners = new WeakMap<EventListener, (this: IMediaRecorder, event: ErrorEvent) => void>();\n        const nativeMediaRecorder = new nativeMediaRecorderConstructor(stream, mediaRecorderOptions);\n        const stopListeners = new WeakMap<EventListener, (this: IMediaRecorder, event: Event) => void>();\n\n        let isActive = true;\n\n        nativeMediaRecorder.addEventListener = ((addEventListener) => {\n            return (\n                type: string,\n                listener: null | TEventHandler<IMediaRecorder> | EventListenerOrEventListenerObject,\n                options?: boolean | AddEventListenerOptions\n            ) => {\n                let patchedEventListener = listener;\n\n                if (typeof listener === 'function') {\n                    if (type === 'dataavailable') {\n                        // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n                        patchedEventListener = (event: IBlobEvent) => {\n                            setTimeout(() => {\n                                if (isActive && nativeMediaRecorder.state === 'inactive') {\n                                    bufferedBlobs.push(event.data);\n                                } else {\n                                    if (bufferedBlobs.length > 0) {\n                                        const blob = event.data;\n\n                                        Object.defineProperty(event, 'data', {\n                                            value: new Blob([...bufferedBlobs, blob], { type: blob.type })\n                                        });\n\n                                        bufferedBlobs.length = 0;\n                                    }\n\n                                    listener.call(nativeMediaRecorder, event);\n                                }\n                            });\n                        };\n\n                        dataAvailableListeners.set(listener, patchedEventListener);\n                    } else if (type === 'error') {\n                        // Bug #12 & #13: Firefox fires a regular event with an error property.\n                        patchedEventListener = (event: ErrorEvent | (Event & { error?: Error })) => {\n                            // Bug #3 & #4: Chrome throws an error event without any error.\n                            if (event.error === undefined) {\n                                listener.call(nativeMediaRecorder, new ErrorEvent('error', { error: createInvalidModificationError() }));\n                                // Bug #1 & #2: Firefox throws an error event with an UnknownError.\n                            } else if (event.error.name === 'UnknownError') {\n                                const message = event.error.message;\n\n                                listener.call(\n                                    nativeMediaRecorder,\n                                    new ErrorEvent('error', { error: createInvalidModificationError(message) })\n                                );\n                            } else if (event instanceof ErrorEvent) {\n                                listener.call(nativeMediaRecorder, event);\n                            } else {\n                                listener.call(nativeMediaRecorder, new ErrorEvent('error', { error: event.error }));\n                            }\n                        };\n\n                        errorListeners.set(listener, patchedEventListener);\n                    } else if (type === 'stop') {\n                        // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n                        patchedEventListener = (event: Event) => {\n                            isActive = false;\n\n                            setTimeout(() => listener.call(nativeMediaRecorder, event));\n                        };\n\n                        stopListeners.set(listener, patchedEventListener);\n                    }\n                }\n\n                return addEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n            };\n        })(nativeMediaRecorder.addEventListener);\n\n        nativeMediaRecorder.dispatchEvent = ((dispatchEvent) => {\n            // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n            return (event: Event) => {\n                let wasActive: boolean;\n\n                setTimeout(() => {\n                    wasActive = isActive;\n                    isActive = false;\n                });\n\n                const returnValue = dispatchEvent.call(nativeMediaRecorder, event);\n\n                setTimeout(() => (isActive = wasActive));\n\n                return returnValue;\n            };\n        })(nativeMediaRecorder.dispatchEvent);\n\n        nativeMediaRecorder.removeEventListener = ((removeEventListener) => {\n            return (\n                type: string,\n                listener: null | TEventHandler<IMediaRecorder> | EventListenerOrEventListenerObject,\n                options?: boolean | EventListenerOptions\n            ) => {\n                let patchedEventListener = listener;\n\n                if (typeof listener === 'function') {\n                    if (type === 'dataavailable') {\n                        const dataAvailableListener = dataAvailableListeners.get(listener);\n\n                        if (dataAvailableListener !== undefined) {\n                            patchedEventListener = dataAvailableListener;\n                        }\n                    } else if (type === 'error') {\n                        const errorListener = errorListeners.get(listener);\n\n                        if (errorListener !== undefined) {\n                            patchedEventListener = errorListener;\n                        }\n                    } else if (type === 'stop') {\n                        const stopListener = stopListeners.get(listener);\n\n                        if (stopListener !== undefined) {\n                            patchedEventListener = stopListener;\n                        }\n                    }\n                }\n\n                return removeEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n            };\n        })(nativeMediaRecorder.removeEventListener);\n\n        nativeMediaRecorder.start = ((start) => {\n            return (timeslice?: number) => {\n                /*\n                 * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n                 * codec.\n                 */\n                if (\n                    mediaRecorderOptions.mimeType !== undefined &&\n                    mediaRecorderOptions.mimeType.startsWith('audio/') &&\n                    stream.getVideoTracks().length > 0\n                ) {\n                    throw createNotSupportedError();\n                }\n\n                isActive = timeslice !== undefined;\n\n                return timeslice === undefined ? start.call(nativeMediaRecorder) : start.call(nativeMediaRecorder, timeslice);\n            };\n        })(nativeMediaRecorder.start);\n\n        return nativeMediaRecorder;\n    };\n};\n","import { IMediaRecorder, IMediaRecorderEventMap, IMediaRecorderOptions } from '../interfaces';\nimport {\n    TBlobEventHandler,\n    TErrorEventHandler,\n    TEventHandler,\n    TMediaRecorderConstructorFactory,\n    TNativeEventTarget,\n    TRecordingState\n} from '../types';\n\nexport const createMediaRecorderConstructor: TMediaRecorderConstructorFactory = (\n    createNativeMediaRecorder,\n    createNotSupportedError,\n    createWebAudioMediaRecorder,\n    createWebmPcmMediaRecorder,\n    encoderRegexes,\n    eventTargetConstructor,\n    nativeMediaRecorderConstructor\n) => {\n    return class MediaRecorder extends eventTargetConstructor<IMediaRecorderEventMap> implements IMediaRecorder {\n        private _internalMediaRecorder: Omit<\n            IMediaRecorder,\n            'ondataavailable' | 'onerror' | 'onpause' | 'onresume' | 'onstart' | 'onstop' | keyof TNativeEventTarget\n        >;\n\n        private _ondataavailable: null | [TBlobEventHandler<this>, TBlobEventHandler<this>];\n\n        private _onerror: null | [TErrorEventHandler<this>, TErrorEventHandler<this>];\n\n        private _onpause: null | [TEventHandler<this>, TEventHandler<this>];\n\n        private _onresume: null | [TEventHandler<this>, TEventHandler<this>];\n\n        private _onstart: null | [TEventHandler<this>, TEventHandler<this>];\n\n        private _onstop: null | [TEventHandler<this>, TEventHandler<this>];\n\n        constructor(stream: MediaStream, options: IMediaRecorderOptions = {}) {\n            const { mimeType } = options;\n\n            if (\n                nativeMediaRecorderConstructor !== null &&\n                // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                (mimeType === undefined ||\n                    (nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                        nativeMediaRecorderConstructor.isTypeSupported(mimeType)))\n            ) {\n                const internalMediaRecorder = createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n\n                super(internalMediaRecorder);\n\n                this._internalMediaRecorder = internalMediaRecorder;\n            } else if (mimeType !== undefined && encoderRegexes.some((regex) => regex.test(mimeType))) {\n                super();\n\n                // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                if (\n                    nativeMediaRecorderConstructor !== null &&\n                    nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                    nativeMediaRecorderConstructor.isTypeSupported('audio/webm;codecs=pcm')\n                ) {\n                    this._internalMediaRecorder = createWebmPcmMediaRecorder(this, nativeMediaRecorderConstructor, stream, mimeType);\n                } else {\n                    this._internalMediaRecorder = createWebAudioMediaRecorder(this, stream, mimeType);\n                }\n            } else {\n                // This is creating a native MediaRecorder just to provoke it to throw an error.\n                if (nativeMediaRecorderConstructor !== null) {\n                    createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n                }\n\n                throw createNotSupportedError();\n            }\n\n            this._ondataavailable = null;\n            this._onerror = null;\n            this._onpause = null;\n            this._onresume = null;\n            this._onstart = null;\n            this._onstop = null;\n        }\n\n        get mimeType(): string {\n            return this._internalMediaRecorder.mimeType;\n        }\n\n        get ondataavailable(): null | TBlobEventHandler<this> {\n            return this._ondataavailable === null ? this._ondataavailable : this._ondataavailable[0];\n        }\n\n        set ondataavailable(value) {\n            if (this._ondataavailable !== null) {\n                this.removeEventListener('dataavailable', this._ondataavailable[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('dataavailable', boundListener);\n\n                this._ondataavailable = [value, boundListener];\n            } else {\n                this._ondataavailable = null;\n            }\n        }\n\n        get onerror(): null | TErrorEventHandler<this> {\n            return this._onerror === null ? this._onerror : this._onerror[0];\n        }\n\n        set onerror(value) {\n            if (this._onerror !== null) {\n                this.removeEventListener('error', this._onerror[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('error', boundListener);\n\n                this._onerror = [value, boundListener];\n            } else {\n                this._onerror = null;\n            }\n        }\n\n        get onpause(): null | TEventHandler<this> {\n            return this._onpause === null ? this._onpause : this._onpause[0];\n        }\n\n        set onpause(value) {\n            if (this._onpause !== null) {\n                this.removeEventListener('pause', this._onpause[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('pause', boundListener);\n\n                this._onpause = [value, boundListener];\n            } else {\n                this._onpause = null;\n            }\n        }\n\n        get onresume(): null | TEventHandler<this> {\n            return this._onresume === null ? this._onresume : this._onresume[0];\n        }\n\n        set onresume(value) {\n            if (this._onresume !== null) {\n                this.removeEventListener('resume', this._onresume[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('resume', boundListener);\n\n                this._onresume = [value, boundListener];\n            } else {\n                this._onresume = null;\n            }\n        }\n\n        get onstart(): null | TEventHandler<this> {\n            return this._onstart === null ? this._onstart : this._onstart[0];\n        }\n\n        set onstart(value) {\n            if (this._onstart !== null) {\n                this.removeEventListener('start', this._onstart[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('start', boundListener);\n\n                this._onstart = [value, boundListener];\n            } else {\n                this._onstart = null;\n            }\n        }\n\n        get onstop(): null | TEventHandler<this> {\n            return this._onstop === null ? this._onstop : this._onstop[0];\n        }\n\n        set onstop(value) {\n            if (this._onstop !== null) {\n                this.removeEventListener('stop', this._onstop[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('stop', boundListener);\n\n                this._onstop = [value, boundListener];\n            } else {\n                this._onstop = null;\n            }\n        }\n\n        get state(): TRecordingState {\n            return this._internalMediaRecorder.state;\n        }\n\n        public pause(): void {\n            return this._internalMediaRecorder.pause();\n        }\n\n        public resume(): void {\n            return this._internalMediaRecorder.resume();\n        }\n\n        public start(timeslice?: number): void {\n            return this._internalMediaRecorder.start(timeslice);\n        }\n\n        public stop(): void {\n            return this._internalMediaRecorder.stop();\n        }\n\n        public static isTypeSupported(mimeType: string): boolean {\n            return (\n                (nativeMediaRecorderConstructor !== null &&\n                    // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                    nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                    nativeMediaRecorderConstructor.isTypeSupported(mimeType)) ||\n                encoderRegexes.some((regex) => regex.test(mimeType))\n            );\n        }\n    };\n};\n","import { IEventTarget } from '../interfaces';\nimport { TEventHandler, TEventTargetConstructorFactory, TNativeEventTarget } from '../types';\n\nexport const createEventTargetConstructor: TEventTargetConstructorFactory = (createEventTarget, wrapEventListener) => {\n    return class EventTarget<EventMap extends Record<string, Event>> implements IEventTarget<EventMap> {\n        private _listeners: WeakMap<EventListenerOrEventListenerObject, EventListenerOrEventListenerObject>;\n\n        private _nativeEventTarget: TNativeEventTarget;\n\n        constructor(nativeEventTarget: null | TNativeEventTarget = null) {\n            this._listeners = new WeakMap();\n            this._nativeEventTarget = nativeEventTarget === null ? createEventTarget() : nativeEventTarget;\n        }\n\n        public addEventListener(\n            type: string,\n            listener: null | TEventHandler<this> | EventListenerOrEventListenerObject,\n            options?: boolean | AddEventListenerOptions\n        ): void {\n            if (listener !== null) {\n                let wrappedEventListener = this._listeners.get(listener);\n\n                if (wrappedEventListener === undefined) {\n                    wrappedEventListener = wrapEventListener(this, listener);\n\n                    if (typeof listener === 'function') {\n                        this._listeners.set(listener, wrappedEventListener);\n                    }\n                }\n\n                this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n            }\n        }\n\n        public dispatchEvent(event: Event): boolean {\n            return this._nativeEventTarget.dispatchEvent(event);\n        }\n\n        public removeEventListener(\n            type: string,\n            listener: null | TEventHandler<this> | EventListenerOrEventListenerObject,\n            options?: boolean | EventListenerOptions\n        ): void {\n            const wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);\n\n            this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);\n        }\n    };\n};\n","import { TWrapEventListenerFunction } from '../types';\n\nexport const wrapEventListener: TWrapEventListenerFunction = (target, eventListener) => {\n    return (event) => {\n        const descriptor = { value: target };\n\n        Object.defineProperties(event, {\n            currentTarget: descriptor,\n            target: descriptor\n        });\n\n        if (typeof eventListener === 'function') {\n            return eventListener.call(target, event);\n        }\n\n        return eventListener.handleEvent.call(target, event);\n    };\n};\n","import { TIsSupportedPromiseFactory } from '../types';\n\nexport const createIsSupportedPromise: TIsSupportedPromiseFactory = (window) => {\n    if (\n        window !== null &&\n        window.MediaStream !== undefined &&\n        /*\n         * Bug #10: An early experimental implemenation in Safari did not provide the isTypeSupported() function.\n         */\n        (window.MediaRecorder === undefined || window.MediaRecorder.isTypeSupported !== undefined)\n    ) {\n        /*\n         * Bug #5: Up until v70 Firefox did emit a blob of type video/webm when asked to encode a MediaStream with a video track into an\n         * audio codec.\n         */\n        return new Promise((resolve) => {\n            // Bug #11 Safari does not yet support the MediaRecorder but that isn't tested here.\n            if (window.MediaRecorder === undefined) {\n                return resolve(true);\n            }\n\n            // @todo captureStream() is not defined yet.\n            const canvasElement: HTMLCanvasElement & { captureStream?(): MediaStream } = document.createElement('canvas');\n\n            // @todo https://bugzilla.mozilla.org/show_bug.cgi?id=1388974\n            canvasElement.getContext('2d');\n\n            if (typeof canvasElement.captureStream !== 'function') {\n                return resolve(false);\n            }\n\n            const mediaStream = canvasElement.captureStream();\n            const mimeType = 'audio/webm';\n\n            try {\n                const mediaRecorder = new window.MediaRecorder(mediaStream, { mimeType });\n\n                mediaRecorder.addEventListener('dataavailable', ({ data }) => resolve(data.type === mimeType));\n                mediaRecorder.start();\n\n                setTimeout(() => mediaRecorder.stop(), 10);\n            } catch (err) {\n                resolve(err.name === 'NotSupportedError');\n            }\n        });\n    }\n\n    return Promise.resolve(false);\n};\n","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.fastUniqueNumbers = {}));\n})(this, (function (exports) { 'use strict';\n\n    var createAddUniqueNumber = function createAddUniqueNumber(generateUniqueNumber) {\n      return function (set) {\n        var number = generateUniqueNumber(set);\n        set.add(number);\n        return number;\n      };\n    };\n\n    var createCache = function createCache(lastNumberWeakMap) {\n      return function (collection, nextNumber) {\n        lastNumberWeakMap.set(collection, nextNumber);\n        return nextNumber;\n      };\n    };\n\n    /*\n     * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it\n     * is fairly new.\n     */\n    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;\n    var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;\n    var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;\n    var createGenerateUniqueNumber = function createGenerateUniqueNumber(cache, lastNumberWeakMap) {\n      return function (collection) {\n        var lastNumber = lastNumberWeakMap.get(collection);\n        /*\n         * Let's try the cheapest algorithm first. It might fail to produce a new\n         * number, but it is so cheap that it is okay to take the risk. Just\n         * increase the last number by one or reset it to 0 if we reached the upper\n         * bound of SMIs (which stands for small integers). When the last number is\n         * unknown it is assumed that the collection contains zero based consecutive\n         * numbers.\n         */\n\n        var nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;\n\n        if (!collection.has(nextNumber)) {\n          return cache(collection, nextNumber);\n        }\n        /*\n         * If there are less than half of 2 ** 30 numbers stored in the collection,\n         * the chance to generate a new random number in the range from 0 to 2 ** 30\n         * is at least 50%. It's benifitial to use only SMIs because they perform\n         * much better in any environment based on V8.\n         */\n\n\n        if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {\n          while (collection.has(nextNumber)) {\n            nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);\n          }\n\n          return cache(collection, nextNumber);\n        } // Quickly check if there is a theoretical chance to generate a new number.\n\n\n        if (collection.size > MAX_SAFE_INTEGER) {\n          throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');\n        } // Otherwise use the full scale of safely usable integers.\n\n\n        while (collection.has(nextNumber)) {\n          nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);\n        }\n\n        return cache(collection, nextNumber);\n      };\n    };\n\n    var LAST_NUMBER_WEAK_MAP = new WeakMap();\n    var cache = createCache(LAST_NUMBER_WEAK_MAP);\n    var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);\n    var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);\n\n    exports.addUniqueNumber = addUniqueNumber;\n    exports.generateUniqueNumber = generateUniqueNumber;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n","/*\n * indefinite-article.js v1.0.0, 12-18-2011\n *\n * @author: Rodrigo Neri (@rigoneri)\n *\n * (The MIT License)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nvar indefiniteArticle = function(phrase) {\n    var i, word;\n\n    // Getting the first word\n    var match = /\\w+/.exec(phrase);\n    if (match)\n        word = match[0];\n    else\n        return \"an\";\n\n    var l_word = word.toLowerCase();\n    // Specific start of words that should be preceeded by 'an'\n    var alt_cases = [\"honest\", \"hour\", \"hono\"];\n    for (i in alt_cases) {\n        if (l_word.indexOf(alt_cases[i]) == 0)\n            return \"an\";\n    }\n\n    // Single letter word which should be preceeded by 'an'\n    if (l_word.length == 1) {\n        if (\"aedhilmnorsx\".indexOf(l_word) >= 0)\n            return \"an\";\n        else\n            return \"a\";\n    }\n\n    // Capital words which should likely be preceeded by 'an'\n    if (word.match(/(?!FJO|[HLMNS]Y.|RY[EO]|SQU|(F[LR]?|[HL]|MN?|N|RH?|S[CHKLMNPTVW]?|X(YL)?)[AEIOU])[FHLMNRSX][A-Z]/)) {\n        return \"an\";\n    }\n\n    // Special cases where a word that begins with a vowel should be preceeded by 'a'\n    var regexes = [/^e[uw]/, /^onc?e\\b/, /^uni([^nmd]|mo)/, /^u[bcfhjkqrst][aeiou]/];\n    for (i = 0; i < regexes.length; i++) {\n        if (l_word.match(regexes[i]))\n            return \"a\"\n    }\n\n    // Special capital words (UK, UN)\n    if (word.match(/^U[NK][AIEO]/)) {\n        return \"a\";\n    }\n    else if (word == word.toUpperCase()) {\n        if (\"aedhilmnorsx\".indexOf(l_word[0]) >= 0)\n            return \"an\";\n        else\n            return \"a\";\n    }\n\n    // Basic method of words that begin with a vowel being preceeded by 'an'\n    if (\"aeiou\".indexOf(l_word[0]) >= 0)\n        return \"an\";\n\n    // Instances where y follwed by specific letters is preceeded by 'an'\n    if (l_word.match(/^y(b[lor]|cl[ea]|fere|gg|p[ios]|rou|tt)/))\n        return \"an\";\n\n    return \"a\";\n};\n\nif ((typeof module !== 'undefined') && (typeof module.exports !== 'undefined')) {\n    module.exports = indefiniteArticle;\n} else {\n    window.indefiniteArticle = indefiniteArticle;\n}\n","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.multiBufferDataView = {}, global._slicedToArray, global._classCallCheck, global._createClass));\n})(this, (function (exports, _slicedToArray, _classCallCheck, _createClass) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);\n    var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);\n    var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);\n\n    function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\n    function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\n    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n    var MultiBufferDataView = /*#__PURE__*/function () {\n      function MultiBufferDataView(buffers) {\n        var byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var byteLength = arguments.length > 2 ? arguments[2] : undefined;\n\n        _classCallCheck__default[\"default\"](this, MultiBufferDataView);\n\n        if (byteOffset < 0 || byteLength !== undefined && byteLength < 0) {\n          throw new RangeError();\n        }\n\n        var availableBytes = buffers.reduce(function (length, buffer) {\n          return length + buffer.byteLength;\n        }, 0);\n\n        if (byteOffset > availableBytes || byteLength !== undefined && byteOffset + byteLength > availableBytes) {\n          throw new RangeError();\n        }\n\n        var dataViews = [];\n        var effectiveByteLength = byteLength === undefined ? availableBytes - byteOffset : byteLength;\n        var truncatedBuffers = [];\n        var consumedByteLength = 0;\n        var truncatedByteOffset = byteOffset;\n\n        var _iterator = _createForOfIteratorHelper(buffers),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var buffer = _step.value;\n\n            if (truncatedBuffers.length === 0) {\n              if (buffer.byteLength > truncatedByteOffset) {\n                consumedByteLength = buffer.byteLength - truncatedByteOffset;\n                var byteLengthOfDataView = consumedByteLength > effectiveByteLength ? effectiveByteLength : consumedByteLength;\n                dataViews.push(new DataView(buffer, truncatedByteOffset, byteLengthOfDataView));\n                truncatedBuffers.push(buffer);\n              } else {\n                truncatedByteOffset -= buffer.byteLength;\n              }\n            } else if (consumedByteLength < effectiveByteLength) {\n              consumedByteLength += buffer.byteLength;\n\n              var _byteLengthOfDataView = consumedByteLength > effectiveByteLength ? buffer.byteLength - consumedByteLength + effectiveByteLength : buffer.byteLength;\n\n              dataViews.push(new DataView(buffer, 0, _byteLengthOfDataView));\n              truncatedBuffers.push(buffer);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        this._buffers = truncatedBuffers;\n        this._byteLength = effectiveByteLength;\n        this._byteOffset = truncatedByteOffset;\n        this._dataViews = dataViews;\n        this._internalBuffer = new DataView(new ArrayBuffer(8));\n      }\n\n      _createClass__default[\"default\"](MultiBufferDataView, [{\n        key: \"buffers\",\n        get: function get() {\n          return this._buffers;\n        }\n      }, {\n        key: \"byteLength\",\n        get: function get() {\n          return this._byteLength;\n        }\n      }, {\n        key: \"byteOffset\",\n        get: function get() {\n          return this._byteOffset;\n        }\n      }, {\n        key: \"getFloat32\",\n        value: function getFloat32(byteOffset, littleEndian) {\n          this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n\n          this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n\n          this._internalBuffer.setUint8(2, this.getUint8(byteOffset + 2));\n\n          this._internalBuffer.setUint8(3, this.getUint8(byteOffset + 3));\n\n          return this._internalBuffer.getFloat32(0, littleEndian);\n        }\n      }, {\n        key: \"getFloat64\",\n        value: function getFloat64(byteOffset, littleEndian) {\n          this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n\n          this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n\n          this._internalBuffer.setUint8(2, this.getUint8(byteOffset + 2));\n\n          this._internalBuffer.setUint8(3, this.getUint8(byteOffset + 3));\n\n          this._internalBuffer.setUint8(4, this.getUint8(byteOffset + 4));\n\n          this._internalBuffer.setUint8(5, this.getUint8(byteOffset + 5));\n\n          this._internalBuffer.setUint8(6, this.getUint8(byteOffset + 6));\n\n          this._internalBuffer.setUint8(7, this.getUint8(byteOffset + 7));\n\n          return this._internalBuffer.getFloat64(0, littleEndian);\n        }\n      }, {\n        key: \"getInt16\",\n        value: function getInt16(byteOffset, littleEndian) {\n          this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n\n          this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n\n          return this._internalBuffer.getInt16(0, littleEndian);\n        }\n      }, {\n        key: \"getInt32\",\n        value: function getInt32(byteOffset, littleEndian) {\n          this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n\n          this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n\n          this._internalBuffer.setUint8(2, this.getUint8(byteOffset + 2));\n\n          this._internalBuffer.setUint8(3, this.getUint8(byteOffset + 3));\n\n          return this._internalBuffer.getInt32(0, littleEndian);\n        }\n      }, {\n        key: \"getInt8\",\n        value: function getInt8(byteOffset) {\n          var _this$_findDataViewWi = this._findDataViewWithOffset(byteOffset),\n              _this$_findDataViewWi2 = _slicedToArray__default[\"default\"](_this$_findDataViewWi, 2),\n              dataView = _this$_findDataViewWi2[0],\n              byteOffsetOfDataView = _this$_findDataViewWi2[1];\n\n          return dataView.getInt8(byteOffset - byteOffsetOfDataView);\n        }\n      }, {\n        key: \"getUint16\",\n        value: function getUint16(byteOffset, littleEndian) {\n          this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n\n          this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n\n          return this._internalBuffer.getUint16(0, littleEndian);\n        }\n      }, {\n        key: \"getUint32\",\n        value: function getUint32(byteOffset, littleEndian) {\n          this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n\n          this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n\n          this._internalBuffer.setUint8(2, this.getUint8(byteOffset + 2));\n\n          this._internalBuffer.setUint8(3, this.getUint8(byteOffset + 3));\n\n          return this._internalBuffer.getUint32(0, littleEndian);\n        }\n      }, {\n        key: \"getUint8\",\n        value: function getUint8(byteOffset) {\n          var _this$_findDataViewWi3 = this._findDataViewWithOffset(byteOffset),\n              _this$_findDataViewWi4 = _slicedToArray__default[\"default\"](_this$_findDataViewWi3, 2),\n              dataView = _this$_findDataViewWi4[0],\n              byteOffsetOfDataView = _this$_findDataViewWi4[1];\n\n          return dataView.getUint8(byteOffset - byteOffsetOfDataView);\n        }\n      }, {\n        key: \"setFloat32\",\n        value: function setFloat32(byteOffset, value, littleEndian) {\n          this._internalBuffer.setFloat32(0, value, littleEndian);\n\n          this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n          this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n          this.setUint8(byteOffset + 2, this._internalBuffer.getUint8(2));\n          this.setUint8(byteOffset + 3, this._internalBuffer.getUint8(3));\n        }\n      }, {\n        key: \"setFloat64\",\n        value: function setFloat64(byteOffset, value, littleEndian) {\n          this._internalBuffer.setFloat64(0, value, littleEndian);\n\n          this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n          this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n          this.setUint8(byteOffset + 2, this._internalBuffer.getUint8(2));\n          this.setUint8(byteOffset + 3, this._internalBuffer.getUint8(3));\n          this.setUint8(byteOffset + 4, this._internalBuffer.getUint8(4));\n          this.setUint8(byteOffset + 5, this._internalBuffer.getUint8(5));\n          this.setUint8(byteOffset + 6, this._internalBuffer.getUint8(6));\n          this.setUint8(byteOffset + 7, this._internalBuffer.getUint8(7));\n        }\n      }, {\n        key: \"setInt16\",\n        value: function setInt16(byteOffset, value, littleEndian) {\n          this._internalBuffer.setInt16(0, value, littleEndian);\n\n          this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n          this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n        }\n      }, {\n        key: \"setInt32\",\n        value: function setInt32(byteOffset, value, littleEndian) {\n          this._internalBuffer.setInt32(0, value, littleEndian);\n\n          this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n          this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n          this.setUint8(byteOffset + 2, this._internalBuffer.getUint8(2));\n          this.setUint8(byteOffset + 3, this._internalBuffer.getUint8(3));\n        }\n      }, {\n        key: \"setInt8\",\n        value: function setInt8(byteOffset, value) {\n          var _this$_findDataViewWi5 = this._findDataViewWithOffset(byteOffset),\n              _this$_findDataViewWi6 = _slicedToArray__default[\"default\"](_this$_findDataViewWi5, 2),\n              dataView = _this$_findDataViewWi6[0],\n              byteOffsetOfDataView = _this$_findDataViewWi6[1];\n\n          dataView.setInt8(byteOffset - byteOffsetOfDataView, value);\n        }\n      }, {\n        key: \"setUint16\",\n        value: function setUint16(byteOffset, value, littleEndian) {\n          this._internalBuffer.setUint16(0, value, littleEndian);\n\n          this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n          this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n        }\n      }, {\n        key: \"setUint32\",\n        value: function setUint32(byteOffset, value, littleEndian) {\n          this._internalBuffer.setUint32(0, value, littleEndian);\n\n          this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n          this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n          this.setUint8(byteOffset + 2, this._internalBuffer.getUint8(2));\n          this.setUint8(byteOffset + 3, this._internalBuffer.getUint8(3));\n        }\n      }, {\n        key: \"setUint8\",\n        value: function setUint8(byteOffset, value) {\n          var _this$_findDataViewWi7 = this._findDataViewWithOffset(byteOffset),\n              _this$_findDataViewWi8 = _slicedToArray__default[\"default\"](_this$_findDataViewWi7, 2),\n              dataView = _this$_findDataViewWi8[0],\n              byteOffsetOfDataView = _this$_findDataViewWi8[1];\n\n          dataView.setUint8(byteOffset - byteOffsetOfDataView, value);\n        }\n      }, {\n        key: \"_findDataViewWithOffset\",\n        value: function _findDataViewWithOffset(byteOffset) {\n          var byteOffsetOfDataView = 0;\n\n          var _iterator2 = _createForOfIteratorHelper(this._dataViews),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var dataView = _step2.value;\n              var byteOffsetOfNextDataView = byteOffsetOfDataView + dataView.byteLength;\n\n              if (byteOffset >= byteOffsetOfDataView && byteOffset < byteOffsetOfNextDataView) {\n                return [dataView, byteOffsetOfDataView];\n              }\n\n              byteOffsetOfDataView = byteOffsetOfNextDataView;\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          throw new RangeError();\n        }\n      }]);\n\n      return MultiBufferDataView;\n    }();\n\n    exports.MultiBufferDataView = MultiBufferDataView;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bigint: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (process.env.NODE_ENV !== 'production') {\n  var ReactIs = require('react-is');\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = require('./factoryWithTypeCheckers')(ReactIs.isElement, throwOnDirectAccess);\n} else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = require('./factoryWithThrowingShims')();\n}\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n","import classNames from 'classnames';\nimport * as React from 'react';\nimport Anchor from '@restart/ui/Anchor';\nimport { useBootstrapPrefix } from './ThemeProvider';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst defaultProps = {\n  active: false,\n  linkProps: {}\n};\nconst BreadcrumbItem = /*#__PURE__*/React.forwardRef(({\n  bsPrefix,\n  active,\n  children,\n  className,\n  // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n  as: Component = 'li',\n  linkAs: LinkComponent = Anchor,\n  linkProps,\n  href,\n  title,\n  target,\n  ...props\n}, ref) => {\n  const prefix = useBootstrapPrefix(bsPrefix, 'breadcrumb-item');\n  return /*#__PURE__*/_jsx(Component, {\n    ref: ref,\n    ...props,\n    className: classNames(prefix, className, {\n      active\n    }),\n    \"aria-current\": active ? 'page' : undefined,\n    children: active ? children : /*#__PURE__*/_jsx(LinkComponent, { ...linkProps,\n      href: href,\n      title: title,\n      target: target,\n      children: children\n    })\n  });\n});\nBreadcrumbItem.displayName = 'BreadcrumbItem';\nBreadcrumbItem.defaultProps = defaultProps;\nexport default BreadcrumbItem;","import classNames from 'classnames';\nimport * as React from 'react';\nimport { useBootstrapPrefix } from './ThemeProvider';\nimport BreadcrumbItem from './BreadcrumbItem';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst defaultProps = {\n  label: 'breadcrumb',\n  listProps: {}\n};\nconst Breadcrumb = /*#__PURE__*/React.forwardRef(({\n  bsPrefix,\n  className,\n  listProps,\n  children,\n  label,\n  // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n  as: Component = 'nav',\n  ...props\n}, ref) => {\n  const prefix = useBootstrapPrefix(bsPrefix, 'breadcrumb');\n  return /*#__PURE__*/_jsx(Component, {\n    \"aria-label\": label,\n    className: className,\n    ref: ref,\n    ...props,\n    children: /*#__PURE__*/_jsx(\"ol\", { ...listProps,\n      className: classNames(prefix, listProps == null ? void 0 : listProps.className),\n      children: children\n    })\n  });\n});\nBreadcrumb.displayName = 'Breadcrumb';\nBreadcrumb.defaultProps = defaultProps;\nexport default Object.assign(Breadcrumb, {\n  Item: BreadcrumbItem\n});","import classNames from 'classnames';\nimport * as React from 'react';\nimport { useBootstrapPrefix } from './ThemeProvider';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst CardImg = /*#__PURE__*/React.forwardRef( // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n({\n  bsPrefix,\n  className,\n  variant,\n  as: Component = 'img',\n  ...props\n}, ref) => {\n  const prefix = useBootstrapPrefix(bsPrefix, 'card-img');\n  return /*#__PURE__*/_jsx(Component, {\n    ref: ref,\n    className: classNames(variant ? `${prefix}-${variant}` : prefix, className),\n    ...props\n  });\n});\nCardImg.displayName = 'CardImg';\nexport default CardImg;","import classNames from 'classnames';\nimport * as React from 'react';\nimport { useMemo } from 'react';\nimport { useBootstrapPrefix } from './ThemeProvider';\nimport CardHeaderContext from './CardHeaderContext';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst CardHeader = /*#__PURE__*/React.forwardRef(({\n  bsPrefix,\n  className,\n  // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n  as: Component = 'div',\n  ...props\n}, ref) => {\n  const prefix = useBootstrapPrefix(bsPrefix, 'card-header');\n  const contextValue = useMemo(() => ({\n    cardHeaderBsPrefix: prefix\n  }), [prefix]);\n  return /*#__PURE__*/_jsx(CardHeaderContext.Provider, {\n    value: contextValue,\n    children: /*#__PURE__*/_jsx(Component, {\n      ref: ref,\n      ...props,\n      className: classNames(className, prefix)\n    })\n  });\n});\nCardHeader.displayName = 'CardHeader';\nexport default CardHeader;","import classNames from 'classnames';\nimport * as React from 'react';\nimport { useBootstrapPrefix } from './ThemeProvider';\nimport createWithBsPrefix from './createWithBsPrefix';\nimport divWithClassName from './divWithClassName';\nimport CardImg from './CardImg';\nimport CardHeader from './CardHeader';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst DivStyledAsH5 = divWithClassName('h5');\nconst DivStyledAsH6 = divWithClassName('h6');\nconst CardBody = createWithBsPrefix('card-body');\nconst CardTitle = createWithBsPrefix('card-title', {\n  Component: DivStyledAsH5\n});\nconst CardSubtitle = createWithBsPrefix('card-subtitle', {\n  Component: DivStyledAsH6\n});\nconst CardLink = createWithBsPrefix('card-link', {\n  Component: 'a'\n});\nconst CardText = createWithBsPrefix('card-text', {\n  Component: 'p'\n});\nconst CardFooter = createWithBsPrefix('card-footer');\nconst CardImgOverlay = createWithBsPrefix('card-img-overlay');\nconst defaultProps = {\n  body: false\n};\nconst Card = /*#__PURE__*/React.forwardRef(({\n  bsPrefix,\n  className,\n  bg,\n  text,\n  border,\n  body,\n  children,\n  // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n  as: Component = 'div',\n  ...props\n}, ref) => {\n  const prefix = useBootstrapPrefix(bsPrefix, 'card');\n  return /*#__PURE__*/_jsx(Component, {\n    ref: ref,\n    ...props,\n    className: classNames(className, prefix, bg && `bg-${bg}`, text && `text-${text}`, border && `border-${border}`),\n    children: body ? /*#__PURE__*/_jsx(CardBody, {\n      children: children\n    }) : children\n  });\n});\nCard.displayName = 'Card';\nCard.defaultProps = defaultProps;\nexport default Object.assign(Card, {\n  Img: CardImg,\n  Title: CardTitle,\n  Subtitle: CardSubtitle,\n  Body: CardBody,\n  Link: CardLink,\n  Text: CardText,\n  Header: CardHeader,\n  Footer: CardFooter,\n  ImgOverlay: CardImgOverlay\n});","import * as React from 'react';\nconst context = /*#__PURE__*/React.createContext(null);\ncontext.displayName = 'CardHeaderContext';\nexport default context;","import classNames from 'classnames';\nimport * as React from 'react';\nimport { useBootstrapPrefix, useBootstrapBreakpoints } from './ThemeProvider';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function useCol({\n  as,\n  bsPrefix,\n  className,\n  ...props\n}) {\n  bsPrefix = useBootstrapPrefix(bsPrefix, 'col');\n  const breakpoints = useBootstrapBreakpoints();\n  const spans = [];\n  const classes = [];\n  breakpoints.forEach(brkPoint => {\n    const propValue = props[brkPoint];\n    delete props[brkPoint];\n    let span;\n    let offset;\n    let order;\n\n    if (typeof propValue === 'object' && propValue != null) {\n      ({\n        span,\n        offset,\n        order\n      } = propValue);\n    } else {\n      span = propValue;\n    }\n\n    const infix = brkPoint !== 'xs' ? `-${brkPoint}` : '';\n    if (span) spans.push(span === true ? `${bsPrefix}${infix}` : `${bsPrefix}${infix}-${span}`);\n    if (order != null) classes.push(`order${infix}-${order}`);\n    if (offset != null) classes.push(`offset${infix}-${offset}`);\n  });\n  return [{ ...props,\n    className: classNames(className, ...spans, ...classes)\n  }, {\n    as,\n    bsPrefix,\n    spans\n  }];\n}\nconst Col = /*#__PURE__*/React.forwardRef( // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n(props, ref) => {\n  const [{\n    className,\n    ...colProps\n  }, {\n    as: Component = 'div',\n    bsPrefix,\n    spans\n  }] = useCol(props);\n  return /*#__PURE__*/_jsx(Component, { ...colProps,\n    ref: ref,\n    className: classNames(className, !spans.length && bsPrefix)\n  });\n});\nCol.displayName = 'Col';\nexport default Col;","import * as React from 'react';\n/**\n * Iterates through children that are typically specified as `props.children`,\n * but only maps over children that are \"valid elements\".\n *\n * The mapFunction provided index will be normalised to the components mapped,\n * so an invalid component would not increase the index.\n *\n */\n\nfunction map(children, func) {\n  let index = 0;\n  return React.Children.map(children, child => /*#__PURE__*/React.isValidElement(child) ? func(child, index++) : child);\n}\n/**\n * Iterates through children that are \"valid elements\".\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child with the index reflecting the position relative to \"valid components\".\n */\n\n\nfunction forEach(children, func) {\n  let index = 0;\n  React.Children.forEach(children, child => {\n    if ( /*#__PURE__*/React.isValidElement(child)) func(child, index++);\n  });\n}\n/**\n * Finds whether a component's `children` prop includes a React element of the\n * specified type.\n */\n\n\nfunction hasChildOfType(children, type) {\n  return React.Children.toArray(children).some(child => /*#__PURE__*/React.isValidElement(child) && child.type === type);\n}\n\nexport { map, forEach, hasChildOfType };","import classNames from 'classnames';\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst propTypes = {\n  /**\n   * Specify whether the feedback is for valid or invalid fields\n   *\n   * @type {('valid'|'invalid')}\n   */\n  type: PropTypes.string,\n\n  /** Display feedback as a tooltip. */\n  tooltip: PropTypes.bool,\n  as: PropTypes.elementType\n};\nconst Feedback = /*#__PURE__*/React.forwardRef( // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n({\n  as: Component = 'div',\n  className,\n  type = 'valid',\n  tooltip = false,\n  ...props\n}, ref) => /*#__PURE__*/_jsx(Component, { ...props,\n  ref: ref,\n  className: classNames(className, `${type}-${tooltip ? 'tooltip' : 'feedback'}`)\n}));\nFeedback.displayName = 'Feedback';\nFeedback.propTypes = propTypes;\nexport default Feedback;","import classNames from 'classnames';\nimport * as React from 'react';\nimport { useContext } from 'react';\nimport FormContext from './FormContext';\nimport { useBootstrapPrefix } from './ThemeProvider';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst FormCheckLabel = /*#__PURE__*/React.forwardRef(({\n  bsPrefix,\n  className,\n  htmlFor,\n  ...props\n}, ref) => {\n  const {\n    controlId\n  } = useContext(FormContext);\n  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-check-label');\n  return /*#__PURE__*/_jsx(\"label\", { ...props,\n    ref: ref,\n    htmlFor: htmlFor || controlId,\n    className: classNames(className, bsPrefix)\n  });\n});\nFormCheckLabel.displayName = 'FormCheckLabel';\nexport default FormCheckLabel;","import classNames from 'classnames';\nimport * as React from 'react';\nimport { useContext, useMemo } from 'react';\nimport Feedback from './Feedback';\nimport FormCheckInput from './FormCheckInput';\nimport FormCheckLabel from './FormCheckLabel';\nimport FormContext from './FormContext';\nimport { useBootstrapPrefix } from './ThemeProvider';\nimport { hasChildOfType } from './ElementChildren';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nconst FormCheck = /*#__PURE__*/React.forwardRef(({\n  id,\n  bsPrefix,\n  bsSwitchPrefix,\n  inline = false,\n  disabled = false,\n  isValid = false,\n  isInvalid = false,\n  feedbackTooltip = false,\n  feedback,\n  feedbackType,\n  className,\n  style,\n  title = '',\n  type = 'checkbox',\n  label,\n  children,\n  // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n  as = 'input',\n  ...props\n}, ref) => {\n  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-check');\n  bsSwitchPrefix = useBootstrapPrefix(bsSwitchPrefix, 'form-switch');\n  const {\n    controlId\n  } = useContext(FormContext);\n  const innerFormContext = useMemo(() => ({\n    controlId: id || controlId\n  }), [controlId, id]);\n  const hasLabel = !children && label != null && label !== false || hasChildOfType(children, FormCheckLabel);\n\n  const input = /*#__PURE__*/_jsx(FormCheckInput, { ...props,\n    type: type === 'switch' ? 'checkbox' : type,\n    ref: ref,\n    isValid: isValid,\n    isInvalid: isInvalid,\n    disabled: disabled,\n    as: as\n  });\n\n  return /*#__PURE__*/_jsx(FormContext.Provider, {\n    value: innerFormContext,\n    children: /*#__PURE__*/_jsx(\"div\", {\n      style: style,\n      className: classNames(className, hasLabel && bsPrefix, inline && `${bsPrefix}-inline`, type === 'switch' && bsSwitchPrefix),\n      children: children || /*#__PURE__*/_jsxs(_Fragment, {\n        children: [input, hasLabel && /*#__PURE__*/_jsx(FormCheckLabel, {\n          title: title,\n          children: label\n        }), feedback && /*#__PURE__*/_jsx(Feedback, {\n          type: feedbackType,\n          tooltip: feedbackTooltip,\n          children: feedback\n        })]\n      })\n    })\n  });\n});\nFormCheck.displayName = 'FormCheck';\nexport default Object.assign(FormCheck, {\n  Input: FormCheckInput,\n  Label: FormCheckLabel\n});","import classNames from 'classnames';\nimport * as React from 'react';\nimport { useContext } from 'react';\nimport warning from 'warning';\nimport Feedback from './Feedback';\nimport FormContext from './FormContext';\nimport { useBootstrapPrefix } from './ThemeProvider';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst FormControl = /*#__PURE__*/React.forwardRef(({\n  bsPrefix,\n  type,\n  size,\n  htmlSize,\n  id,\n  className,\n  isValid = false,\n  isInvalid = false,\n  plaintext,\n  readOnly,\n  // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n  as: Component = 'input',\n  ...props\n}, ref) => {\n  const {\n    controlId\n  } = useContext(FormContext);\n  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-control');\n  let classes;\n\n  if (plaintext) {\n    classes = {\n      [`${bsPrefix}-plaintext`]: true\n    };\n  } else {\n    classes = {\n      [bsPrefix]: true,\n      [`${bsPrefix}-${size}`]: size\n    };\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(controlId == null || !id, '`controlId` is ignored on `<FormControl>` when `id` is specified.') : void 0;\n  return /*#__PURE__*/_jsx(Component, { ...props,\n    type: type,\n    size: htmlSize,\n    ref: ref,\n    readOnly: readOnly,\n    id: id || controlId,\n    className: classNames(className, classes, isValid && `is-valid`, isInvalid && `is-invalid`, type === 'color' && `${bsPrefix}-color`)\n  });\n});\nFormControl.displayName = 'FormControl';\nexport default Object.assign(FormControl, {\n  Feedback\n});","import createWithBsPrefix from './createWithBsPrefix';\nexport default createWithBsPrefix('form-floating');","import * as React from 'react';\nimport { useMemo } from 'react';\nimport FormContext from './FormContext';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst FormGroup = /*#__PURE__*/React.forwardRef(({\n  controlId,\n  // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n  as: Component = 'div',\n  ...props\n}, ref) => {\n  const context = useMemo(() => ({\n    controlId\n  }), [controlId]);\n  return /*#__PURE__*/_jsx(FormContext.Provider, {\n    value: context,\n    children: /*#__PURE__*/_jsx(Component, { ...props,\n      ref: ref\n    })\n  });\n});\nFormGroup.displayName = 'FormGroup';\nexport default FormGroup;","import classNames from 'classnames';\nimport * as React from 'react';\nimport { useContext } from 'react';\nimport warning from 'warning';\nimport Col from './Col';\nimport FormContext from './FormContext';\nimport { useBootstrapPrefix } from './ThemeProvider';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst defaultProps = {\n  column: false,\n  visuallyHidden: false\n};\nconst FormLabel = /*#__PURE__*/React.forwardRef(({\n  // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n  as: Component = 'label',\n  bsPrefix,\n  column,\n  visuallyHidden,\n  className,\n  htmlFor,\n  ...props\n}, ref) => {\n  const {\n    controlId\n  } = useContext(FormContext);\n  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-label');\n  let columnClass = 'col-form-label';\n  if (typeof column === 'string') columnClass = `${columnClass} ${columnClass}-${column}`;\n  const classes = classNames(className, bsPrefix, visuallyHidden && 'visually-hidden', column && columnClass);\n  process.env.NODE_ENV !== \"production\" ? warning(controlId == null || !htmlFor, '`controlId` is ignored on `<FormLabel>` when `htmlFor` is specified.') : void 0;\n  htmlFor = htmlFor || controlId;\n  if (column) return /*#__PURE__*/_jsx(Col, {\n    ref: ref,\n    as: \"label\",\n    className: classes,\n    htmlFor: htmlFor,\n    ...props\n  });\n  return (\n    /*#__PURE__*/\n    // eslint-disable-next-line jsx-a11y/label-has-for, jsx-a11y/label-has-associated-control\n    _jsx(Component, {\n      ref: ref,\n      className: classes,\n      htmlFor: htmlFor,\n      ...props\n    })\n  );\n});\nFormLabel.displayName = 'FormLabel';\nFormLabel.defaultProps = defaultProps;\nexport default FormLabel;","import classNames from 'classnames';\nimport * as React from 'react';\nimport { useContext } from 'react';\nimport { useBootstrapPrefix } from './ThemeProvider';\nimport FormContext from './FormContext';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst FormRange = /*#__PURE__*/React.forwardRef(({\n  bsPrefix,\n  className,\n  id,\n  ...props\n}, ref) => {\n  const {\n    controlId\n  } = useContext(FormContext);\n  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-range');\n  return /*#__PURE__*/_jsx(\"input\", { ...props,\n    type: \"range\",\n    ref: ref,\n    className: classNames(className, bsPrefix),\n    id: id || controlId\n  });\n});\nFormRange.displayName = 'FormRange';\nexport default FormRange;","import classNames from 'classnames';\nimport * as React from 'react';\nimport { useContext } from 'react';\nimport { useBootstrapPrefix } from './ThemeProvider';\nimport FormContext from './FormContext';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst FormSelect = /*#__PURE__*/React.forwardRef(({\n  bsPrefix,\n  size,\n  htmlSize,\n  className,\n  isValid = false,\n  isInvalid = false,\n  id,\n  ...props\n}, ref) => {\n  const {\n    controlId\n  } = useContext(FormContext);\n  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-select');\n  return /*#__PURE__*/_jsx(\"select\", { ...props,\n    size: htmlSize,\n    ref: ref,\n    className: classNames(className, bsPrefix, size && `${bsPrefix}-${size}`, isValid && `is-valid`, isInvalid && `is-invalid`),\n    id: id || controlId\n  });\n});\nFormSelect.displayName = 'FormSelect';\nexport default FormSelect;","import classNames from 'classnames';\nimport * as React from 'react';\nimport { useBootstrapPrefix } from './ThemeProvider';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst FormText = /*#__PURE__*/React.forwardRef( // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n({\n  bsPrefix,\n  className,\n  as: Component = 'small',\n  muted,\n  ...props\n}, ref) => {\n  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-text');\n  return /*#__PURE__*/_jsx(Component, { ...props,\n    ref: ref,\n    className: classNames(className, bsPrefix, muted && 'text-muted')\n  });\n});\nFormText.displayName = 'FormText';\nexport default FormText;","import * as React from 'react';\nimport FormCheck from './FormCheck';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst Switch = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/_jsx(FormCheck, { ...props,\n  ref: ref,\n  type: \"switch\"\n}));\nSwitch.displayName = 'Switch';\nexport default Object.assign(Switch, {\n  Input: FormCheck.Input,\n  Label: FormCheck.Label\n});","import classNames from 'classnames';\nimport * as React from 'react';\nimport FormGroup from './FormGroup';\nimport { useBootstrapPrefix } from './ThemeProvider';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nconst FloatingLabel = /*#__PURE__*/React.forwardRef(({\n  bsPrefix,\n  className,\n  children,\n  controlId,\n  label,\n  ...props\n}, ref) => {\n  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-floating');\n  return /*#__PURE__*/_jsxs(FormGroup, {\n    ref: ref,\n    className: classNames(className, bsPrefix),\n    controlId: controlId,\n    ...props,\n    children: [children, /*#__PURE__*/_jsx(\"label\", {\n      htmlFor: controlId,\n      children: label\n    })]\n  });\n});\nFloatingLabel.displayName = 'FloatingLabel';\nexport default FloatingLabel;","import classNames from 'classnames';\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport FormCheck from './FormCheck';\nimport FormControl from './FormControl';\nimport FormFloating from './FormFloating';\nimport FormGroup from './FormGroup';\nimport FormLabel from './FormLabel';\nimport FormRange from './FormRange';\nimport FormSelect from './FormSelect';\nimport FormText from './FormText';\nimport Switch from './Switch';\nimport FloatingLabel from './FloatingLabel';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst propTypes = {\n  /**\n   * The Form `ref` will be forwarded to the underlying element,\n   * which means, unless it's rendered `as` a composite component,\n   * it will be a DOM node, when resolved.\n   *\n   * @type {ReactRef}\n   * @alias ref\n   */\n  _ref: PropTypes.any,\n\n  /**\n   * Mark a form as having been validated. Setting it to `true` will\n   * toggle any validation styles on the forms elements.\n   */\n  validated: PropTypes.bool,\n  as: PropTypes.elementType\n};\nconst Form = /*#__PURE__*/React.forwardRef(({\n  className,\n  validated,\n  // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n  as: Component = 'form',\n  ...props\n}, ref) => /*#__PURE__*/_jsx(Component, { ...props,\n  ref: ref,\n  className: classNames(className, validated && 'was-validated')\n}));\nForm.displayName = 'Form';\nForm.propTypes = propTypes;\nexport default Object.assign(Form, {\n  Group: FormGroup,\n  Control: FormControl,\n  Floating: FormFloating,\n  Check: FormCheck,\n  Switch,\n  Label: FormLabel,\n  Text: FormText,\n  Range: FormRange,\n  Select: FormSelect,\n  FloatingLabel\n});","import classNames from 'classnames';\nimport * as React from 'react';\nimport { useContext } from 'react';\nimport FormContext from './FormContext';\nimport { useBootstrapPrefix } from './ThemeProvider';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst FormCheckInput = /*#__PURE__*/React.forwardRef(({\n  id,\n  bsPrefix,\n  className,\n  type = 'checkbox',\n  isValid = false,\n  isInvalid = false,\n  // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n  as: Component = 'input',\n  ...props\n}, ref) => {\n  const {\n    controlId\n  } = useContext(FormContext);\n  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-check-input');\n  return /*#__PURE__*/_jsx(Component, { ...props,\n    ref: ref,\n    type: type,\n    id: id || controlId,\n    className: classNames(className, bsPrefix, isValid && 'is-valid', isInvalid && 'is-invalid')\n  });\n});\nFormCheckInput.displayName = 'FormCheckInput';\nexport default FormCheckInput;","import * as React from 'react'; // TODO\n\nconst FormContext = /*#__PURE__*/React.createContext({});\nexport default FormContext;","import classNames from 'classnames';\nimport * as React from 'react';\nimport { useMemo } from 'react';\nimport createWithBsPrefix from './createWithBsPrefix';\nimport { useBootstrapPrefix } from './ThemeProvider';\nimport FormCheckInput from './FormCheckInput';\nimport InputGroupContext from './InputGroupContext';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst InputGroupText = createWithBsPrefix('input-group-text', {\n  Component: 'span'\n});\n\nconst InputGroupCheckbox = props => /*#__PURE__*/_jsx(InputGroupText, {\n  children: /*#__PURE__*/_jsx(FormCheckInput, {\n    type: \"checkbox\",\n    ...props\n  })\n});\n\nconst InputGroupRadio = props => /*#__PURE__*/_jsx(InputGroupText, {\n  children: /*#__PURE__*/_jsx(FormCheckInput, {\n    type: \"radio\",\n    ...props\n  })\n});\n\n/**\n *\n * @property {InputGroupText} Text\n * @property {InputGroupRadio} Radio\n * @property {InputGroupCheckbox} Checkbox\n */\nconst InputGroup = /*#__PURE__*/React.forwardRef(({\n  bsPrefix,\n  size,\n  hasValidation,\n  className,\n  // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n  as: Component = 'div',\n  ...props\n}, ref) => {\n  bsPrefix = useBootstrapPrefix(bsPrefix, 'input-group'); // Intentionally an empty object. Used in detecting if a dropdown\n  // exists under an input group.\n\n  const contextValue = useMemo(() => ({}), []);\n  return /*#__PURE__*/_jsx(InputGroupContext.Provider, {\n    value: contextValue,\n    children: /*#__PURE__*/_jsx(Component, {\n      ref: ref,\n      ...props,\n      className: classNames(className, bsPrefix, size && `${bsPrefix}-${size}`, hasValidation && 'has-validation')\n    })\n  });\n});\nInputGroup.displayName = 'InputGroup';\nexport default Object.assign(InputGroup, {\n  Text: InputGroupText,\n  Radio: InputGroupRadio,\n  Checkbox: InputGroupCheckbox\n});","import classNames from 'classnames';\nimport * as React from 'react';\nimport { useBootstrapPrefix, useBootstrapBreakpoints } from './ThemeProvider';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst Row = /*#__PURE__*/React.forwardRef(({\n  bsPrefix,\n  className,\n  // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n  as: Component = 'div',\n  ...props\n}, ref) => {\n  const decoratedBsPrefix = useBootstrapPrefix(bsPrefix, 'row');\n  const breakpoints = useBootstrapBreakpoints();\n  const sizePrefix = `${decoratedBsPrefix}-cols`;\n  const classes = [];\n  breakpoints.forEach(brkPoint => {\n    const propValue = props[brkPoint];\n    delete props[brkPoint];\n    let cols;\n\n    if (propValue != null && typeof propValue === 'object') {\n      ({\n        cols\n      } = propValue);\n    } else {\n      cols = propValue;\n    }\n\n    const infix = brkPoint !== 'xs' ? `-${brkPoint}` : '';\n    if (cols != null) classes.push(`${sizePrefix}${infix}-${cols}`);\n  });\n  return /*#__PURE__*/_jsx(Component, {\n    ref: ref,\n    ...props,\n    className: classNames(className, decoratedBsPrefix, ...classes)\n  });\n});\nRow.displayName = 'Row';\nexport default Row;","import * as React from 'react';\nimport classNames from 'classnames';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default (className => /*#__PURE__*/React.forwardRef((p, ref) => /*#__PURE__*/_jsx(\"div\", { ...p,\n  ref: ref,\n  className: classNames(p.className, className)\n})));","module.exports = require(\"./lib\");\n","\"use strict\";var __awaiter=(this&&this.__awaiter)||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}\nreturn new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}\nfunction rejected(value){try{step(generator[\"throw\"](value));}catch(e){reject(e);}}\nfunction step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}\nstep((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=(this&&this.__generator)||function(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),\"throw\":verb(1),\"return\":verb(2)},typeof Symbol===\"function\"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}\nfunction step(op){if(f)throw new TypeError(\"Generator is already executing.\");while(_)try{if(f=1,y&&(t=op[0]&2?y[\"return\"]:op[0]?y[\"throw\"]||((t=y[\"return\"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}\nif(op[0]===3&&(!t||(op[1]>t[0]&&op[1]<t[3]))){_.label=op[1];break;}\nif(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}\nif(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}\nif(t[2])_.ops.pop();_.trys.pop();continue;}\nop=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}\nif(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};Object.defineProperty(exports,\"__esModule\",{value:true});exports.ReactMediaRecorder=exports.useReactMediaRecorder=exports.RecorderErrors=void 0;var extendable_media_recorder_1=require(\"extendable-media-recorder\");var react_1=require(\"react\");var extendable_media_recorder_wav_encoder_1=require(\"extendable-media-recorder-wav-encoder\");var RecorderErrors;(function(RecorderErrors){RecorderErrors[\"AbortError\"]=\"media_aborted\";RecorderErrors[\"NotAllowedError\"]=\"permission_denied\";RecorderErrors[\"NotFoundError\"]=\"no_specified_media_found\";RecorderErrors[\"NotReadableError\"]=\"media_in_use\";RecorderErrors[\"OverconstrainedError\"]=\"invalid_media_constraints\";RecorderErrors[\"TypeError\"]=\"no_constraints\";RecorderErrors[\"NONE\"]=\"\";RecorderErrors[\"NO_RECORDER\"]=\"recorder_error\";})(RecorderErrors=exports.RecorderErrors||(exports.RecorderErrors={}));function useReactMediaRecorder(_a){var _this=this;var _b=_a.audio,audio=_b===void 0?true:_b,_c=_a.video,video=_c===void 0?false:_c,_d=_a.onStop,onStop=_d===void 0?function(){return null;}:_d,_e=_a.onStart,onStart=_e===void 0?function(){return null;}:_e,blobPropertyBag=_a.blobPropertyBag,_f=_a.screen,screen=_f===void 0?false:_f,_g=_a.mediaRecorderOptions,mediaRecorderOptions=_g===void 0?undefined:_g,_h=_a.customMediaStream,customMediaStream=_h===void 0?null:_h,_j=_a.stopStreamsOnStop,stopStreamsOnStop=_j===void 0?true:_j,_k=_a.askPermissionOnMount,askPermissionOnMount=_k===void 0?false:_k;var mediaRecorder=(0,react_1.useRef)(null);var mediaChunks=(0,react_1.useRef)([]);var mediaStream=(0,react_1.useRef)(null);var _l=(0,react_1.useState)(\"idle\"),status=_l[0],setStatus=_l[1];var _m=(0,react_1.useState)(false),isAudioMuted=_m[0],setIsAudioMuted=_m[1];var _o=(0,react_1.useState)(undefined),mediaBlobUrl=_o[0],setMediaBlobUrl=_o[1];var _p=(0,react_1.useState)(\"NONE\"),error=_p[0],setError=_p[1];(0,react_1.useEffect)(function(){var setup=function(){return __awaiter(_this,void 0,void 0,function(){var _a;return __generator(this,function(_b){switch(_b.label){case 0:_a=extendable_media_recorder_1.register;return[4,(0,extendable_media_recorder_wav_encoder_1.connect)()];case 1:return[4,_a.apply(void 0,[_b.sent()])];case 2:_b.sent();return[2];}});});};setup();},[]);var getMediaStream=(0,react_1.useCallback)(function(){return __awaiter(_this,void 0,void 0,function(){var requiredMedia,stream_1,audioStream,stream,error_1;return __generator(this,function(_a){switch(_a.label){case 0:setStatus(\"acquiring_media\");requiredMedia={audio:typeof audio===\"boolean\"?!!audio:audio,video:typeof video===\"boolean\"?!!video:video,};_a.label=1;case 1:_a.trys.push([1,9,,10]);if(!customMediaStream)return[3,2];mediaStream.current=customMediaStream;return[3,8];case 2:if(!screen)return[3,6];return[4,window.navigator.mediaDevices.getDisplayMedia({video:video||true,})];case 3:stream_1=(_a.sent());stream_1.getVideoTracks()[0].addEventListener(\"ended\",function(){stopRecording();});if(!audio)return[3,5];return[4,window.navigator.mediaDevices.getUserMedia({audio:audio,})];case 4:audioStream=_a.sent();audioStream.getAudioTracks().forEach(function(audioTrack){return stream_1.addTrack(audioTrack);});_a.label=5;case 5:mediaStream.current=stream_1;return[3,8];case 6:return[4,window.navigator.mediaDevices.getUserMedia(requiredMedia)];case 7:stream=_a.sent();mediaStream.current=stream;_a.label=8;case 8:setStatus(\"idle\");return[3,10];case 9:error_1=_a.sent();setError(error_1.name);setStatus(\"idle\");return[3,10];case 10:return[2];}});});},[audio,video,screen]);(0,react_1.useEffect)(function(){if(!window.MediaRecorder){throw new Error(\"Unsupported Browser\");}\nif(screen){if(!window.navigator.mediaDevices.getDisplayMedia){throw new Error(\"This browser doesn\\'t support screen capturing\");}}\nvar checkConstraints=function(mediaType){var supportedMediaConstraints=navigator.mediaDevices.getSupportedConstraints();var unSupportedConstraints=Object.keys(mediaType).filter(function(constraint){return!supportedMediaConstraints[constraint];});if(unSupportedConstraints.length>0){console.error(\"The constraints \".concat(unSupportedConstraints.join(\",\"),\" doesn't support on this browser. Please check your ReactMediaRecorder component.\"));}};if(typeof audio===\"object\"){checkConstraints(audio);}\nif(typeof video===\"object\"){checkConstraints(video);}\nif(mediaRecorderOptions&&mediaRecorderOptions.mimeType){if(!MediaRecorder.isTypeSupported(mediaRecorderOptions.mimeType)){console.error(\"The specified MIME type you supplied for MediaRecorder doesn't support this browser\");}}\nif(!mediaStream.current&&askPermissionOnMount){getMediaStream();}\nreturn function(){if(mediaStream.current){var tracks=mediaStream.current.getTracks();tracks.forEach(function(track){return track.clone().stop();});}};},[audio,screen,video,getMediaStream,mediaRecorderOptions,askPermissionOnMount,]);var startRecording=function(){return __awaiter(_this,void 0,void 0,function(){var isStreamEnded;return __generator(this,function(_a){switch(_a.label){case 0:setError(\"NONE\");if(!!mediaStream.current)return[3,2];return[4,getMediaStream()];case 1:_a.sent();_a.label=2;case 2:if(!mediaStream.current)return[3,5];isStreamEnded=mediaStream.current.getTracks().some(function(track){return track.readyState===\"ended\";});if(!isStreamEnded)return[3,4];return[4,getMediaStream()];case 3:_a.sent();_a.label=4;case 4:if(!mediaStream.current.active){return[2];}\nmediaRecorder.current=new extendable_media_recorder_1.MediaRecorder(mediaStream.current,mediaRecorderOptions||undefined);mediaRecorder.current.ondataavailable=onRecordingActive;mediaRecorder.current.onstop=onRecordingStop;mediaRecorder.current.onstart=onRecordingStart;mediaRecorder.current.onerror=function(){setError(\"NO_RECORDER\");setStatus(\"idle\");};mediaRecorder.current.start();setStatus(\"recording\");_a.label=5;case 5:return[2];}});});};var onRecordingActive=function(_a){var data=_a.data;mediaChunks.current.push(data);};var onRecordingStart=function(){onStart();};var onRecordingStop=function(){var chunk=mediaChunks.current[0];var blobProperty=Object.assign({type:chunk.type},blobPropertyBag||(video?{type:\"video/mp4\"}:{type:\"audio/wav\"}));var blob=new Blob(mediaChunks.current,blobProperty);var url=URL.createObjectURL(blob);setStatus(\"stopped\");setMediaBlobUrl(url);onStop(url,blob);};var muteAudio=function(mute){setIsAudioMuted(mute);if(mediaStream.current){mediaStream.current.getAudioTracks().forEach(function(audioTrack){return(audioTrack.enabled=!mute);});}};var pauseRecording=function(){if(mediaRecorder.current&&mediaRecorder.current.state===\"recording\"){setStatus(\"paused\");mediaRecorder.current.pause();}};var resumeRecording=function(){if(mediaRecorder.current&&mediaRecorder.current.state===\"paused\"){setStatus(\"recording\");mediaRecorder.current.resume();}};var stopRecording=function(){if(mediaRecorder.current){if(mediaRecorder.current.state!==\"inactive\"){setStatus(\"stopping\");mediaRecorder.current.stop();if(stopStreamsOnStop){mediaStream.current&&mediaStream.current.getTracks().forEach(function(track){return track.stop();});}\nmediaChunks.current=[];}}};return{error:RecorderErrors[error],muteAudio:function(){return muteAudio(true);},unMuteAudio:function(){return muteAudio(false);},startRecording:startRecording,pauseRecording:pauseRecording,resumeRecording:resumeRecording,stopRecording:stopRecording,mediaBlobUrl:mediaBlobUrl,status:status,isAudioMuted:isAudioMuted,previewStream:mediaStream.current?new MediaStream(mediaStream.current.getVideoTracks()):null,previewAudioStream:mediaStream.current?new MediaStream(mediaStream.current.getAudioTracks()):null,clearBlobUrl:function(){if(mediaBlobUrl){URL.revokeObjectURL(mediaBlobUrl);}\nsetMediaBlobUrl(undefined);setStatus(\"idle\");},};}\nexports.useReactMediaRecorder=useReactMediaRecorder;var ReactMediaRecorder=function(props){return props.render(useReactMediaRecorder(props));};exports.ReactMediaRecorder=ReactMediaRecorder;","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Webcam\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"Webcam\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_react__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/react-webcam.tsx\");\n","import * as React from \"react\";\n\n// polyfill based on https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n(function polyfillGetUserMedia() {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  // Older browsers might not implement mediaDevices at all, so we set an empty object first\n  if (navigator.mediaDevices === undefined) {\n    (navigator as any).mediaDevices = {};\n  }\n\n  // Some browsers partially implement mediaDevices. We can't just assign an object\n  // with getUserMedia as it would overwrite existing properties.\n  // Here, we will just add the getUserMedia property if it's missing.\n  if (navigator.mediaDevices.getUserMedia === undefined) {\n    navigator.mediaDevices.getUserMedia = function(constraints) {\n      // First get ahold of the legacy getUserMedia, if present\n      const getUserMedia =\n        navigator.getUserMedia ||\n        navigator.webkitGetUserMedia ||\n        navigator.mozGetUserMedia ||\n        navigator.msGetUserMedia;\n\n      // Some browsers just don't implement it - return a rejected promise with an error\n      // to keep a consistent interface\n      if (!getUserMedia) {\n        return Promise.reject(\n          new Error(\"getUserMedia is not implemented in this browser\")\n        );\n      }\n\n      // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise\n      return new Promise(function(resolve, reject) {\n        getUserMedia.call(navigator, constraints, resolve, reject);\n      });\n    };\n  }\n})();\n\nfunction hasGetUserMedia() {\n  return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);\n}\n\ninterface ScreenshotDimensions {\n  width: number;\n  height: number;\n}\n\ninterface ChildrenProps {\n  getScreenshot: (screenshotDimensions?: ScreenshotDimensions) => string | null;\n}\n\nexport type WebcamProps = Omit<React.HTMLProps<HTMLVideoElement>, \"ref\"> & {\n  audio: boolean;\n  audioConstraints?: MediaStreamConstraints[\"audio\"];\n  forceScreenshotSourceSize: boolean;\n  imageSmoothing: boolean;\n  mirrored: boolean;\n  minScreenshotHeight?: number;\n  minScreenshotWidth?: number;\n  onUserMedia: (stream: MediaStream) => void;\n  onUserMediaError: (error: string | DOMException) => void;\n  screenshotFormat: \"image/webp\" | \"image/png\" | \"image/jpeg\";\n  screenshotQuality: number;\n  videoConstraints?: MediaStreamConstraints[\"video\"];\n  children?: (childrenProps: ChildrenProps) => JSX.Element;\n}\n\ninterface WebcamState {\n  hasUserMedia: boolean;\n  src?: string;\n}\n\nexport default class Webcam extends React.Component<WebcamProps, WebcamState> {\n  static defaultProps = {\n    audio: false,\n    forceScreenshotSourceSize: false,\n    imageSmoothing: true,\n    mirrored: false,\n    onUserMedia: () => undefined,\n    onUserMediaError: () => undefined,\n    screenshotFormat: \"image/webp\",\n    screenshotQuality: 0.92,\n  };\n\n  private canvas: HTMLCanvasElement | null = null;\n\n  private ctx: CanvasRenderingContext2D | null = null;\n\n  private requestUserMediaId = 0;\n\n  private unmounted = false;\n\n  stream: MediaStream | null;\n\n  video: HTMLVideoElement | null;\n\n  constructor(props: WebcamProps) {\n    super(props);\n    this.state = {\n      hasUserMedia: false\n    };\n  }\n\n  componentDidMount() {\n    const { state, props } = this;\n    this.unmounted = false;\n\n    if (!hasGetUserMedia()) {\n      props.onUserMediaError(\"getUserMedia not supported\");\n\n      return;\n    }\n\n    if (!state.hasUserMedia) {\n      this.requestUserMedia();\n    }\n\n    if (props.children && typeof props.children != 'function') {\n      console.warn(\"children must be a function\");\n    }\n  }\n\n  componentDidUpdate(nextProps: WebcamProps) {\n    const { props } = this;\n\n    if (!hasGetUserMedia()) {\n      props.onUserMediaError(\"getUserMedia not supported\");\n\n      return;\n    }\n\n    const audioConstraintsChanged =\n      JSON.stringify(nextProps.audioConstraints) !==\n      JSON.stringify(props.audioConstraints);\n    const videoConstraintsChanged =\n      JSON.stringify(nextProps.videoConstraints) !==\n      JSON.stringify(props.videoConstraints);\n    const minScreenshotWidthChanged =\n      nextProps.minScreenshotWidth !== props.minScreenshotWidth;\n    const minScreenshotHeightChanged =\n      nextProps.minScreenshotHeight !== props.minScreenshotHeight;\n    if (\n      videoConstraintsChanged ||\n      minScreenshotWidthChanged ||\n      minScreenshotHeightChanged\n    ) {\n      this.canvas = null;\n      this.ctx = null;\n    }\n    if (audioConstraintsChanged || videoConstraintsChanged) {\n      this.stopAndCleanup();\n      this.requestUserMedia();\n    }\n  }\n\n  componentWillUnmount() {\n    this.unmounted = true;\n    this.stopAndCleanup();\n  }\n\n  private static stopMediaStream(stream: MediaStream | null) {\n    if (stream) {\n      if (stream.getVideoTracks && stream.getAudioTracks) {\n        stream.getVideoTracks().map(track => {\n          stream.removeTrack(track);\n          track.stop();\n        });\n        stream.getAudioTracks().map(track => {\n          stream.removeTrack(track);\n          track.stop()\n        });\n      } else {\n        ((stream as unknown) as MediaStreamTrack).stop();\n      }\n    }\n  }\n\n  private stopAndCleanup() {\n    const { state } = this;\n\n    if (state.hasUserMedia) {\n      Webcam.stopMediaStream(this.stream);\n\n      if (state.src) {\n        window.URL.revokeObjectURL(state.src);\n      }\n    }\n  }\n\n  getScreenshot(screenshotDimensions?: ScreenshotDimensions) {\n    const { state, props } = this;\n\n    if (!state.hasUserMedia) return null;\n\n    const canvas = this.getCanvas(screenshotDimensions);\n    return (\n      canvas &&\n      canvas.toDataURL(props.screenshotFormat, props.screenshotQuality)\n    );\n  }\n\n  getCanvas(screenshotDimensions?: ScreenshotDimensions) {\n    const { state, props } = this;\n\n    if (!this.video) {\n      return null;\n    }\n\n    if (!state.hasUserMedia || !this.video.videoHeight) return null;\n\n    if (!this.ctx) {\n      let canvasWidth = this.video.videoWidth;\n      let canvasHeight = this.video.videoHeight;\n      if (!this.props.forceScreenshotSourceSize) {\n        const aspectRatio = canvasWidth / canvasHeight;\n\n        canvasWidth = props.minScreenshotWidth || this.video.clientWidth;\n        canvasHeight = canvasWidth / aspectRatio;\n\n        if (\n          props.minScreenshotHeight &&\n          canvasHeight < props.minScreenshotHeight\n        ) {\n          canvasHeight = props.minScreenshotHeight;\n          canvasWidth = canvasHeight * aspectRatio;\n        }\n      }\n\n      this.canvas = document.createElement(\"canvas\");\n      this.canvas.width = screenshotDimensions?.width ||  canvasWidth;\n      this.canvas.height = screenshotDimensions?.height || canvasHeight;\n      this.ctx = this.canvas.getContext(\"2d\");\n    }\n\n    const { ctx, canvas } = this;\n\n    if (ctx && canvas) {\n      // mirror the screenshot\n      if (props.mirrored) {\n        ctx.translate(canvas.width, 0);\n        ctx.scale(-1, 1);\n      }\n\n      ctx.imageSmoothingEnabled = props.imageSmoothing;\n      ctx.drawImage(this.video, 0, 0, screenshotDimensions?.width || canvas.width, screenshotDimensions?.height || canvas.height);\n\n      // invert mirroring\n      if (props.mirrored) {\n        ctx.scale(-1, 1);\n        ctx.translate(-canvas.width, 0);\n      }\n    }\n\n    return canvas;\n  }\n\n  private requestUserMedia() {\n    const { props } = this;\n\n    const sourceSelected = (\n      audioConstraints: boolean | MediaTrackConstraints | undefined,\n      videoConstraints: boolean | MediaTrackConstraints | undefined,\n    ) => {\n      const constraints: MediaStreamConstraints = {\n        video: typeof videoConstraints !== \"undefined\" ? videoConstraints : true\n      };\n\n      if (props.audio) {\n        constraints.audio =\n          typeof audioConstraints !== \"undefined\" ? audioConstraints : true;\n      }\n\n      this.requestUserMediaId++\n      const myRequestUserMediaId = this.requestUserMediaId\n\n      navigator.mediaDevices\n        .getUserMedia(constraints)\n        .then(stream => {\n          if (this.unmounted || myRequestUserMediaId !== this.requestUserMediaId) {\n            Webcam.stopMediaStream(stream);\n          } else {\n            this.handleUserMedia(null, stream);\n          }\n        })\n        .catch(e => {\n          this.handleUserMedia(e);\n        });\n    };\n\n    if (\"mediaDevices\" in navigator) {\n      sourceSelected(props.audioConstraints, props.videoConstraints);\n    } else {\n      const optionalSource = (id: string | null) => ({ optional: [{ sourceId: id }] }) as MediaTrackConstraints;\n\n      const constraintToSourceId = (constraint) => {\n        const { deviceId } = constraint;\n\n        if (typeof deviceId === \"string\") {\n          return deviceId;\n        }\n\n        if (Array.isArray(deviceId) && deviceId.length > 0) {\n          return deviceId[0];\n        }\n\n        if (typeof deviceId === \"object\" && deviceId.ideal) {\n          return deviceId.ideal;\n        }\n\n        return null;\n      };\n\n      // @ts-ignore: deprecated api\n      MediaStreamTrack.getSources(sources => {\n        let audioSource: string | null = null;\n        let videoSource: string | null = null;\n\n        sources.forEach((source: MediaStreamTrack) => {\n          if (source.kind === \"audio\") {\n            audioSource = source.id;\n          } else if (source.kind === \"video\") {\n            videoSource = source.id;\n          }\n        });\n\n        const audioSourceId = constraintToSourceId(props.audioConstraints);\n        if (audioSourceId) {\n          audioSource = audioSourceId;\n        }\n\n        const videoSourceId = constraintToSourceId(props.videoConstraints);\n        if (videoSourceId) {\n          videoSource = videoSourceId;\n        }\n\n        sourceSelected(\n          optionalSource(audioSource),\n          optionalSource(videoSource)\n        );\n      });\n    }\n  }\n\n  private handleUserMedia(err, stream?: MediaStream) {\n    const { props } = this;\n\n    if (err || !stream) {\n      this.setState({ hasUserMedia: false });\n      props.onUserMediaError(err);\n\n      return;\n    }\n\n    this.stream = stream;\n\n    try {\n      if (this.video) {\n        this.video.srcObject = stream;\n      }\n      this.setState({ hasUserMedia: true });\n    } catch (error) {\n      this.setState({\n        hasUserMedia: true,\n        src: window.URL.createObjectURL(stream)\n      });\n    }\n\n    props.onUserMedia(stream);\n  }\n\n  render() {\n    const { state, props } = this;\n\n    const {\n      audio,\n      forceScreenshotSourceSize,\n      onUserMedia,\n      onUserMediaError,\n      screenshotFormat,\n      screenshotQuality,\n      minScreenshotWidth,\n      minScreenshotHeight,\n      audioConstraints,\n      videoConstraints,\n      imageSmoothing,\n      mirrored,\n      style = {},\n      children,\n      ...rest\n    } = props;\n\n    const videoStyle = mirrored ? { ...style, transform: `${style.transform || \"\"} scaleX(-1)` } : style;\n\n    const childrenProps: ChildrenProps = {\n      getScreenshot: this.getScreenshot.bind(this),\n    };\n\n    return (\n      <>\n        <video\n          autoPlay\n          src={state.src}\n          muted={!audio}\n          playsInline\n          ref={ref => {\n            this.video = ref;\n          }}\n          style={videoStyle}\n          {...rest}\n        />\n        {children && children(childrenProps)}\n      </>\n    );\n  }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE_react__;","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayLikeToArray = require(\"./arrayLikeToArray.js\");\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\n\nmodule.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayWithHoles = require(\"./arrayWithHoles.js\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit.js\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\n\nvar nonIterableRest = require(\"./nonIterableRest.js\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayWithoutHoles = require(\"./arrayWithoutHoles.js\");\n\nvar iterableToArray = require(\"./iterableToArray.js\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread.js\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayLikeToArray = require(\"./arrayLikeToArray.js\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;"],"names":["exports","_slicedToArray","_classCallCheck","_createClass","_interopDefaultLegacy","e","_slicedToArray__default","_classCallCheck__default","_createClass__default","createExtendedExponentialRampToValueAutomationEvent","value","endTime","insertTime","type","createExtendedLinearRampToValueAutomationEvent","createSetValueAutomationEvent","startTime","createSetValueCurveAutomationEvent","values","duration","getTargetValueAtTime","time","valueAtStartTime","_ref","target","timeConstant","Math","exp","isExponentialRampToValueAutomationEvent","automationEvent","isLinearRampToValueAutomationEvent","isAnyRampToValueAutomationEvent","isSetValueAutomationEvent","isSetValueCurveAutomationEvent","getValueOfAutomationEventAtIndexAtTime","automationEvents","index","defaultValue","undefined","length","getEndTimeAndValueOfPreviousAutomationEvent","currentAutomationEvent","nextAutomationEvent","isCancelAndHoldAutomationEvent","isCancelScheduledValuesAutomationEvent","getEventTime","cancelTime","getExponentialRampValueAtTime","pow","getLinearRampValueAtTime","interpolateValue","theoreticIndex","lowerIndex","floor","upperIndex","ceil","getValueCurveValueAtTime","isSetTargetAutomationEvent","AutomationEventList","_Symbol$iterator","this","_automationEvents","_currenTime","_defaultValue","key","Symbol","iterator","eventTime","findIndex","removedAutomationEvent","slice","lastAutomationEvent","Error","startValue","truncatedAutomationEvent","push","getValue","Float32Array","_index","previousAutomationEvent","persistentAutomationEvent","splice","remainingAutomationEvents","firstRemainingAutomationEvent","unshift","indexOfNextEvent","indexOfCurrentEvent","_getEndTimeAndValueOf","_getEndTimeAndValueOf2","_getEndTimeAndValueOf3","_getEndTimeAndValueOf4","_startTime","_value","createCancelAndHoldAutomationEvent","createCancelScheduledValuesAutomationEvent","createExponentialRampToValueAutomationEvent","createLinearRampToValueAutomationEvent","createSetTargetAutomationEvent","Object","defineProperty","factory","require","PORT_MAP","WeakMap","ONGOING_REQUESTS","createBroker","brokerImplementation","partialBrokerImplementation","fullBrokerImplementation","connect","call","MessageChannel","port1","port2","port","portId","set","disconnect","get","isSupported","sender","ongoingRequests","has","Map","createOrGetOngoingRequests","addEventListener","message","data","id","reject","resolve","delete","error","result","start","isMessagePort","method","params","transferables","Promise","generateUniqueNumber","postMessage","notify","functions","entries","handler","_toConsumableArray","dashify","indefiniteArticle","_toConsumableArray__default","dashify__default","indefiniteArticle__default","applyModifiers","name","modifiers","reduce","modifiedName","modifier","head","charAt","toUpperCase","tail","concat","buildRegex","variable","expression","map","join","RegExp","preRenderString","string","parameters","expressionRegex","variables","expressionResult","exec","modifiersRegex","modifiersRegexResult","preRenderedParts","parts","part","split","prts","prt","prmtrs","missingParameters","renderedParts","preRenderedPart","compile","template","knownParameters","arguments","renderCode","code","renderMessage","render","causeOrMissingParameters","optionalCause","cause","err","status","module","str","options","TypeError","trim","replace","m","test","condense","toLowerCase","wrap","characterize","encode","recordingId","timeslice","record","sampleRate","typedArrays","buffer","blob","Blob","url","URL","createObjectURL","extendableMediaRecorderWavEncoder","worker","Worker","load","revokeObjectURL","encoderIds","Set","encoderId","arrayBuffers","instantiate","mimeType","addUniqueNumber","register","mediaEncoderHost","loadWorker","createInvalidModificationError","DOMException","createNotSupportedError","observable","noop","rethrow","emitNotSupportedError","observer","window","wrapSubscribeFunction","patch","toObserver","emptyFunction","isNextFunction","args","innerSubscribe","subscribe","unsubscribe","next","createWrapSubscribeFunction","arg","prototype","complete","bind","mutations","createAnimationFrame","htmlElement","MutationObserver","mutationObserver","records","observe","createMutations","mapSubscribableThing","subscribableThing","createMapSubscribableThing","prependSubscribableThing","prependedValue","createPrependSubscribableThing","on","createAttribute","createGeolocation","createIntersections","createMediaDevices","createMediaQueryMatch","createMetrics","createMidiInputs","createMidiOutputs","listener","event","removeEventListener","createOn","createOnline","createPermissionState","createReports","createResizes","createUnhandledRejection","createVideoFrame","createWakeLock","JSON_RPC_ERROR_CODES","addRecorderAudioWorkletModule","blobConstructor","urlConstructor","worklet","addAudioWorkletModule","createAddRecorderAudioWorkletModule","createRecorderAudioWorkletNode","createListener","createPostMessage","validateState","audioWorkletNodeConstructor","context","audioWorkletNode","channelCountMode","numberOfInputs","numberOfOutputs","state","defineProperties","pause","encoderPort","resume","stop","createRecorderAudioWorkletNodeFactory","ongoingRequest","createPostMessageFactory","expectedStates","currentState","includes","expectedState","ACTIVE_AUDIO_NODE_STORE","WeakSet","AUDIO_NODE_CONNECTIONS_STORE","AUDIO_NODE_STORE","AUDIO_PARAM_CONNECTIONS_STORE","AUDIO_PARAM_STORE","CONTEXT_STORE","EVENT_LISTENERS","CYCLE_COUNTERS","NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","NODE_TO_PROCESSOR_MAPS","construct","IMPORT_STATEMENT_REGEX","splitImportStatements","source","importStatements","sourceWithoutImportStatements","match","unresolvedUrl","importStatementWithResolvedUrl","toString","verifyParameterDescriptors","parameterDescriptors","Array","isArray","verifyProcessorCtor","processorCtor","constructible","Proxy","isConstructible","getValueForKey","pickElementFromSet","predicate","matchingElements","from","filter","matchingElement","deletePassiveInputConnectionToAudioNode","passiveInputs","output","input","passiveInputConnections","matchingConnection","passiveInputConnection","size","getEventListenersOfAudioNode","audioNode","setInternalStateToActive","add","forEach","eventListener","isAudioWorkletNode","setInternalStateToPassive","setInternalStateToPassiveWhenNecessary","activeInputs","every","connections","DEFAULT_OPTIONS","channelCount","channelInterpretation","fftSize","maxDecibels","minDecibels","smoothingTimeConstant","isOwnedByContext","nativeAudioNode","nativeContext","testAudioBufferCopyChannelMethodsOutOfBoundsSupport","nativeAudioBuffer","copyToChannel","createIndexSizeError","wrapAudioBufferGetChannelDataMethod","audioBuffer","getChannelData","channel","numberOfChannels","MOST_NEGATIVE_SINGLE_FLOAT","MOST_POSITIVE_SINGLE_FLOAT","isActiveAudioNode","loop","loopEnd","loopStart","playbackRate","getAudioNodeConnections","getAudioParamConnections","audioParam","deactivateActiveAudioNodeInputConnections","trace","audioParams","isAudioBufferSourceNode","isBiquadFilterNode","Q","detune","frequency","gain","isConstantSourceNode","offset","isGainNode","isOscillatorNode","isStereoPannerNode","pan","audioParamConnections","deactivateAudioGraph","destination","isValidLatencyHint","latencyHint","isAudioNode","audioNodeOrAudioParam","isAudioNodeOutputConnection","outputConnection","insertElementInSet","element","ignoreDuplicates","addActiveInputConnectionToAudioParam","activeInputConnection","addPassiveInputConnectionToAudioParam","isNativeAudioNodeFaker","nativeAudioNodeOrNativeAudioNodeFaker","connectNativeAudioNodeToNativeAudioNode","nativeSourceAudioNode","nativeDestinationAudioNode","fakeNativeDestinationAudioNode","inputs","deleteActiveInputConnection","activeInputConnections","deleteEventListenerOfAudioNode","deletePassiveInputConnectionToAudioParam","disconnectNativeAudioNodeFromNativeAudioNode","getNativeAudioNode","getNativeAudioParam","isPartOfACycle","isPassiveAudioNode","testAudioNodeDisconnectMethodSupport","nativeAudioContext","nativeAudioWorkletNodeConstructor","analyzer","createScriptProcessor","dummy","createGain","ones","createBuffer","channelData","createBufferSource","onaudioprocess","chnnlDt","inputBuffer","some","sample","visitEachAudioNodeOnce","cycles","visitor","counts","cycle","count","isNativeAudioNode","nativeAudioNodeOrAudioParam","wrapAudioNodeDisconnectMethod","returnValue","connectionsToDestination","connection","destinationOrOutput","apply","clear","filteredConnections","addConnectionToAudioParamOfAudioContext","isOffline","outputs","eventListeners","isActive","nativeAudioParam","partialConnection","deleteActiveInputConnectionToAudioParam","deleteInputsOfAudioNode","deleteInputConnectionOfAudioNode","deleteInputsOfAudioParam","deleteInputConnectionOfAudioParam","ReadOnlyMap","_map","callback","thisArg","keys","parameterData","processorOptions","copyFromChannel","parent","channelNumber","bufferOffset","byteLength","slicedInput","BYTES_PER_ELEMENT","createNestedArrays","x","y","arrays","i","array","j","getAudioWorkletProcessor","nativeOfflineAudioContext","proxy","nodeToProcessorMap","nativeAudioWorkletNode","processBuffer","renderedBuffer","outputChannelCount","processorConstructor","exposeCurrentFrameAndCurrentTime","numberOfInputChannels","numberOfOutputChannels","sum","processedBuffer","audioNodeConnections","audioWorkletProcessor","k","potentiallyEmptyInputs","activeSourceFlag","process","outputChannelSplitterNodeOutput","dispatchEvent","ErrorEvent","colno","filename","lineno","disableNormalization","detachArrayBuffer","arrayBuffer","closeAndResolve","onmessage","close","delayTime","maxDelayTime","getOutputAudioNodeAtIndex","outputAudioNodes","outputAudioNode","attack","knee","ratio","release","threshold","createInvalidStateError","createInvalidAccessError","filterBuffer","feedback","feedbackLength","feedforward","feedforwardLength","minLength","xBuffer","yBuffer","bufferIndex","bufferLength","inputLength","filterFullBuffer","convertedFeedback","Float64Array","convertedFeedforward","min","filteredBuffer","fill","testPromiseSupport","uint32Array","Uint32Array","promise","decodeAudioData","catch","assignNativeAudioNodeOption","option","assignNativeAudioNodeOptions","testAnalyserNodeGetFloatTimeDomainDataMethodSupport","nativeAnalyserNode","getFloatTimeDomainData","assignNativeAudioNodeAudioParamValue","wrapAudioScheduledSourceNodeStartMethodNegativeParameters","nativeAudioScheduledSourceNode","when","RangeError","wrapAudioScheduledSourceNodeStopMethodNegativeParameters","computeBufferSize","baseLatency","max","round","log2","cloneAudioWorkletNodeOptions","audioWorkletNodeOptions","onmessageerror","createAudioWorkletProcessorPromise","clonedAudioWorkletNodeOptions","createNativeBiquadFilterNode","nativeBiquadFilterNode","createBiquadFilter","createNativeChannelSplitterNode","nativeChannelSplitterNode","createChannelSplitter","channelSplitterNode","wrapChannelSplitterNode","interceptConnections","original","interceptor","createNativeDelayNode","nativeDelayNode","createDelay","createNativeGainNode","nativeGainNode","divide","a","b","denominator","evaluatePolynomial","coefficient","z","ongoingTests","testResults","contextStore","audioNodeConnectionsStore","unit32Array","audioParamConnectionsStore","createNativeScriptProcessorNode","bufferSize","periodicWave","coneInnerAngle","coneOuterAngle","coneOuterGain","distanceModel","maxDistance","orientationX","orientationY","orientationZ","panningModel","positionX","positionY","positionZ","refDistance","rolloffFactor","createUnknownError","curve","oversample","getFirstSample","isDCCurve","overwriteAccessors","object","property","createGetter","createSetter","hasOwnProperty","getPrototypeOf","getOwnPropertyDescriptor","testAudioScheduledSourceNodeStartMethodNegativeParametersSupport","nativeAudioBufferSourceNode","createOscillator","testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","testAudioScheduledSourceNodeStopMethodNegativeParametersSupport","wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","disconnectGainNode","isStopped","setValueAtTime","wrapEventListener","descriptor","currentTarget","handleEvent","addActiveInputConnectionToAudioNode","createAddActiveInputConnectionToAudioNode","addPassiveInputConnectionToAudioNode","createAddPassiveInputConnectionToAudioNode","deleteActiveInputConnectionToAudioNode","createDeleteActiveInputConnectionToAudioNode","audioNodeTailTimeStore","getAudioNodeTailTime","_a","createGetAudioNodeTailTime","cacheTestResult","tester","cachedTestResult","ongoingTest","synchronousTestResult","then","finalTestResult","createNativeAnalyserNode","createAnalyser","byteTimeDomainData","Uint8Array","getByteTimeDomainData","wrapAnalyserNodeGetFloatTimeDomainDataMethod","createNativeAnalyserNodeFactory","getAudioNodeRenderer","renderer","createGetAudioNodeRenderer","renderInputsOfAudioNode","all","audioNodeRenderer","renderedNativeAudioNode","allRenderingPromises","renderingPromises","createRenderInputsOfAudioNode","createAnalyserNodeRenderer","renderedNativeAnalyserNodes","createAnalyserNode","renderedNativeAnalyserNode","createAnalyserNodeRendererFactory","getNativeContext","nativeOfflineAudioContextConstructor","OfflineAudioContext","webkitOfflineAudioContext","createNativeOfflineAudioContextConstructor","isNativeOfflineAudioContext","anything","createIsNativeOfflineAudioContext","audioParamAudioNodeStore","eventTargetConstructor","_nativeEventTarget","_listeners","wrappedEventListener","createEventTargetConstructor","nativeAudioContextConstructor","AudioContext","webkitAudioContext","createNativeAudioContextConstructor","isNativeAudioContext","createIsNativeAudioContext","AudioNode","createIsNativeAudioNode","isNativeAudioParam","AudioParam","createIsNativeAudioParam","AudioWorkletNode","createNativeAudioWorkletNodeConstructor","audioNodeConstructor","addAudioNodeConnections","addConnectionToAudioNode","createIncrementCycleCounter","decrementCycleCounter","detectCycles","_context","_nativeAudioNode","isPassive","isNewConnectionToAudioNode","maxValue","isNewConnectionToAudioParam","destinations","audioNodeConnectionsOfSource","deleteAnyConnection","deleteConnectionAtOutput","deleteConnectionToDestination","createAudioNodeConstructor","tailTimeTimeoutIds","tailTime","tailTimeTimeoutId","clearTimeout","setTimeout","createAddConnectionToAudioNode","cycleCounters","cycleCounter","nativeDestinationAudioParam","createIncrementCycleCounterFactory","createDecrementCycleCounter","chain","nextLink","isDelayNode","mergedCycles","nestedCycles","createDetectCycles","analyserNodeConstructor","audionNodeConstructor","mergedOptions","analyserNodeRenderer","_nativeAnalyserNode","frequencyBinCount","getByteFrequencyData","getFloatFrequencyData","createAnalyserNodeConstructor","audioBufferStore","nativeAudioBufferConstructor","AudioBuffer","createNativeAudioBufferConstructor","convertNumberToUnsignedLong","wrapAudioBufferCopyChannelMethods","channelNumberAsNumber","bufferOffsetAsNumber","audioBufferLength","destinationLength","sourceLength","createWrapAudioBufferCopyChannelMethods","wrapAudioBufferCopyChannelMethodsOutOfBounds","createWrapAudioBufferCopyChannelMethodsOutOfBounds","audioBufferConstructor","testNativeAudioBufferConstructorSupport","instance","hasInstance","createAudioBufferConstructor","createTestAudioBufferConstructorSupport","addSilentConnection","createAddSilentConnection","renderInputsOfAudioParam","createRenderInputsOfAudioParam","connectAudioParam","createConnectAudioParam","createNativeAudioBufferSourceNode","testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","testAudioBufferSourceNodeStartMethodOffsetClampingSupport","testAudioBufferSourceNodeStopMethodNullifiedBufferSupport","wrapAudioBufferSourceNodeStartMethodOffsetClampling","wrapAudioBufferSourceNodeStopMethodNullifiedBuffer","isScheduled","wrapAudioBufferSourceNodeStartMethodConsecutiveCalls","createNativeAudioBufferSourceNodeFactory","clampedOffset","nullifiedBuffer","createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer","renderAutomation","getAudioParamRenderer","replay","createRenderAutomation","createGetAudioParamRenderer","createAudioBufferSourceNodeRenderer","renderedNativeAudioBufferSourceNodes","createAudioBufferSourceNode","nativeAudioBufferSourceNodeIsOwnedByContext","renderedNativeAudioBufferSourceNode","createAudioBufferSourceNodeRendererFactory","createAudioParam","addAudioParamConnections","audioParamStore","createAudioParamRenderer","setValueAtTimeUntilPossible","isAudioParamOfOfflineAudioContext","minValue","automationEventList","audioParamRenderer","currentTime","cancelAndHoldAtTime","flush","previousLastEvent","pop","currentLastEvent","cancelScheduledValues","exponentialRampToValueAtTime","linearRampToValueAtTime","setValueCurveAtTime","Number","isFinite","setTargetAtTime","convertedValues","firstSample","lastSample","numberOfInterpolatedValues","interpolatedValues","timeOfLastSample","createAudioParamFactory","audioBufferSourceNodeConstructor","audioBufferSourceNodeRenderer","_audioBufferSourceNodeRenderer","_isBufferNullified","_isBufferSet","_nativeAudioBufferSourceNode","_onended","_playbackRate","wrappedListener","onended","nativeOnEnded","resetInternalStateToPassive","createAudioBufferSourceNodeConstructor","audioDestinationNodeConstructor","createAudioDestinationNodeRenderer","createNativeAudioDestinationNode","nativeAudioDestinationNode","audioDestinationNodeRenderer","_isNodeOfNativeOfflineAudioContext","_nativeAudioDestinationNode","maxChannelCount","createAudioDestinationNodeConstructor","renderedNativeAudioDestinationNodes","createAudioDestinationNode","renderedNativeAudioDestinationNode","isNodeOfNativeOfflineAudioContext","gainNode","createNativeAudioDestinationNodeFactory","createBiquadFilterNodeRenderer","renderedNativeBiquadFilterNodes","createBiquadFilterNode","nativeBiquadFilterNodeIsOwnedByContext","renderedNativeBiquadFilterNode","createBiquadFilterNodeRendererFactory","setAudioNodeTailTime","createSetAudioNodeTailTime","biquadFilterNodeConstructor","biquadFilterNodeRenderer","_Q","_detune","_frequency","_gain","log10","_nativeBiquadFilterNode","frequencyHz","magResponse","phaseResponse","getFrequencyResponse","createBiquadFilterNodeConstructor","monitorConnections","whenConnected","whenDisconnected","wasDisconnected","wasConnected","isDisconnected","createMonitorConnections","wrapChannelMergerNode","channelMergerNode","audioBufferSourceNode","createWrapChannelMergerNode","createNativeChannelMergerNode","nativeChannelMergerNode","createChannelMerger","createNativeChannelMergerNodeFactory","createChannelMergerNodeRenderer","renderedNativeAudioNodes","createAudioNode","createChannelMergerNodeRendererFactory","channelMergerNodeConstructor","channelMergerNodeRenderer","createChannelMergerNodeConstructor","createChannelSplitterNodeRenderer","createChannelSplitterNodeRendererFactory","channelSplitterNodeConstructor","sanitizeChannelSplitterOptions","channelSplitterNodeRenderer","createChannelSplitterNodeConstructor","createNativeConstantSourceNodeFaker","audioNodeOptions","nativeConstantSourceNodeFaker","createNativeConstantSourceNodeFakerFactory","createNativeConstantSourceNode","createConstantSource","nativeConstantSourceNode","createNativeConstantSourceNodeFactory","createConstantSourceNodeRenderer","renderedNativeConstantSourceNodes","createConstantSourceNode","nativeConstantSourceNodeIsOwnedByContext","renderedNativeConstantSourceNode","createConstantSourceNodeRendererFactory","constantSourceNodeConstructor","constantSourceNodeRenderer","_constantSourceNodeRenderer","_nativeConstantSourceNode","_offset","createConstantSourceNodeConstructor","createNativeConvolverNode","nativeConvolverNode","createConvolver","normalize","createNativeConvolverNodeFactory","createConvolverNodeRenderer","renderedNativeConvolverNodes","createConvolverNode","renderedNativeConvolverNode","createConvolverNodeRendererFactory","convolverNodeConstructor","convolverNodeRenderer","_nativeConvolverNode","createConvolverNodeConstructor","createDelayNodeRenderer","renderedNativeDelayNodes","createDelayNode","nativeDelayNodeIsOwnedByContext","renderedNativeDelayNode","createDelayNodeRendererFactory","delayNodeConstructor","delayNodeRenderer","_delayTime","createDelayNodeConstructor","createNativeDynamicsCompressorNode","nativeDynamicsCompressorNode","createDynamicsCompressor","createNativeDynamicsCompressorNodeFactory","createDynamicsCompressorNodeRenderer","renderedNativeDynamicsCompressorNodes","createDynamicsCompressorNode","nativeDynamicsCompressorNodeIsOwnedByContext","renderedNativeDynamicsCompressorNode","createDynamicsCompressorNodeRendererFactory","dynamicsCompressorNodeConstructor","dynamicsCompressorNodeRenderer","_attack","_knee","_nativeDynamicsCompressorNode","_ratio","_release","_threshold","previousChannelCount","reduction","createDynamicsCompressorNodeConstructor","createGainNodeRenderer","renderedNativeGainNodes","createGainNode","nativeGainNodeIsOwnedByContext","renderedNativeGainNode","createGainNodeRendererFactory","gainNodeConstructor","gainNodeRenderer","createGainNodeConstructor","createNativeIIRFilterNodeFaker","scriptProcessorNode","bufferIndexes","xBuffers","yBuffers","outputBuffer","nyquist","nativeIIRFilterNodeFaker","omega","PI","cos","sin","response","sqrt","atan2","createNativeIIRFilterNodeFakerFactory","renderNativeOfflineAudioContext","testOfflineAudioContextCurrentTimeSupport","isOfflineAudioContextCurrentTimeSupported","oncomplete","startRendering","createRenderNativeOfflineAudioContext","createTestOfflineAudioContextCurrentTimeSupport","createIIRFilterNodeRenderer","filteredBufferPromise","nativeIIRFilterNode","nativeIIRFilterNodeIsOwnedByContext","createIIRFilter","partialOfflineAudioContext","createIIRFilterNodeRendererFactory","createNativeIIRFilterNode","createNativeIIRFilterNodeFactory","iIRFilterNodeConstructor","iirFilterNodeRenderer","wrapIIRFilterNodeGetFrequencyResponseMethod","_nativeIIRFilterNode","createIIRFilterNodeConstructor","createAudioListener","nativeListener","forwardX","isScriptProcessorNodeCreated","lastOrientation","lastPosition","createScriptProcessorNode","orientation","setOrientation","positon","setPosition","createSetOrientation","createSetPosition","createFakeAudioParam","initialValue","setValue","constantSourceNode","forwardY","forwardZ","upX","upY","upZ","createFakeAudioParams","createAudioListenerFactory","unrenderedAudioWorkletNodeStore","minimalBaseAudioContextConstructor","_nativeContext","_destination","_listener","_onstatechange","onstatechange","nativeOnStateChange","createMinimalBaseAudioContextConstructor","createNativeOscillatorNode","nativeOscillatorNode","setPeriodicWave","createNativeOscillatorNodeFactory","createOscillatorNodeRenderer","renderedNativeOscillatorNodes","createOscillatorNode","nativeOscillatorNodeIsOwnedByContext","renderedNativeOscillatorNode","createOscillatorNodeRendererFactory","oscillatorNodeConstructor","oscillatorNodeRenderer","_nativeOscillatorNode","_oscillatorNodeRenderer","createOscillatorNodeConstructor","createConnectedNativeAudioBufferSourceNode","createConnectedNativeAudioBufferSourceNodeFactory","createNativeWaveShaperNodeFaker","negativeWaveShaperNode","createWaveShaper","positiveWaveShaperNode","inputGainNode","invertGainNode","outputGainNode","revertGainNode","disconnectNativeAudioBufferSourceNode","isConnected","unmodifiedCurve","nativeWaveShaperNodeFaker","curveLength","negativeCurve","positiveCurve","centerIndex","createNativeWaveShaperNodeFakerFactory","createNativeWaveShaperNode","nativeWaveShaperNode","automationRate","createNativeWaveShaperNodeFactory","createNativePannerNodeFaker","pannerNode","createPanner","SINGLE_CHANNEL_OPTIONS","orientationXGainNode","orientationYGainNode","orientationZGainNode","positionXGainNode","positionYGainNode","positionZGainNode","waveShaperNode","nativePannerNodeFaker","createNativePannerNodeFakerFactory","createNativePannerNode","nativePannerNode","createNativePannerNodeFactory","createPannerNodeRenderer","renderedBufferPromise","commonAudioNodeOptions","commonNativePannerNodeOptions","nativePannerNodeIsOwnedByContext","nativeConstantSourceNodes","channelDatas","gateGainNode","partialPannerNode","renderedNativeGainNodeOrNativePannerNode","createPannerNodeRendererFactory","pannerNodeConstructor","pannerNodeRenderer","_nativePannerNode","_orientationX","_orientationY","_orientationZ","_positionX","_positionY","_positionZ","createPannerNodeConstructor","createNativePeriodicWave","imag","real","convertedImag","convertedReal","nativePeriodicWave","createPeriodicWave","createNativePeriodicWaveFactory","periodicWaveConstructor","periodicWaveStore","sanitizePeriodicWaveOptions","PeriodicWave","createPeriodicWaveConstructor","nativeStereoPannerNodeFakerFactory","CURVE_SIZE","DC_CURVE","HALF_PI","SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS","buildInternalGraph","panGainNode","leftWaveShaperCurve","rightWaveShaperCurve","leftGainNode","leftWaveShaperNode","panWaveShaperNode","rightGainNode","rightWaveShaperNode","connectGraph","disconnectGraph","buildInternalGraphForMono","leftInputForLeftOutputWaveShaperCurve","leftInputForRightOutputWaveShaperCurve","rightInputForLeftOutputWaveShaperCurve","rightInputForRightOutputWaveShaperCurve","leftInputForLeftOutputGainNode","leftInputForLeftOutputWaveShaperNode","leftInputForRightOutputGainNode","leftInputForRightOutputWaveShaperNode","rightInputForLeftOutputGainNode","rightInputForLeftOutputWaveShaperNode","rightInputForRightOutputGainNode","rightInputForRightOutputWaveShaperNode","buildInternalGraphForStereo","createNativeStereoPannerNodeFakerFactory","createNativeStereoPannerNode","createNativeStereoPannerNodeFaker","createStereoPanner","nativeStereoPannerNode","createNativeStereoPannerNodeFactory","createStereoPannerNodeRenderer","renderedNativeStereoPannerNodes","createStereoPannerNode","nativeStereoPannerNodeIsOwnedByContext","renderedNativeStereoPannerNode","createStereoPannerNodeRendererFactory","stereoPannerNodeConstructor","stereoPannerNodeRenderer","_pan","createStereoPannerNodeConstructor","createWaveShaperNodeRenderer","renderedNativeWaveShaperNodes","createWaveShaperNode","renderedNativeWaveShaperNode","createWaveShaperNodeRendererFactory","waveShaperNodeConstructor","waveShaperNodeRenderer","_isCurveNullified","_nativeWaveShaperNode","createWaveShaperNodeConstructor","isSecureContext","createIsSecureContext","fn","currentFrame","configurable","createExposeCurrentFrameAndCurrentTime","backupOfflineAudioContextStore","getOrCreateBackupOfflineAudioContext","backupOfflineAudioContext","createGetOrCreateBackupOfflineAudioContext","evaluateSource","fetchSource","resolvedRequests","testAudioWorkletProcessorPostMessageSupport","moduleURL","credentials","resolvedRequestsOfContext","ongoingRequestsOfContext","promiseOfOngoingRequest","audioWorklet","absoluteUrl","wrappedSource","evaluateAudioWorkletGlobalScope","_AWGS","SyntaxError","nodeNameToProcessorConstructorMap","isSupportingPostMessage","currentIndex","patchedAudioWorkletProcessor","memberDefinition","bufferRegistration","addModule","nativeContextOrBackupOfflineAudioContext","finally","updatedResolvedRequestsOfContext","updatedOngoingRequestsOfContext","createAddAudioWorkletModule","document","script","createElement","originalOnErrorHandler","onerror","removeErrorEventListenerAndRevokeUrl","src","location","href","onload","appendChild","createEvaluateSource","createAbortError","fetch","ok","text","createFetchSource","offlineAudioContext","isEmittingMessageEvents","isEmittingProcessorErrorEvents","oscillator","onprocessorerror","createTestAudioWorkletProcessorPostMessageSupport","isNativeContext","createIsNativeContext","createDataCloneError","createEncodingError","detachedArrayBuffers","anyContext","audioData","fail","createDecodeAudioData","baseAudioContextConstructor","_audioWorklet","constraints","successCallback","errorCallback","createBaseAudioContextConstructor","mediaElementAudioSourceNodeConstructor","createNativeMediaElementAudioSourceNode","nativeMediaElementAudioSourceNode","_nativeMediaElementAudioSourceNode","mediaElement","createMediaElementAudioSourceNodeConstructor","createMediaElementSource","mediaStreamAudioDestinationNodeConstructor","createNativeMediaStreamAudioDestinationNode","nativeMediaStreamAudioDestinationNode","_nativeMediaStreamAudioDestinationNode","stream","createMediaStreamAudioDestinationNodeConstructor","createMediaStreamDestination","mediaStreamAudioSourceNodeConstructor","createNativeMediaStreamAudioSourceNode","nativeMediaStreamAudioSourceNode","_nativeMediaStreamAudioSourceNode","mediaStream","createMediaStreamAudioSourceNodeConstructor","audioStreamTracks","getAudioTracks","sort","filteredAudioStreamTracks","createMediaStreamSource","MediaStream","createNativeMediaStreamTrackAudioSourceNode","mediaStreamTrack","createMediaStreamTrackSource","kind","createNativeMediaStreamTrackAudioSourceNodeFactory","mediaStreamTrackAudioSourceNodeConstructor","nativeMediaStreamTrackAudioSourceNode","createMediaStreamTrackAudioSourceNodeConstructor","getUnrenderedAudioWorkletNodes","createAudioContextConstructor","unrenderedAudioWorkletNodes","createGetUnrenderedAudioWorkletNodes","addUnrenderedAudioWorkletNode","createAddUnrenderedAudioWorkletNode","connectMultipleOutputs","createConnectMultipleOutputs","deleteUnrenderedAudioWorkletNode","createDeleteUnrenderedAudioWorkletNode","disconnectMultipleOutputs","createDisconnectMultipleOutputs","activeAudioWorkletNodeInputsStore","getActiveAudioWorkletNodeInputs","createGetActiveAudioWorkletNodeInputs","createNativeAudioWorkletNodeFaker","numberOfParameters","messageChannel","gainNodes","inputChannelSplitterNodes","constantSourceNodes","inputChannelMergerNode","outputChannelSplitterNode","outputChannelMergerNodes","parameterMap","nativeAudioWorkletNodeFaker","_","patchedEventListeners","unpatchedEventListener","patchedEventListener","audioWorkletProcessorPromise","createAudioWorkletProcessor","dWrkltPrcssr","disconnectOutputsGraph","outputChannelMergerNode","activeInputIndexes","disconnectFakeGraph","connectFakeGraph","createNativeAudioWorkletNodeFakerFactory","createNativeAudioWorkletNode","testClonabilityOfAudioWorkletNodeOptions","createNativeAudioWorkletNodeFactory","createAudioWorkletNodeRenderer","processedBufferPromise","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","renderBuffer","nm","renderedNativeAudioWorkletNodeOrGainNode","createAudioWorkletNodeRendererFactory","getBackupOfflineAudioContext","createGetBackupOfflineAudioContext","setActiveAudioWorkletNodeInputs","createSetActiveAudioWorkletNodeInputs","sanitizeAudioWorkletNodeOptions","testAudioWorkletNodeOptionsClonability","audioWorkletNodeRenderer","_nativeAudioWorkletNode","_onprocessorerror","_parameters","nativeOnProcessorError","createAudioWorkletNodeConstructor","minimalAudioContextConstructor","_baseLatency","_nativeAudioContext","_nativeGainNode","_state","revokeState","resolvePromise","suspend","createMinimalAudioContextConstructor","createNativeOfflineAudioContext","createCreateNativeOfflineAudioContext","createStartRendering","ERROR_MESSAGE","createMinimalOfflineAudioContextConstructor","createOfflineAudioContextConstructor","createIsAnyAudioContext","audioNodeStore","createIsAnyAudioNode","createIsAnyAudioParam","createIsAnyOfflineAudioContext","createPromisedAudioNodesEncoderIdAndPort","audioContext","AudioBufferSourceNode","mediaStreamAudioSourceNode","MediaStreamAudioSourceNode","recorderAudioWorkletNode","encoderRegexes","createBlobEvent","nativeBlobEventConstructor","blobEventInit","eventInit","fakeBlobEvent","Event","createBlobEventFactory","BlobEvent","createNativeBlobEventConstructor","createWebAudioMediaRecorder","eventTarget","getSettings","MinimalAudioContext","bufferedArrayBuffers","promisedAudioWorkletModule","abortRecording","intervalId","promisedAudioNodesAndEncoderId","promisedPartialRecording","isAudioContextRunning","dispatchDataAvailableEvent","requestNextPartialRecording","getVideoTracks","audioTracks","ConstantSourceNode","tracks","getTracks","setInterval","currentTracks","track","createWebAudioMediaRecorderFactory","readVariableSizeInteger","readVariableSizeIntegerLength","dataView","firstDataByteOffset","getUint8","createReadVariableSizeInteger","byte","readElementContent","lengthAndValue","content","numberOfSamples","elementOffset","getFloat32","createReadElementContent","readElementType","createReadElementType","decodeWebMChunk","elementType","contents","currentElementType","lengthAndType","contentAndLength","createDecodeWebMChunk","createWebmPcmMediaRecorder","nativeMediaRecorderConstructor","nativeMediaRecorder","stopRecording","isRecording","pendingInvocations","promisedDataViewElementTypeEncoderIdAndPort","currentDataView","MultiBufferDataView","buffers","byteOffset","remainingDataView","createWebmPcmMediaRecorderFactory","createEventTarget","createEventTargetFactory","MediaRecorder","createNativeMediaRecorderConstructor","createNativeMediaRecorder","mediaRecorderOptions","bufferedBlobs","dataAvailableListeners","errorListeners","stopListeners","wasActive","dataAvailableListener","errorListener","stopListener","startsWith","createNativeMediaRecorderFactory","mediaRecorderConstructor","isTypeSupported","internalMediaRecorder","_internalMediaRecorder","regex","_ondataavailable","_onerror","_onpause","_onresume","_onstart","_onstop","boundListener","createMediaRecorderConstructor","nativeEventTarget","canvasElement","getContext","captureStream","mediaRecorder","createIsSupportedPromise","rgstr","createAddUniqueNumber","number","createCache","lastNumberWeakMap","collection","nextNumber","MAX_SAFE_INTEGER","TWO_TO_THE_POWER_OF_TWENTY_NINE","TWO_TO_THE_POWER_OF_THIRTY","createGenerateUniqueNumber","cache","lastNumber","random","LAST_NUMBER_WEAK_MAP","phrase","word","l_word","alt_cases","indexOf","regexes","_createForOfIteratorHelper","o","allowArrayLike","it","_unsupportedIterableToArray","F","s","n","done","_e","f","normalCompletion","didErr","step","_e2","minLen","_arrayLikeToArray","constructor","arr","len","arr2","availableBytes","_step","dataViews","effectiveByteLength","truncatedBuffers","consumedByteLength","truncatedByteOffset","_iterator","byteLengthOfDataView","DataView","_byteLengthOfDataView","_buffers","_byteLength","_byteOffset","_dataViews","_internalBuffer","ArrayBuffer","littleEndian","setUint8","getFloat64","getInt16","getInt32","_this$_findDataViewWi","_findDataViewWithOffset","_this$_findDataViewWi2","byteOffsetOfDataView","getInt8","getUint16","getUint32","_this$_findDataViewWi3","_this$_findDataViewWi4","setFloat32","setFloat64","setInt16","setInt32","_this$_findDataViewWi5","_this$_findDataViewWi6","setInt8","setUint16","setUint32","_this$_findDataViewWi7","_this$_findDataViewWi8","_step2","_iterator2","byteOffsetOfNextDataView","ReactPropTypesSecret","emptyFunctionWithReset","resetWarningCache","shim","props","propName","componentName","propFullName","secret","getShim","isRequired","ReactPropTypes","bigint","bool","func","symbol","any","arrayOf","instanceOf","node","objectOf","oneOf","oneOfType","shape","exact","checkPropTypes","PropTypes","BreadcrumbItem","React","ref","bsPrefix","active","children","className","as","Component","linkAs","LinkComponent","Anchor","linkProps","title","prefix","useBootstrapPrefix","_jsx","classNames","displayName","defaultProps","Breadcrumb","listProps","label","assign","Item","CardImg","variant","CardHeader","contextValue","useMemo","cardHeaderBsPrefix","CardHeaderContext","DivStyledAsH5","divWithClassName","DivStyledAsH6","CardBody","createWithBsPrefix","CardTitle","CardSubtitle","CardLink","CardText","CardFooter","CardImgOverlay","Card","bg","border","body","Img","Title","Subtitle","Body","Link","Text","Header","Footer","ImgOverlay","Col","breakpoints","useBootstrapBreakpoints","spans","classes","brkPoint","span","order","propValue","infix","useCol","colProps","child","hasChildOfType","propTypes","tooltip","Feedback","FormCheckLabel","htmlFor","controlId","useContext","FormContext","FormCheck","bsSwitchPrefix","inline","disabled","isValid","isInvalid","feedbackTooltip","feedbackType","style","innerFormContext","hasLabel","FormCheckInput","_jsxs","_Fragment","Input","Label","FormControl","htmlSize","plaintext","readOnly","FormGroup","FormLabel","column","visuallyHidden","columnClass","FormRange","FormSelect","FormText","muted","Switch","FloatingLabel","validated","Form","Group","Control","Floating","FormFloating","Check","Range","Select","InputGroupText","InputGroup","hasValidation","InputGroupContext","Radio","Checkbox","Row","decoratedBsPrefix","sizePrefix","cols","p","__awaiter","_arguments","P","generator","fulfilled","rejected","__generator","t","g","sent","trys","ops","verb","v","op","ReactMediaRecorder","useReactMediaRecorder","RecorderErrors","extendable_media_recorder_1","react_1","extendable_media_recorder_wav_encoder_1","_this","_b","audio","_c","video","_d","onStop","onStart","blobPropertyBag","_f","screen","_g","_h","customMediaStream","_j","stopStreamsOnStop","_k","askPermissionOnMount","useRef","mediaChunks","_l","useState","setStatus","_m","isAudioMuted","setIsAudioMuted","_o","mediaBlobUrl","setMediaBlobUrl","_p","setError","useEffect","getMediaStream","useCallback","requiredMedia","stream_1","error_1","current","navigator","mediaDevices","getDisplayMedia","getUserMedia","audioTrack","addTrack","checkConstraints","mediaType","supportedMediaConstraints","getSupportedConstraints","unSupportedConstraints","constraint","console","clone","onRecordingActive","onRecordingStart","onRecordingStop","chunk","blobProperty","muteAudio","mute","enabled","unMuteAudio","startRecording","readyState","ondataavailable","onstop","onstart","pauseRecording","resumeRecording","previewStream","previewAudioStream","clearBlobUrl","l","modules","__webpack_require__","enumerable","hasGetUserMedia","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","_super","hasUserMedia","__extends","Webcam","unmounted","requestUserMedia","warn","onUserMediaError","nextProps","audioConstraintsChanged","JSON","stringify","audioConstraints","videoConstraintsChanged","videoConstraints","minScreenshotWidthChanged","minScreenshotWidth","minScreenshotHeightChanged","minScreenshotHeight","canvas","ctx","stopAndCleanup","removeTrack","stopMediaStream","screenshotDimensions","getCanvas","toDataURL","screenshotFormat","screenshotQuality","videoHeight","canvasWidth","videoWidth","canvasHeight","forceScreenshotSourceSize","aspectRatio","clientWidth","width","height","mirrored","translate","scale","imageSmoothingEnabled","imageSmoothing","drawImage","sourceSelected","requestUserMediaId","myRequestUserMediaId","handleUserMedia","optionalSource_1","optional","sourceId","constraintToSourceId_1","deviceId","ideal","MediaStreamTrack","getSources","sources","audioSource","videoSource","audioSourceId","videoSourceId","setState","srcObject","onUserMedia","rest","videoStyle","__assign","transform","childrenProps","getScreenshot","react__WEBPACK_IMPORTED_MODULE_0__","autoPlay","playsInline","__webpack_exports__","__WEBPACK_EXTERNAL_MODULE_react__","__esModule","arrayLikeToArray","Constructor","_defineProperties","writable","protoProps","staticProps","iter","_i","_s","_arr","_n","arrayWithHoles","iterableToArrayLimit","unsupportedIterableToArray","nonIterableRest","arrayWithoutHoles","iterableToArray","nonIterableSpread"],"sourceRoot":""}